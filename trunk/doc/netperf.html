<html lang="en">
<head>
<title>Care and Feeding of Netperf 2.6.X</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Care and Feeding of Netperf 2.6.X">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="top" href="#Top">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This is Rick Jones' feeble attempt at a Texinfo-based manual for the
netperf benchmark.

Copyright (C) 2005-2012 Hewlett-Packard Company

     Permission is granted to copy, distribute and/or modify this
     document per the terms of the netperf source license, a copy of
     which can be found in the file `COPYING' of the basic netperf
     distribution.
   -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<h1 class="settitle">Care and Feeding of Netperf 2.6.X</h1>
<div class="contents">
<h2>Table of Contents</h2>
<ul>
<li><a name="toc_Top" href="#Top">Netperf Manual</a>
<li><a name="toc_Introduction" href="#Introduction">1 Introduction</a>
<ul>
<li><a href="#Conventions">1.1 Conventions</a>
</li></ul>
<li><a name="toc_Installing-Netperf" href="#Installing-Netperf">2 Installing Netperf</a>
<ul>
<li><a href="#Getting-Netperf-Bits">2.1 Getting Netperf Bits</a>
<li><a href="#Installing-Netperf-Bits">2.2 Installing Netperf</a>
<li><a href="#Verifying-Installation">2.3 Verifying Installation</a>
</li></ul>
<li><a name="toc_The-Design-of-Netperf" href="#The-Design-of-Netperf">3 The Design of Netperf</a>
<ul>
<li><a href="#CPU-Utilization">3.1 CPU Utilization</a>
<ul>
<li><a href="#CPU-Utilization-in-a-Virtual-Guest">3.1.1 CPU Utilization in a Virtual Guest</a>
</li></ul>
</li></ul>
<li><a name="toc_Global-Command_002dline-Options" href="#Global-Command_002dline-Options">4 Global Command-line Options</a>
<ul>
<li><a href="#Command_002dline-Options-Syntax">4.1 Command-line Options Syntax</a>
<li><a href="#Global-Options">4.2 Global Options</a>
</li></ul>
<li><a name="toc_Using-Netperf-to-Measure-Bulk-Data-Transfer" href="#Using-Netperf-to-Measure-Bulk-Data-Transfer">5 Using Netperf to Measure Bulk Data Transfer</a>
<ul>
<li><a href="#Issues-in-Bulk-Transfer">5.1 Issues in Bulk Transfer</a>
<li><a href="#Options-common-to-TCP-UDP-and-SCTP-tests">5.2 Options common to TCP UDP and SCTP tests</a>
<ul>
<li><a href="#TCP_005fSTREAM">5.2.1 TCP_STREAM</a>
<li><a href="#TCP_005fMAERTS">5.2.2 TCP_MAERTS</a>
<li><a href="#TCP_005fSENDFILE">5.2.3 TCP_SENDFILE</a>
<li><a href="#UDP_005fSTREAM">5.2.4 UDP_STREAM</a>
<li><a href="#XTI_005fTCP_005fSTREAM">5.2.5 XTI_TCP_STREAM</a>
<li><a href="#XTI_005fUDP_005fSTREAM">5.2.6 XTI_UDP_STREAM</a>
<li><a href="#SCTP_005fSTREAM">5.2.7 SCTP_STREAM</a>
<li><a href="#DLCO_005fSTREAM">5.2.8 DLCO_STREAM</a>
<li><a href="#DLCL_005fSTREAM">5.2.9 DLCL_STREAM</a>
<li><a href="#STREAM_005fSTREAM">5.2.10 STREAM_STREAM</a>
<li><a href="#DG_005fSTREAM">5.2.11 DG_STREAM</a>
</li></ul>
</li></ul>
<li><a name="toc_Using-Netperf-to-Measure-Request_002fResponse" href="#Using-Netperf-to-Measure-Request_002fResponse">6 Using Netperf to Measure Request/Response</a>
<ul>
<li><a href="#Issues-in-Request_002fResponse">6.1 Issues in Request/Response</a>
<li><a href="#Options-Common-to-TCP-UDP-and-SCTP-_005fRR-tests">6.2 Options Common to TCP UDP and SCTP _RR tests</a>
<ul>
<li><a href="#TCP_005fRR">6.2.1 TCP_RR</a>
<li><a href="#TCP_005fCC">6.2.2 TCP_CC</a>
<li><a href="#TCP_005fCRR">6.2.3 TCP_CRR</a>
<li><a href="#UDP_005fRR">6.2.4 UDP_RR</a>
<li><a href="#XTI_005fTCP_005fRR">6.2.5 XTI_TCP_RR</a>
<li><a href="#XTI_005fTCP_005fCC">6.2.6 XTI_TCP_CC</a>
<li><a href="#XTI_005fTCP_005fCRR">6.2.7 XTI_TCP_CRR</a>
<li><a href="#XTI_005fUDP_005fRR">6.2.8 XTI_UDP_RR</a>
<li><a href="#DLCL_005fRR">6.2.9 DLCL_RR</a>
<li><a href="#DLCO_005fRR">6.2.10 DLCO_RR</a>
<li><a href="#SCTP_005fRR">6.2.11 SCTP_RR</a>
</li></ul>
</li></ul>
<li><a name="toc_Using-Netperf-to-Measure-Aggregate-Performance" href="#Using-Netperf-to-Measure-Aggregate-Performance">7 Using Netperf to Measure Aggregate Performance</a>
<ul>
<li><a href="#Running-Concurrent-Netperf-Tests">7.1 Running Concurrent Netperf Tests</a>
<ul>
<li><a href="#Issues-in-Running-Concurrent-Tests">7.1.1 Issues in Running Concurrent Tests</a>
</li></ul>
<li><a href="#Using-_002d_002denable_002dburst">7.2 Using - -enable-burst</a>
<li><a href="#Using-_002d_002denable_002ddemo">7.3 Using - -enable-demo</a>
</li></ul>
<li><a name="toc_Using-Netperf-to-Measure-Bidirectional-Transfer" href="#Using-Netperf-to-Measure-Bidirectional-Transfer">8 Using Netperf to Measure Bidirectional Transfer</a>
<ul>
<li><a href="#Bidirectional-Transfer-with-Concurrent-Tests">8.1 Bidirectional Transfer with Concurrent Tests</a>
<li><a href="#Bidirectional-Transfer-with-TCP_005fRR">8.2 Bidirectional Transfer with TCP_RR</a>
<li><a href="#Implications-of-Concurrent-Tests-vs-Burst-Request_002fResponse">8.3 Implications of Concurrent Tests vs Burst Request/Response</a>
</li></ul>
<li><a name="toc_The-Omni-Tests" href="#The-Omni-Tests">9 The Omni Tests</a>
<ul>
<li><a href="#Native-Omni-Tests">9.1 Native Omni Tests</a>
<li><a href="#Migrated-Tests">9.2 Migrated Tests</a>
<li><a href="#Omni-Output-Selection">9.3 Omni Output Selection</a>
<ul>
<li><a href="#Omni-Output-Selectors">9.3.1 Omni Output Selectors</a>
</li></ul>
</li></ul>
<li><a name="toc_Other-Netperf-Tests" href="#Other-Netperf-Tests">10 Other Netperf Tests</a>
<ul>
<li><a href="#CPU-rate-calibration">10.1 CPU rate calibration</a>
<li><a href="#UUID-Generation">10.2 UUID Generation</a>
</li></ul>
<li><a name="toc_Address-Resolution" href="#Address-Resolution">11 Address Resolution</a>
<li><a name="toc_Enhancing-Netperf" href="#Enhancing-Netperf">12 Enhancing Netperf</a>
<li><a name="toc_Netperf4" href="#Netperf4">13 Netperf4</a>
<li><a name="toc_Concept-Index" href="#Concept-Index">Concept Index</a>
<li><a name="toc_Option-Index" href="#Option-Index">Option Index</a>
</li></ul>
</div>



<div class="node">
<a name="Top"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Introduction">Introduction</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#dir">(dir)</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#dir">(dir)</a>

</div>

<h2 class="unnumbered">Netperf Manual</h2>

<p>This is Rick Jones' feeble attempt at a Texinfo-based manual for the
netperf benchmark.

   <p>Copyright &copy; 2005-2012 Hewlett-Packard Company
<blockquote>
Permission is granted to copy, distribute and/or modify this document
per the terms of the netperf source license, a copy of which can be
found in the file <samp><span class="file">COPYING</span></samp> of the basic netperf distribution. 
</blockquote>

<ul class="menu">
<li><a accesskey="1" href="#Introduction">Introduction</a>:                 An introduction to netperf - what it
is and what it is not. 
<li><a accesskey="2" href="#Installing-Netperf">Installing Netperf</a>:           How to go about installing netperf. 
<li><a accesskey="3" href="#The-Design-of-Netperf">The Design of Netperf</a>
<li><a accesskey="4" href="#Global-Command_002dline-Options">Global Command-line Options</a>
<li><a accesskey="5" href="#Using-Netperf-to-Measure-Bulk-Data-Transfer">Using Netperf to Measure Bulk Data Transfer</a>
<li><a accesskey="6" href="#Using-Netperf-to-Measure-Request_002fResponse">Using Netperf to Measure Request/Response </a>
<li><a accesskey="7" href="#Using-Netperf-to-Measure-Aggregate-Performance">Using Netperf to Measure Aggregate Performance</a>
<li><a accesskey="8" href="#Using-Netperf-to-Measure-Bidirectional-Transfer">Using Netperf to Measure Bidirectional Transfer</a>
<li><a accesskey="9" href="#The-Omni-Tests">The Omni Tests</a>
<li><a href="#Other-Netperf-Tests">Other Netperf Tests</a>
<li><a href="#Address-Resolution">Address Resolution</a>
<li><a href="#Enhancing-Netperf">Enhancing Netperf</a>
<li><a href="#Netperf4">Netperf4</a>
<li><a href="#Concept-Index">Concept Index</a>
<li><a href="#Option-Index">Option Index</a>
</ul>

<div class="node">
<a name="Introduction"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Installing-Netperf">Installing Netperf</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Top">Top</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">1 Introduction</h2>

<p><a name="index-Introduction-1"></a>
Netperf is a benchmark that can be use to measure various aspect of
networking performance.  The primary foci are bulk (aka
unidirectional) data transfer and request/response performance using
either TCP or UDP and the Berkeley Sockets interface.  As of this
writing, the tests available either unconditionally or conditionally
include:

     <ul>
<li>TCP and UDP unidirectional transfer and request/response over IPv4 and
IPv6 using the Sockets interface. 
<li>TCP and UDP unidirectional transfer and request/response over IPv4
using the XTI interface. 
<li>Link-level unidirectional transfer and request/response using the DLPI
interface. 
<li>Unix domain sockets
<li>SCTP unidirectional transfer and request/response over IPv4 and IPv6
using the sockets interface. 
</ul>

   <p>While not every revision of netperf will work on every platform
listed, the intention is that at least some version of netperf will
work on the following platforms:

     <ul>
<li>Unix - at least all the major variants. 
<li>Linux
<li>Windows
<li>Others
</ul>

   <p>Netperf is maintained and informally supported primarily by Rick
Jones, who can perhaps be best described as Netperf Contributing
Editor.  Non-trivial and very appreciated assistance comes from others
in the network performance community, who are too numerous to mention
here. While it is often used by them, netperf is NOT supported via any
of the formal Hewlett-Packard support channels.  You should feel free
to make enhancements and modifications to netperf to suit your
nefarious porpoises, so long as you stay within the guidelines of the
netperf copyright.  If you feel so inclined, you can send your changes
to
<a href="mailto:netperf-feedback@netperf.org">netperf-feedback</a> for possible
inclusion into subsequent versions of netperf.

   <p>It is the Contributing Editor's belief that the netperf license walks
like open source and talks like open source. However, the license was
never submitted for &ldquo;certification&rdquo; as an open source license.  If
you would prefer to make contributions to a networking benchmark using
a certified open source license, please consider netperf4, which is
distributed under the terms of the GPLv2.

   <p>The <a href="mailto:netperf-talk@netperf.org">netperf-talk</a> mailing list is
available to discuss the care and feeding of netperf with others who
share your interest in network performance benchmarking. The
netperf-talk mailing list is a closed list (to deal with spam) and you
must first subscribe by sending email to
<a href="mailto:netperf-talk-request@netperf.org">netperf-talk-request</a>.

<ul class="menu">
<li><a accesskey="1" href="#Conventions">Conventions</a>
</ul>

<div class="node">
<a name="Conventions"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Introduction">Introduction</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Introduction">Introduction</a>

</div>

<h3 class="section">1.1 Conventions</h3>

<p>A <dfn>sizespec</dfn> is a one or two item, comma-separated list used as an
argument to a command-line option that can set one or two, related
netperf parameters.  If you wish to set both parameters to separate
values, items should be separated by a comma:

<pre class="example">     parameter1,parameter2
</pre>
   <p>If you wish to set the first parameter without altering the value of
the second from its default, you should follow the first item with a
comma:

<pre class="example">     parameter1,
</pre>
   <p>Likewise, precede the item with a comma if you wish to set only the
second parameter:

<pre class="example">     ,parameter2
</pre>
   <p>An item with no commas:

<pre class="example">     parameter1and2
</pre>
   <p>will set both parameters to the same value.  This last mode is one of
the most frequently used.

   <p>There is another variant of the comma-separated, two-item list called
a <dfn>optionspec</dfn> which is like a sizespec with the exception that a
single item with no comma:

<pre class="example">     parameter1
</pre>
   <p>will only set the value of the first parameter and will leave the
second parameter at its default value.

   <p>Netperf has two types of command-line options.  The first are global
command line options.  They are essentially any option not tied to a
particular test or group of tests.  An example of a global
command-line option is the one which sets the test type - <samp><span class="option">-t</span></samp>.

   <p>The second type of options are test-specific options.  These are
options which are only applicable to a particular test or set of
tests.  An example of a test-specific option would be the send socket
buffer size for a TCP_STREAM test.

   <p>Global command-line options are specified first with test-specific
options following after a <code>--</code> as in:

<pre class="example">     netperf &lt;global&gt; -- &lt;test-specific&gt;
</pre>
   <div class="node">
<a name="Installing-Netperf"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#The-Design-of-Netperf">The Design of Netperf</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Introduction">Introduction</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">2 Installing Netperf</h2>

<p><a name="index-Installation-2"></a>
Netperf's primary form of distribution is source code.  This allows
installation on systems other than those to which the authors have
ready access and thus the ability to create binaries.  There are two
styles of netperf installation.  The first runs the netperf server
program - netserver - as a child of inetd.  This requires the
installer to have sufficient privileges to edit the files
<samp><span class="file">/etc/services</span></samp> and <samp><span class="file">/etc/inetd.conf</span></samp> or their
platform-specific equivalents.

   <p>The second style is to run netserver as a standalone daemon.  This
second method does not require edit privileges on <samp><span class="file">/etc/services</span></samp>
and <samp><span class="file">/etc/inetd.conf</span></samp> but does mean you must remember to run the
netserver program explicitly after every system reboot.

   <p>This manual assumes that those wishing to measure networking
performance already know how to use anonymous FTP and/or a web
browser. It is also expected that you have at least a passing
familiarity with the networking protocols and interfaces involved. In
all honesty, if you do not have such familiarity, likely as not you
have some experience to gain before attempting network performance
measurements.  The excellent texts by authors such as Stevens, Fenner
and Rudoff and/or Stallings would be good starting points. There are
likely other excellent sources out there as well.

<ul class="menu">
<li><a accesskey="1" href="#Getting-Netperf-Bits">Getting Netperf Bits</a>
<li><a accesskey="2" href="#Installing-Netperf-Bits">Installing Netperf Bits</a>
<li><a accesskey="3" href="#Verifying-Installation">Verifying Installation</a>
</ul>

<div class="node">
<a name="Getting-Netperf-Bits"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Installing-Netperf-Bits">Installing Netperf Bits</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Installing-Netperf">Installing Netperf</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Installing-Netperf">Installing Netperf</a>

</div>

<h3 class="section">2.1 Getting Netperf Bits</h3>

<p>Gzipped tar files of netperf sources can be retrieved via
<a href="ftp://ftp.netperf.org/netperf">anonymous FTP</a>
for &ldquo;released&rdquo; versions of the bits.  Pre-release versions of the
bits can be retrieved via anonymous FTP from the
<a href="ftp://ftp.netperf.org/netperf/experimental">experimental</a> subdirectory.

   <p>For convenience and ease of remembering, a link to the download site
is provided via the
<a href="http://www.netperf.org/">NetperfPage</a>

   <p>The bits corresponding to each discrete release of netperf are
<a href="http://www.netperf.org/svn/netperf2/tags">tagged</a> for retrieval
via subversion.  For example, there is a tag for the first version
corresponding to this version of the manual -
<a href="http://www.netperf.org/svn/netperf2/tags/netperf-2.6.0">netperf 2.6.0</a>.  Those wishing to be on the bleeding edge of netperf
development can use subversion to grab the
<a href="http://www.netperf.org/svn/netperf2/trunk">top of trunk</a>.  When
fixing bugs or making enhancements, patches against the top-of-trunk
are preferred.

   <p>There are likely other places around the Internet from which one can
download netperf bits.  These may be simple mirrors of the main
netperf site, or they may be local variants on netperf.  As with
anything one downloads from the Internet, take care to make sure it is
what you really wanted and isn't some malicious Trojan or whatnot. 
Caveat downloader.

   <p>As a general rule, binaries of netperf and netserver are not
distributed from ftp.netperf.org.  From time to time a kind soul or
souls has packaged netperf as a Debian package available via the
apt-get mechanism or as an RPM.  I would be most interested in
learning how to enhance the makefiles to make that easier for people.

<div class="node">
<a name="Installing-Netperf-Bits"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Verifying-Installation">Verifying Installation</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Getting-Netperf-Bits">Getting Netperf Bits</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Installing-Netperf">Installing Netperf</a>

</div>

<h3 class="section">2.2 Installing Netperf</h3>

<p>Once you have downloaded the tar file of netperf sources onto your
system(s), it is necessary to unpack the tar file, cd to the netperf
directory, run configure and then make.  Most of the time it should be
sufficient to just:

<pre class="example">     gzcat netperf-&lt;version&gt;.tar.gz | tar xf -
     cd netperf-&lt;version&gt;
     ./configure
     make
     make install
</pre>
   <p>Most of the &ldquo;usual&rdquo; configure script options should be present
dealing with where to install binaries and whatnot.
<pre class="example">     ./configure --help
</pre>
   <p>should list all of those and more.  You may find the <code>--prefix</code>
option helpful in deciding where the binaries and such will be put
during the <code>make install</code>.

   <p><a name="index-g_t_002d_002denable_002dcpuutil_002c-Configure-3"></a>If the netperf configure script does not know how to automagically
detect which CPU utilization mechanism to use on your platform you may
want to add a <code>--enable-cpuutil=mumble</code> option to the configure
command.   If you have knowledge and/or experience to contribute to
that area, feel free to contact <a href="mailto:netperf-feedback@netperf.org">netperf-feedback@netperf.org</a>.

   <p><a name="index-g_t_002d_002denable_002dxti_002c-Configure-4"></a><a name="index-g_t_002d_002denable_002dunixdomain_002c-Configure-5"></a><a name="index-g_t_002d_002denable_002ddlpi_002c-Configure-6"></a><a name="index-g_t_002d_002denable_002dsctp_002c-Configure-7"></a>Similarly, if you want tests using the XTI interface, Unix Domain
Sockets, DLPI or SCTP it will be necessary to add one or more
<code>--enable-[xti|unixdomain|dlpi|sctp]=yes</code> options to the configure
command.  As of this writing, the configure script will not include
those tests automagically.

   <p><a name="index-g_t_002d_002denable_002domni_002c-Configure-8"></a>Starting with version 2.5.0, netperf began migrating most of the
&ldquo;classic&rdquo; netperf tests found in <samp><span class="file">src/nettest_bsd.c</span></samp> to the
so-called &ldquo;omni&rdquo; tests (aka &ldquo;two routines to run them all&rdquo;) found
in <samp><span class="file">src/nettest_omni.c</span></samp>.  This migration enables a number of new
features such as greater control over what output is included, and new
things to output.  The &ldquo;omni&rdquo; test is enabled by default in 2.5.0
and a number of the classic tests are migrated - you can tell if a
test has been migrated
from the presence of <code>MIGRATED</code> in the test banner.  If you
encounter problems with either the omni or migrated tests, please
first attempt to obtain resolution via
<a href="mailto:netperf-talk@netperf.org">netperf-talk@netperf.org</a> or
<a href="mailto:netperf-feedback@netperf.org">netperf-feedback@netperf.org</a>.  If that is unsuccessful, you
can add a <code>--enable-omni=no</code> to the configure command and the
omni tests will not be compiled-in and the classic tests will not be
migrated.

   <p>Starting with version 2.5.0, netperf includes the &ldquo;burst mode&rdquo;
functionality in a default compilation of the bits.  If you encounter
problems with this, please first attempt to obtain help via
<a href="mailto:netperf-talk@netperf.org">netperf-talk@netperf.org</a> or
<a href="mailto:netperf-feedback@netperf.org">netperf-feedback@netperf.org</a>.  If that is unsuccessful, you
can add a <code>--enable-burst=no</code> to the configure command and the
burst mode functionality will not be compiled-in.

   <p>On some platforms, it may be necessary to precede the configure
command with a CFLAGS and/or LIBS variable as the netperf configure
script is not yet smart enough to set them itself.  Whenever possible,
these requirements will be found in <samp><span class="file">README.</span><var>platform</var></samp> files. 
Expertise and assistance in making that more automagic in the
configure script would be most welcome.

   <p><a name="index-Limiting-Bandwidth-9"></a><a name="index-Bandwidth-Limitation-10"></a><a name="index-g_t_002d_002denable_002dintervals_002c-Configure-11"></a><a name="index-g_t_002d_002denable_002dhistogram_002c-Configure-12"></a>Other optional configure-time settings include
<code>--enable-intervals=yes</code> to give netperf the ability to &ldquo;pace&rdquo;
its _STREAM tests and <code>--enable-histogram=yes</code> to have netperf
keep a histogram of interesting times.  Each of these will have some
effect on the measured result.  If your system supports
<code>gethrtime()</code> the effect of the histogram measurement should be
minimized but probably still measurable.  For example, the histogram
of a netperf TCP_RR test will be of the individual transaction times:
<pre class="example">     netperf -t TCP_RR -H lag -v 2
     TCP REQUEST/RESPONSE TEST from 0.0.0.0 (0.0.0.0) port 0 AF_INET to lag.hpl.hp.com (15.4.89.214) port 0 AF_INET : histogram
     Local /Remote
     Socket Size   Request  Resp.   Elapsed  Trans.
     Send   Recv   Size     Size    Time     Rate
     bytes  Bytes  bytes    bytes   secs.    per sec
     
     16384  87380  1        1       10.00    3538.82
     32768  32768
     Alignment      Offset
     Local  Remote  Local  Remote
     Send   Recv    Send   Recv
         8      0       0      0
     Histogram of request/response times
     UNIT_USEC     :    0:    0:    0:    0:    0:    0:    0:    0:    0:    0
     TEN_USEC      :    0:    0:    0:    0:    0:    0:    0:    0:    0:    0
     HUNDRED_USEC  :    0: 34480:  111:   13:   12:    6:    9:    3:    4:    7
     UNIT_MSEC     :    0:   60:   50:   51:   44:   44:   72:  119:  100:  101
     TEN_MSEC      :    0:  105:    0:    0:    0:    0:    0:    0:    0:    0
     HUNDRED_MSEC  :    0:    0:    0:    0:    0:    0:    0:    0:    0:    0
     UNIT_SEC      :    0:    0:    0:    0:    0:    0:    0:    0:    0:    0
     TEN_SEC       :    0:    0:    0:    0:    0:    0:    0:    0:    0:    0
     &gt;100_SECS: 0
     HIST_TOTAL:      35391
</pre>
   <p>The histogram you see above is basically a base-10 log histogram where
we can see that most of the transaction times were on the order of one
hundred to one-hundred, ninety-nine microseconds, but they were
occasionally as long as ten to nineteen milliseconds

   <p>The <samp><span class="option">--enable-demo=yes</span></samp> configure option will cause code to be
included to report interim results during a test run.  The rate at
which interim results are reported can then be controlled via the
global <samp><span class="option">-D</span></samp> option.  Here is an example of <samp><span class="option">-D</span></samp> output:

<pre class="example">     $ src/netperf -D 1.35 -H tardy.hpl.hp.com -f M
     MIGRATED TCP STREAM TEST from 0.0.0.0 (0.0.0.0) port 0 AF_INET to tardy.hpl.hp.com (15.9.116.144) port 0 AF_INET : demo
     Interim result:    5.41 MBytes/s over 1.35 seconds ending at 1308789765.848
     Interim result:   11.07 MBytes/s over 1.36 seconds ending at 1308789767.206
     Interim result:   16.00 MBytes/s over 1.36 seconds ending at 1308789768.566
     Interim result:   20.66 MBytes/s over 1.36 seconds ending at 1308789769.922
     Interim result:   22.74 MBytes/s over 1.36 seconds ending at 1308789771.285
     Interim result:   23.07 MBytes/s over 1.36 seconds ending at 1308789772.647
     Interim result:   23.77 MBytes/s over 1.37 seconds ending at 1308789774.016
     Recv   Send    Send
     Socket Socket  Message  Elapsed
     Size   Size    Size     Time     Throughput
     bytes  bytes   bytes    secs.    MBytes/sec
     
      87380  16384  16384    10.06      17.81
</pre>
   <p>Notice how the units of the interim result track that requested by the
<samp><span class="option">-f</span></samp> option.  Also notice that sometimes the interval will be
longer than the value specified in the <samp><span class="option">-D</span></samp> option.  This is
normal and stems from how demo mode is implemented not by relying on
interval timers or frequent calls to get the current time, but by
calculating how many units of work must be performed to take at least
the desired interval.

   <p>Those familiar with this option in earlier versions of netperf will
note the addition of the &ldquo;ending at&rdquo; text.  This is the time as
reported by a <code>gettimeofday()</code> call (or its emulation) with a
<code>NULL</code> timezone pointer.  This addition is intended to make it
easier to insert interim results into an
<a href="http://oss.oetiker.ch/rrdtool/doc/rrdtool.en.html">rrdtool</a>
Round-Robin Database (RRD).  A likely bug-riddled example of doing so
can be found in <samp><span class="file">doc/examples/netperf_interim_to_rrd.sh</span></samp>.  The
time is reported out to milliseconds rather than microseconds because
that is the most rrdtool understands as of the time of this writing.

   <p>As of this writing, a <code>make install</code> will not actually update the
files <samp><span class="file">/etc/services</span></samp> and/or <samp><span class="file">/etc/inetd.conf</span></samp> or their
platform-specific equivalents.  It remains necessary to perform that
bit of installation magic by hand.  Patches to the makefile sources to
effect an automagic editing of the necessary files to have netperf
installed as a child of inetd would be most welcome.

   <p>Starting the netserver as a standalone daemon should be as easy as:
<pre class="example">     $ netserver
     Starting netserver at port 12865
     Starting netserver at hostname 0.0.0.0 port 12865 and family 0
</pre>
   <p>Over time the specifics of the messages netserver prints to the screen
may change but the gist will remain the same.

   <p>If the compilation of netperf or netserver happens to fail, feel free
to contact <a href="mailto:netperf-feedback@netperf.org">netperf-feedback@netperf.org</a> or join and ask in
<a href="mailto:netperf-talk@netperf.org">netperf-talk@netperf.org</a>.  However, it is quite important
that you include the actual compilation errors and perhaps even the
configure log in your email.  Otherwise, it will be that much more
difficult for someone to assist you.

<div class="node">
<a name="Verifying-Installation"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Installing-Netperf-Bits">Installing Netperf Bits</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Installing-Netperf">Installing Netperf</a>

</div>

<h3 class="section">2.3 Verifying Installation</h3>

<p>Basically, once netperf is installed and netserver is configured as a
child of inetd, or launched as a standalone daemon, simply typing:
<pre class="example">     netperf
</pre>
   <p>should result in output similar to the following:
<pre class="example">     $ netperf
     TCP STREAM TEST from 0.0.0.0 (0.0.0.0) port 0 AF_INET to localhost.localdomain (127.0.0.1) port 0 AF_INET
     Recv   Send    Send
     Socket Socket  Message  Elapsed
     Size   Size    Size     Time     Throughput
     bytes  bytes   bytes    secs.    10^6bits/sec
     
      87380  16384  16384    10.00    2997.84
</pre>
   <div class="node">
<a name="The-Design-of-Netperf"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Global-Command_002dline-Options">Global Command-line Options</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Installing-Netperf">Installing Netperf</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">3 The Design of Netperf</h2>

<p><a name="index-Design-of-Netperf-13"></a>
Netperf is designed around a basic client-server model.  There are
two executables - netperf and netserver.  Generally you will only
execute the netperf program, with the netserver program being invoked
by the remote system's inetd or having been previously started as its
own standalone daemon.

   <p>When you execute netperf it will establish a &ldquo;control connection&rdquo; to
the remote system.  This connection will be used to pass test
configuration information and results to and from the remote system. 
Regardless of the type of test to be run, the control connection will
be a TCP connection using BSD sockets.  The control connection can use
either IPv4 or IPv6.

   <p>Once the control connection is up and the configuration information
has been passed, a separate &ldquo;data&rdquo; connection will be opened for the
measurement itself using the API's and protocols appropriate for the
specified test.  When the test is completed, the data connection will
be torn-down and results from the netserver will be passed-back via the
control connection and combined with netperf's result for display to
the user.

   <p>Netperf places no traffic on the control connection while a test is in
progress.  Certain TCP options, such as SO_KEEPALIVE, if set as your
systems' default, may put packets out on the control connection while
a test is in progress.  Generally speaking this will have no effect on
the results.

<ul class="menu">
<li><a accesskey="1" href="#CPU-Utilization">CPU Utilization</a>
</ul>

<div class="node">
<a name="CPU-Utilization"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#The-Design-of-Netperf">The Design of Netperf</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#The-Design-of-Netperf">The Design of Netperf</a>

</div>

<h3 class="section">3.1 CPU Utilization</h3>

<p><a name="index-CPU-Utilization-14"></a>
CPU utilization is an important, and alas all-too infrequently
reported component of networking performance.  Unfortunately, it can
be one of the most difficult metrics to measure accurately and
portably.  Netperf will do its level best to report accurate
CPU utilization figures, but some combinations of processor, OS and
configuration may make that difficult.

   <p>CPU utilization in netperf is reported as a value between 0 and 100%
regardless of the number of CPUs involved.  In addition to CPU
utilization, netperf will report a metric called a <dfn>service
demand</dfn>.  The service demand is the normalization of CPU utilization
and work performed.  For a _STREAM test it is the microseconds of CPU
time consumed to transfer on KB (K == 1024) of data.  For a _RR test
it is the microseconds of CPU time consumed processing a single
transaction.   For both CPU utilization and service demand, lower is
better.

   <p>Service demand can be particularly useful when trying to gauge the
effect of a performance change.  It is essentially a measure of
efficiency, with smaller values being more efficient and thus
&ldquo;better.&rdquo;

   <p>Netperf is coded to be able to use one of several, generally
platform-specific CPU utilization measurement mechanisms.  Single
letter codes will be included in the CPU portion of the test banner to
indicate which mechanism was used on each of the local (netperf) and
remote (netserver) system.

   <p>As of this writing those codes are:

     <dl>
<dt><code>U</code><dd>The CPU utilization measurement mechanism was unknown to netperf or
netperf/netserver was not compiled to include CPU utilization
measurements. The code for the null CPU utilization mechanism can be
found in <samp><span class="file">src/netcpu_none.c</span></samp>. 
<br><dt><code>I</code><dd>An HP-UX-specific CPU utilization mechanism whereby the kernel
incremented a per-CPU counter by one for each trip through the idle
loop. This mechanism was only available on specially-compiled HP-UX
kernels prior to HP-UX 10 and is mentioned here only for the sake of
historical completeness and perhaps as a suggestion to those who might
be altering other operating systems. While rather simple, perhaps even
simplistic, this mechanism was quite robust and was not affected by
the concerns of statistical methods, or methods attempting to track
time in each of user, kernel, interrupt and idle modes which require
quite careful accounting.  It can be thought-of as the in-kernel
version of the looper <code>L</code> mechanism without the context switch
overhead. This mechanism required calibration. 
<br><dt><code>P</code><dd>An HP-UX-specific CPU utilization mechanism whereby the kernel
keeps-track of time (in the form of CPU cycles) spent in the kernel
idle loop (HP-UX 10.0 to 11.31 inclusive), or where the kernel keeps
track of time spent in idle, user, kernel and interrupt processing
(HP-UX 11.23 and later).  The former requires calibration, the latter
does not.  Values in either case are retrieved via one of the pstat(2)
family of calls, hence the use of the letter <code>P</code>.  The code for
these mechanisms is found in <samp><span class="file">src/netcpu_pstat.c</span></samp> and
<samp><span class="file">src/netcpu_pstatnew.c</span></samp> respectively. 
<br><dt><code>K</code><dd>A Solaris-specific CPU utilization mechanism whereby the kernel keeps
track of ticks (eg HZ) spent in the idle loop.  This method is
statistical and is known to be inaccurate when the interrupt rate is
above epsilon as time spent processing interrupts is not subtracted
from idle.  The value is retrieved via a kstat() call - hence the use
of the letter <code>K</code>.  Since this mechanism uses units of ticks (HZ)
the calibration value should invariably match HZ. (Eg 100) The code
for this mechanism is implemented in <samp><span class="file">src/netcpu_kstat.c</span></samp>. 
<br><dt><code>M</code><dd>A Solaris-specific mechanism available on Solaris 10 and latter which
uses the new microstate accounting mechanisms.  There are two, alas,
overlapping, mechanisms.  The first tracks nanoseconds spent in user,
kernel, and idle modes. The second mechanism tracks nanoseconds spent
in interrupt.  Since the mechanisms overlap, netperf goes through some
hand-waving to try to &ldquo;fix&rdquo; the problem.  Since the accuracy of the
handwaving cannot be completely determined, one must presume that
while better than the <code>K</code> mechanism, this mechanism too is not
without issues.  The values are retrieved via kstat() calls, but the
letter code is set to <code>M</code> to distinguish this mechanism from the
even less accurate <code>K</code> mechanism.  The code for this mechanism is
implemented in <samp><span class="file">src/netcpu_kstat10.c</span></samp>. 
<br><dt><code>L</code><dd>A mechanism based on &ldquo;looper&rdquo;or &ldquo;soaker&rdquo; processes which sit in
tight loops counting as fast as they possibly can. This mechanism
starts a looper process for each known CPU on the system.  The effect
of processor hyperthreading on the mechanism is not yet known.  This
mechanism definitely requires calibration.  The code for the
&ldquo;looper&rdquo;mechanism can be found in <samp><span class="file">src/netcpu_looper.c</span></samp>
<br><dt><code>N</code><dd>A Microsoft Windows-specific mechanism, the code for which can be
found in <samp><span class="file">src/netcpu_ntperf.c</span></samp>.  This mechanism too is based on
what appears to be a form of micro-state accounting and requires no
calibration.  On laptops, or other systems which may dynamically alter
the CPU frequency to minimize power consumption, it has been suggested
that this mechanism may become slightly confused, in which case using
BIOS/uEFI settings to disable the power saving would be indicated.

     <br><dt><code>S</code><dd>This mechanism uses <samp><span class="file">/proc/stat</span></samp> on Linux to retrieve time
(ticks) spent in idle mode.  It is thought but not known to be
reasonably accurate.  The code for this mechanism can be found in
<samp><span class="file">src/netcpu_procstat.c</span></samp>. 
<br><dt><code>C</code><dd>A mechanism somewhat similar to <code>S</code> but using the sysctl() call
on BSD-like Operating systems (*BSD and MacOS X).  The code for this
mechanism can be found in <samp><span class="file">src/netcpu_sysctl.c</span></samp>. 
<br><dt><code>Others</code><dd>Other mechanisms included in netperf in the past have included using
the times() and getrusage() calls.  These calls are actually rather
poorly suited to the task of measuring CPU overhead for networking as
they tend to be process-specific and much network-related processing
can happen outside the context of a process, in places where it is not
a given it will be charged to the correct, or even a process.  They
are mentioned here as a warning to anyone seeing those mechanisms used
in other networking benchmarks.  These mechanisms are not available in
netperf 2.4.0 and later. 
</dl>

   <p>For many platforms, the configure script will chose the best available
CPU utilization mechanism.  However, some platforms have no
particularly good mechanisms.  On those platforms, it is probably best
to use the &ldquo;LOOPER&rdquo; mechanism which is basically some number of
processes (as many as there are processors) sitting in tight little
loops counting as fast as they can.  The rate at which the loopers
count when the system is believed to be idle is compared with the rate
when the system is running netperf and the ratio is used to compute
CPU utilization.

   <p>In the past, netperf included some mechanisms that only reported CPU
time charged to the calling process.  Those mechanisms have been
removed from netperf versions 2.4.0 and later because they are
hopelessly inaccurate.  Networking can and often results in CPU time
being spent in places - such as interrupt contexts - that do not get
charged to a or the correct process.

   <p>In fact, time spent in the processing of interrupts is a common issue
for many CPU utilization mechanisms.  In particular, the &ldquo;PSTAT&rdquo;
mechanism was eventually known to have problems accounting for certain
interrupt time prior to HP-UX 11.11 (11iv1).  HP-UX 11iv2 and later
are known/presumed to be good. The &ldquo;KSTAT&rdquo; mechanism is known to
have problems on all versions of Solaris up to and including Solaris
10.  Even the microstate accounting available via kstat in Solaris 10
has issues, though perhaps not as bad as those of prior versions.

   <p>The /proc/stat mechanism under Linux is in what the author would
consider an &ldquo;uncertain&rdquo; category as it appears to be statistical,
which may also have issues with time spent processing interrupts.

   <p>In summary, be sure to &ldquo;sanity-check&rdquo; the CPU utilization figures
with other mechanisms.  However, platform tools such as top, vmstat or
mpstat are often based on the same mechanisms used by netperf.

<ul class="menu">
<li><a accesskey="1" href="#CPU-Utilization-in-a-Virtual-Guest">CPU Utilization in a Virtual Guest</a>
</ul>

<div class="node">
<a name="CPU-Utilization-in-a-Virtual-Guest"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#CPU-Utilization">CPU Utilization</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#CPU-Utilization">CPU Utilization</a>

</div>

<h4 class="subsection">3.1.1 CPU Utilization in a Virtual Guest</h4>

<p>The CPU utilization mechanisms used by netperf are &ldquo;inline&rdquo; in that
they are run by the same netperf or netserver process as is running
the test itself.  This works just fine for &ldquo;bare iron&rdquo; tests but
runs into a problem when using virtual machines.

   <p>The relationship between virtual guest and hypervisor can be thought
of as being similar to that between a process and kernel in a bare
iron system.  As such, (m)any CPU utilization mechanisms used in the
virtual guest are similar to &ldquo;process-local&rdquo; mechanisms in a bare
iron situation.  However, just as with bare iron and process-local
mechanisms, much networking processing happens outside the context of
the virtual guest.  It takes place in the hypervisor, and is not
visible to mechanisms running in the guest(s).  For this reason, one
should not really trust CPU utilization figures reported by netperf or
netserver when running in a virtual guest.

   <p>If one is looking to measure the added overhead of a virtualization
mechanism, rather than rely on CPU utilization, one can rely instead
on netperf _RR tests - path-lengths and overheads can be a significant
fraction of the latency, so increases in overhead should appear as
decreases in transaction rate.  Whatever you do, <b>DO NOT</b> rely on
the throughput of a _STREAM test.  Achieving link-rate can be done via
a multitude of options that mask overhead rather than eliminate it.

<div class="node">
<a name="Global-Command-line-Options"></a>
<a name="Global-Command_002dline-Options"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Using-Netperf-to-Measure-Bulk-Data-Transfer">Using Netperf to Measure Bulk Data Transfer</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#The-Design-of-Netperf">The Design of Netperf</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">4 Global Command-line Options</h2>

<p>This section describes each of the global command-line options
available in the netperf and netserver binaries.  Essentially, it is
an expanded version of the usage information displayed by netperf or
netserver when invoked with the <samp><span class="option">-h</span></samp> global command-line
option.

<ul class="menu">
<li><a accesskey="1" href="#Command_002dline-Options-Syntax">Command-line Options Syntax</a>
<li><a accesskey="2" href="#Global-Options">Global Options</a>
</ul>

<div class="node">
<a name="Command-line-Options-Syntax"></a>
<a name="Command_002dline-Options-Syntax"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Global-Options">Global Options</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Global-Command_002dline-Options">Global Command-line Options</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Global-Command_002dline-Options">Global Command-line Options</a>

</div>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">4.1 Command-line Options Syntax</h3>

<p>Revision 1.8 of netperf introduced enough new functionality to overrun
the English alphabet for mnemonic command-line option names, and the
author was not and is not quite ready to switch to the contemporary
<samp><span class="option">--mumble</span></samp> style of command-line options. (Call him a Luddite
if you wish :).

   <p>For this reason, the command-line options were split into two parts -
the first are the global command-line options.  They are options that
affect nearly any and every test type of netperf.  The second type are
the test-specific command-line options.  Both are entered on the same
command line, but they must be separated from one another by a <code>--</code>
for correct parsing.  Global command-line options come first, followed
by the <code>--</code> and then test-specific command-line options.  If there
are no test-specific options to be set, the <code>--</code> may be omitted.  If
there are no global command-line options to be set, test-specific
options must still be preceded by a <code>--</code>.  For example:
<pre class="example">     netperf &lt;global&gt; -- &lt;test-specific&gt;
</pre>
   <p>sets both global and test-specific options:
<pre class="example">     netperf &lt;global&gt;
</pre>
   <p>sets just global options and:
<pre class="example">     netperf -- &lt;test-specific&gt;
</pre>
   <p>sets just test-specific options.

<div class="node">
<a name="Global-Options"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Command_002dline-Options-Syntax">Command-line Options Syntax</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Global-Command_002dline-Options">Global Command-line Options</a>

</div>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">4.2 Global Options</h3>

     
<a name="index-g_t_002da_002c-Global-15"></a>
<dl><dt><code>-a &lt;sizespec&gt;</code><dd>This option allows you to alter the alignment of the buffers used in
the sending and receiving calls on the local system.. Changing the
alignment of the buffers can force the system to use different copy
schemes, which can have a measurable effect on performance.  If the
page size for the system were 4096 bytes, and you want to pass
page-aligned buffers beginning on page boundaries, you could use
&lsquo;<samp><span class="samp">-a 4096</span></samp>&rsquo;.  By default the units are bytes, but suffix of &ldquo;G,&rdquo;
&ldquo;M,&rdquo; or &ldquo;K&rdquo; will specify the units to be 2^30 (GB), 2^20 (MB) or
2^10 (KB) respectively. A suffix of &ldquo;g,&rdquo; &ldquo;m&rdquo; or &ldquo;k&rdquo; will specify
units of 10^9, 10^6 or 10^3 bytes respectively. [Default: 8 bytes]

     <p><a name="index-g_t_002dA_002c-Global-16"></a><br><dt><code>-A &lt;sizespec&gt;</code><dd>This option is identical to the <samp><span class="option">-a</span></samp> option with the difference
being it affects alignments for the remote system.

     <p><a name="index-g_t_002db_002c-Global-17"></a><br><dt><code>-b &lt;size&gt;</code><dd>This option is only present when netperf has been configure with
&ndash;enable-intervals=yes prior to compilation.  It sets the size of the
burst of send calls in a _STREAM test.  When used in conjunction with
the <samp><span class="option">-w</span></samp> option it can cause the rate at which data is sent to
be &ldquo;paced.&rdquo;

     <p><a name="index-g_t_002dB_002c-Global-18"></a><br><dt><code>-B &lt;string&gt;</code><dd>This option will cause <samp><span class="option">&lt;string&gt;</span></samp> to be appended to the brief
(see -P) output of netperf.

     <p><a name="index-g_t_002dc_002c-Global-19"></a><br><dt><code>-c [rate]</code><dd>This option will ask that CPU utilization and service demand be
calculated for the local system.  For those CPU utilization mechanisms
requiring calibration, the options rate parameter may be specified to
preclude running another calibration step, saving 40 seconds of time. 
For those CPU utilization mechanisms requiring no calibration, the
optional rate parameter will be utterly and completely ignored. 
[Default: no CPU measurements]

     <p><a name="index-g_t_002dC_002c-Global-20"></a><br><dt><code>-C [rate]</code><dd>This option requests CPU utilization and service demand calculations
for the remote system.  It is otherwise identical to the <samp><span class="option">-c</span></samp>
option.

     <p><a name="index-g_t_002dd_002c-Global-21"></a><br><dt><code>-d</code><dd>Each instance of this option will increase the quantity of debugging
output displayed during a test.  If the debugging output level is set
high enough, it may have a measurable effect on performance. 
Debugging information for the local system is printed to stdout. 
Debugging information for the remote system is sent by default to the
file <samp><span class="file">/tmp/netperf.debug</span></samp>. [Default: no debugging output]

     <p><a name="index-g_t_002dD_002c-Global-22"></a><br><dt><code>-D [interval,units]</code><dd>This option is only available when netperf is configured with
&ndash;enable-demo=yes.  When set, it will cause netperf to emit periodic
reports of performance during the run.  [<var>interval</var>,<var>units</var>]
follow the semantics of an optionspec. If specified,
<var>interval</var> gives the minimum interval in real seconds, it does not
have to be whole seconds.  The <var>units</var> value can be used for the
first guess as to how many units of work (bytes or transactions) must
be done to take at least <var>interval</var> seconds. If omitted,
<var>interval</var> defaults to one second and <var>units</var> to values
specific to each test type.

     <p><a name="index-g_t_002df_002c-Global-23"></a><br><dt><code>-f G|M|K|g|m|k|x</code><dd>This option can be used to change the reporting units for _STREAM
tests.  Arguments of &ldquo;G,&rdquo; &ldquo;M,&rdquo; or &ldquo;K&rdquo; will set the units to
2^30, 2^20 or 2^10 bytes/s respectively (EG power of two GB, MB or
KB).  Arguments of &ldquo;g,&rdquo; &ldquo;,m&rdquo; or &ldquo;k&rdquo; will set the units to 10^9,
10^6 or 10^3 bits/s respectively.  An argument of &ldquo;x&rdquo; requests the
units be transactions per second and is only meaningful for a
request-response test. [Default: &ldquo;m&rdquo; or 10^6 bits/s]

     <p><a name="index-g_t_002dF_002c-Global-24"></a><br><dt><code>-F &lt;fillfile&gt;</code><dd>This option specified the file from which send which buffers will be
pre-filled .  While the buffers will contain data from the specified
file, the file is not fully transferred to the remote system as the
receiving end of the test will not write the contents of what it
receives to a file.  This can be used to pre-fill the send buffers
with data having different compressibility and so is useful when
measuring performance over mechanisms which perform compression.

     <p>While previously required for a TCP_SENDFILE test, later versions of
netperf removed that restriction, creating a temporary file as
needed.  While the author cannot recall exactly when that took place,
it is known to be unnecessary in version 2.5.0 and later.

     <p><a name="index-g_t_002dh_002c-Global-25"></a><br><dt><code>-h</code><dd>This option causes netperf to display its &ldquo;global&rdquo; usage string and
exit to the exclusion of all else.

     <p><a name="index-g_t_002dH_002c-Global-26"></a><br><dt><code>-H &lt;optionspec&gt;</code><dd>This option will set the name of the remote system and or the address
family used for the control connection.  For example:
     <pre class="example">          -H linger,4
</pre>
     <p>will set the name of the remote system to &ldquo;linger&rdquo; and tells netperf to
use IPv4 addressing only.
     <pre class="example">          -H ,6
</pre>
     <p>will leave the name of the remote system at its default, and request
that only IPv6 addresses be used for the control connection.
     <pre class="example">          -H lag
</pre>
     <p>will set the name of the remote system to &ldquo;lag&rdquo; and leave the
address family to AF_UNSPEC which means selection of IPv4 vs IPv6 is
left to the system's address resolution.

     <p>A value of &ldquo;inet&rdquo; can be used in place of &ldquo;4&rdquo; to request IPv4 only
addressing.  Similarly, a value of &ldquo;inet6&rdquo; can be used in place of
&ldquo;6&rdquo; to request IPv6 only addressing.  A value of &ldquo;0&rdquo; can be used
to request either IPv4 or IPv6 addressing as name resolution dictates.

     <p>By default, the options set with the global <samp><span class="option">-H</span></samp> option are
inherited by the test for its data connection, unless a test-specific
<samp><span class="option">-H</span></samp> option is specified.

     <p>If a <samp><span class="option">-H</span></samp> option follows either the <samp><span class="option">-4</span></samp> or <samp><span class="option">-6</span></samp>
options, the family setting specified with the -H option will override
the <samp><span class="option">-4</span></samp> or <samp><span class="option">-6</span></samp> options for the remote address
family. If no address family is specified, settings from a previous
<samp><span class="option">-4</span></samp> or <samp><span class="option">-6</span></samp> option will remain.  In a nutshell, the
last explicit global command-line option wins.

     <p>[Default:  &ldquo;localhost&rdquo; for the remote name/IP address and &ldquo;0&rdquo; (eg
AF_UNSPEC) for the remote address family.]

     <p><a name="index-g_t_002dI_002c-Global-27"></a><br><dt><code>-I &lt;optionspec&gt;</code><dd>This option enables the calculation of confidence intervals and sets
the confidence and width parameters with the first half of the
optionspec being either 99 or 95 for 99% or 95% confidence
respectively.  The second value of the optionspec specifies the width
of the desired confidence interval.  For example
     <pre class="example">          -I 99,5
</pre>
     <p>asks netperf to be 99% confident that the measured mean values for
throughput and CPU utilization are within +/- 2.5% of the &ldquo;real&rdquo;
mean values.  If the <samp><span class="option">-i</span></samp> option is specified and the
<samp><span class="option">-I</span></samp> option is omitted, the confidence defaults to 99% and the
width to 5% (giving +/- 2.5%)

     <p>If classic netperf test calculates that the desired confidence
intervals have not been met, it emits a noticeable warning that cannot
be suppressed with the <samp><span class="option">-P</span></samp> or <samp><span class="option">-v</span></samp> options:

     <pre class="example">          netperf -H tardy.cup -i 3 -I 99,5
          TCP STREAM TEST from 0.0.0.0 (0.0.0.0) port 0 AF_INET to tardy.cup.hp.com (15.244.44.58) port 0 AF_INET : +/-2.5%  99% conf.
          !!! WARNING
          !!! Desired confidence was not achieved within the specified iterations.
          !!! This implies that there was variability in the test environment that
          !!! must be investigated before going further.
          !!! Confidence intervals: Throughput      :  6.8%
          !!!                       Local CPU util  :  0.0%
          !!!                       Remote CPU util :  0.0%
          
          Recv   Send    Send
          Socket Socket  Message  Elapsed
          Size   Size    Size     Time     Throughput
          bytes  bytes   bytes    secs.    10^6bits/sec
          
           32768  16384  16384    10.01      40.23
</pre>
     <p>In the example above we see that netperf did not meet the desired
confidence intervals.  Instead of being 99% confident it was within
+/- 2.5% of the real mean value of throughput it is only confident it
was within +/-3.4%.  In this example, increasing the <samp><span class="option">-i</span></samp>
option (described below) and/or increasing the iteration length with
the <samp><span class="option">-l</span></samp> option might resolve the situation.

     <p>In an explicit &ldquo;omni&rdquo; test, failure to meet the confidence intervals
will not result in netperf emitting a warning.  To verify the hitting,
or not, of the confidence intervals one will need to include them as
part of an <a href="#Omni-Output-Selection">output selection</a> in the
test-specific <samp><span class="option">-o</span></samp>, <samp><span class="option">-O</span></samp> or <samp><span class="option">k</span></samp> output selection
options.  The warning about not hitting the confidence intervals will
remain in a &ldquo;migrated&rdquo; classic netperf test.

     <p><a name="index-g_t_002di_002c-Global-28"></a><br><dt><code>-i &lt;sizespec&gt;</code><dd>This option enables the calculation of confidence intervals and sets
the minimum and maximum number of iterations to run in attempting to
achieve the desired confidence interval.  The first value sets the
maximum number of iterations to run, the second, the minimum.  The
maximum number of iterations is silently capped at 30 and the minimum
is silently floored at 3.  Netperf repeats the measurement the minimum
number of iterations and continues until it reaches either the
desired confidence interval, or the maximum number of iterations,
whichever comes first.  A classic or migrated netperf test will not
display the actual number of iterations run. An <a href="#The-Omni-Tests">omni test</a> will emit the number of iterations run if the
<code>CONFIDENCE_ITERATION</code> output selector is included in the
<a href="#Omni-Output-Selection">output selection</a>.

     <p>If the <samp><span class="option">-I</span></samp> option is specified and the <samp><span class="option">-i</span></samp> option
omitted the maximum number of iterations is set to 10 and the minimum
to three.

     <p>Output of a warning upon not hitting the desired confidence intervals
follows the description provided for the <samp><span class="option">-I</span></samp> option.

     <p>The total test time will be somewhere between the minimum and maximum
number of iterations multiplied by the test length supplied by the
<samp><span class="option">-l</span></samp> option.

     <p><a name="index-g_t_002dj_002c-Global-29"></a><br><dt><code>-j</code><dd>This option instructs netperf to keep additional timing statistics
when explicitly running an <a href="#The-Omni-Tests">omni test</a>.  These can
be output when the test-specific <samp><span class="option">-o</span></samp>, <samp><span class="option">-O</span></samp> or
<samp><span class="option">-k</span></samp> <a href="#Omni-Output-Selectors">output selectors</a> include one
or more of:

          <ul>
<li>MIN_LATENCY
<li>MAX_LATENCY
<li>P50_LATENCY
<li>P90_LATENCY
<li>P99_LATENCY
<li>MEAN_LATENCY
<li>STDDEV_LATENCY
</ul>

     <p>These statistics will be based on an expanded (100 buckets per row
rather than 10) histogram of times rather than a terribly long list of
individual times.  As such, there will be some slight error thanks to
the bucketing. However, the reduction in storage and processing
overheads is well worth it.  When running a request/response test, one
might get some idea of the error by comparing the <a href="#Omni-Output-Selectors"><code>MEAN_LATENCY</code></a> calculated from the histogram with the
<code>RT_LATENCY</code> calculated from the number of request/response
transactions and the test run time.

     <p>In the case of a request/response test the latencies will be
transaction latencies.  In the case of a receive-only test they will
be time spent in the receive call.  In the case of a send-only test
they will be time spent in the send call. The units will be
microseconds. Added in netperf 2.5.0.

     <p><a name="index-g_t_002dl_002c-Global-30"></a><br><dt><code>-l testlen</code><dd>This option controls the length of any <b>one</b> iteration of the requested
test.  A positive value for <var>testlen</var> will run each iteration of
the test for at least <var>testlen</var> seconds.  A negative value for
<var>testlen</var> will run each iteration for the absolute value of
<var>testlen</var> transactions for a _RR test or bytes for a _STREAM test. 
Certain tests, notably those using UDP can only be timed, they cannot
be limited by transaction or byte count.  This limitation may be
relaxed in an <a href="#The-Omni-Tests">omni</a> test.

     <p>In some situations, individual iterations of a test may run for longer
for the number of seconds specified by the <samp><span class="option">-l</span></samp> option.  In
particular, this may occur for those tests where the socket buffer
size(s) are significantly longer than the bandwidthXdelay product of
the link(s) over which the data connection passes, or those tests
where there may be non-trivial numbers of retransmissions.

     <p>If confidence intervals are enabled via either <samp><span class="option">-I</span></samp> or
<samp><span class="option">-i</span></samp> the total length of the netperf test will be somewhere
between the minimum and maximum iteration count multiplied by
<var>testlen</var>.

     <p><a name="index-g_t_002dL_002c-Global-31"></a><br><dt><code>-L &lt;optionspec&gt;</code><dd>This option is identical to the <samp><span class="option">-H</span></samp> option with the difference
being it sets the _local_ hostname/IP and/or address family
information.  This option is generally unnecessary, but can be useful
when you wish to make sure that the netperf control and data
connections go via different paths.  It can also come-in handy if one
is trying to run netperf through those evil, end-to-end breaking
things known as firewalls.

     <p>[Default: 0.0.0.0 (eg INADDR_ANY) for IPv4 and ::0 for IPv6 for the
local name.  AF_UNSPEC for the local address family.]

     <p><a name="index-g_t_002dn_002c-Global-32"></a><br><dt><code>-n numcpus</code><dd>This option tells netperf how many CPUs it should ass-u-me are active
on the system running netperf.  In particular, this is used for the
<a href="#CPU-Utilization">CPU utilization</a> and service demand calculations. 
On certain systems, netperf is able to determine the number of CPU's
automagically. This option will override any number netperf might be
able to determine on its own.

     <p>Note that this option does _not_ set the number of CPUs on the system
running netserver.  When netperf/netserver cannot automagically
determine the number of CPUs that can only be set for netserver via a
netserver <samp><span class="option">-n</span></samp> command-line option.

     <p>As it is almost universally possible for netperf/netserver to
determine the number of CPUs on the system automagically, 99 times out
of 10 this option should not be necessary and may be removed in a
future release of netperf.

     <p><a name="index-g_t_002dN_002c-Global-33"></a><br><dt><code>-N</code><dd>This option tells netperf to forgo establishing a control
connection. This makes it is possible to run some limited netperf
tests without a corresponding netserver on the remote system.

     <p>With this option set, the test to be run is to get all the addressing
information it needs to establish its data connection from the command
line or internal defaults.  If not otherwise specified by
test-specific command line options, the data connection for a
&ldquo;STREAM&rdquo; or &ldquo;SENDFILE&rdquo; test will be to the &ldquo;discard&rdquo; port, an
&ldquo;RR&rdquo; test will be to the &ldquo;echo&rdquo; port, and a &ldquo;MEARTS&rdquo; test will
be to the chargen port.

     <p>The response size of an &ldquo;RR&rdquo; test will be silently set to be the
same as the request size.  Otherwise the test would hang if the
response size was larger than the request size, or would report an
incorrect, inflated transaction rate if the response size was less
than the request size.

     <p>Since there is no control connection when this option is specified, it
is not possible to set &ldquo;remote&rdquo; properties such as socket buffer
size and the like via the netperf command line. Nor is it possible to
retrieve such interesting remote information as CPU utilization. 
These items will be displayed as values which should make it
immediately obvious that was the case.

     <p>The only way to change remote characteristics such as socket buffer
size or to obtain information such as CPU utilization is to employ
platform-specific methods on the remote system.  Frankly, if one has
access to the remote system to employ those methods one aught to be
able to run a netserver there.  However, that ability may not be
present in certain &ldquo;support&rdquo; situations, hence the addition of this
option.

     <p>Added in netperf 2.4.3.

     <p><a name="index-g_t_002do_002c-Global-34"></a><br><dt><code>-o &lt;sizespec&gt;</code><dd>The value(s) passed-in with this option will be used as an offset
added to the alignment specified with the <samp><span class="option">-a</span></samp> option.  For
example:
     <pre class="example">          -o 3 -a 4096
</pre>
     <p>will cause the buffers passed to the local (netperf) send and receive
calls to begin three bytes past an address aligned to 4096
bytes. [Default: 0 bytes]

     <p><a name="index-g_t_002dO_002c-Global-35"></a><br><dt><code>-O &lt;sizespec&gt;</code><dd>This option behaves just as the <samp><span class="option">-o</span></samp> option but on the remote
(netserver) system and in conjunction with the <samp><span class="option">-A</span></samp>
option. [Default: 0 bytes]

     <p><a name="index-g_t_002dp_002c-Global-36"></a><br><dt><code>-p &lt;optionspec&gt;</code><dd>The first value of the optionspec passed-in with this option tells
netperf the port number at which it should expect the remote netserver
to be listening for control connections.  The second value of the
optionspec will request netperf to bind to that local port number
before establishing the control connection.  For example
     <pre class="example">          -p 12345
</pre>
     <p>tells netperf that the remote netserver is listening on port 12345 and
leaves selection of the local port number for the control connection
up to the local TCP/IP stack whereas
     <pre class="example">          -p ,32109
</pre>
     <p>leaves the remote netserver port at the default value of 12865 and
causes netperf to bind to the local port number 32109 before
connecting to the remote netserver.

     <p>In general, setting the local port number is only necessary when one
is looking to run netperf through those evil, end-to-end breaking
things known as firewalls.

     <p><a name="index-g_t_002dP_002c-Global-37"></a><br><dt><code>-P 0|1</code><dd>A value of &ldquo;1&rdquo; for the <samp><span class="option">-P</span></samp> option will enable display of
the test banner.  A value of &ldquo;0&rdquo; will disable display of the test
banner. One might want to disable display of the test banner when
running the same basic test type (eg TCP_STREAM) multiple times in
succession where the test banners would then simply be redundant and
unnecessarily clutter the output. [Default: 1 - display test banners]

     <p><a name="index-g_t_002ds_002c-Global-38"></a><br><dt><code>-s &lt;seconds&gt;</code><dd>This option will cause netperf to sleep &lsquo;<samp><span class="samp">&lt;seconds&gt;</span></samp>&rsquo; before
actually transferring data over the data connection.  This may be
useful in situations where one wishes to start a great many netperf
instances and do not want the earlier ones affecting the ability of
the later ones to get established.

     <p>Added somewhere between versions 2.4.3 and 2.5.0.

     <p><a name="index-g_t_002dS_002c-Global-39"></a><br><dt><code>-S</code><dd>This option will cause an attempt to be made to set SO_KEEPALIVE on
the data socket of a test using the BSD sockets interface.  The
attempt will be made on the netperf side of all tests, and will be
made on the netserver side of an <a href="#The-Omni-Tests">omni</a> or
<a href="#Migrated-Tests">migrated</a> test.  No indication of failure is given
unless debug output is enabled with the global <samp><span class="option">-d</span></samp> option.

     <p>Added in version 2.5.0.

     <p><a name="index-g_t_002dt_002c-Global-40"></a><br><dt><code>-t testname</code><dd>This option is used to tell netperf which test you wish to run.  As of
this writing, valid values for <var>testname</var> include:
          <ul>
<li><a href="#TCP_005fSTREAM">TCP_STREAM</a>, <a href="#TCP_005fMAERTS">TCP_MAERTS</a>, <a href="#TCP_005fSENDFILE">TCP_SENDFILE</a>, <a href="#TCP_005fRR">TCP_RR</a>, <a href="#TCP_005fCRR">TCP_CRR</a>, <a href="#TCP_005fCC">TCP_CC</a>
<li><a href="#UDP_005fSTREAM">UDP_STREAM</a>, <a href="#UDP_005fRR">UDP_RR</a>
<li><a href="#XTI_005fTCP_005fSTREAM">XTI_TCP_STREAM</a>,  <a href="#XTI_005fTCP_005fRR">XTI_TCP_RR</a>, <a href="#XTI_005fTCP_005fCRR">XTI_TCP_CRR</a>, <a href="#XTI_005fTCP_005fCC">XTI_TCP_CC</a>
<li><a href="#XTI_005fUDP_005fSTREAM">XTI_UDP_STREAM</a>, <a href="#XTI_005fUDP_005fRR">XTI_UDP_RR</a>
<li><a href="#SCTP_005fSTREAM">SCTP_STREAM</a>, <a href="#SCTP_005fRR">SCTP_RR</a>
<li><a href="#DLCO_005fSTREAM">DLCO_STREAM</a>, <a href="#DLCO_005fRR">DLCO_RR</a>,  <a href="#DLCL_005fSTREAM">DLCL_STREAM</a>, <a href="#DLCL_005fRR">DLCL_RR</a>
<li><a href="#Other-Netperf-Tests">LOC_CPU</a>, <a href="#Other-Netperf-Tests">REM_CPU</a>
<li><a href="#The-Omni-Tests">OMNI</a>
</ul>
     Not all tests are always compiled into netperf.  In particular, the
&ldquo;XTI,&rdquo; &ldquo;SCTP,&rdquo; &ldquo;UNIXDOMAIN,&rdquo; and &ldquo;DL*&rdquo; tests are only included in
netperf when configured with
<samp><span class="option">--enable-[xti|sctp|unixdomain|dlpi]=yes</span></samp>.

     <p>Netperf only runs one type of test no matter how many <samp><span class="option">-t</span></samp>
options may be present on the command-line.  The last <samp><span class="option">-t</span></samp>
global command-line option will determine the test to be
run. [Default: TCP_STREAM]

     <p><a name="index-g_t_002dT_002c-Global-41"></a><br><dt><code>-T &lt;optionspec&gt;</code><dd>This option controls the CPU, and probably by extension memory,
affinity of netperf and/or netserver.
     <pre class="example">          netperf -T 1
</pre>
     <p>will bind both netperf and netserver to &ldquo;CPU 1&rdquo; on their respective
systems.
     <pre class="example">          netperf -T 1,
</pre>
     <p>will bind just netperf to &ldquo;CPU 1&rdquo; and will leave netserver unbound.
     <pre class="example">          netperf -T ,2
</pre>
     <p>will leave netperf unbound and will bind netserver to &ldquo;CPU 2.&rdquo;
     <pre class="example">          netperf -T 1,2
</pre>
     <p>will bind netperf to &ldquo;CPU 1&rdquo; and netserver to &ldquo;CPU 2.&rdquo;

     <p>This can be particularly useful when investigating performance issues
involving where processes run relative to where NIC interrupts are
processed or where NICs allocate their DMA buffers.

     <p><a name="index-g_t_002dv_002c-Global-42"></a><br><dt><code>-v verbosity</code><dd>This option controls how verbose netperf will be in its output, and is
often used in conjunction with the <samp><span class="option">-P</span></samp> option. If the
verbosity is set to a value of &ldquo;0&rdquo; then only the test's SFM (Single
Figure of Merit) is displayed.  If local <a href="#CPU-Utilization">CPU utilization</a> is requested via the <samp><span class="option">-c</span></samp> option then the SFM is
the local service demand.  Othersise, if remote CPU utilization is
requested via the <samp><span class="option">-C</span></samp> option then the SFM is the remote
service demand.  If neither local nor remote CPU utilization are
requested the SFM will be the measured throughput or transaction rate
as implied by the test specified with the <samp><span class="option">-t</span></samp> option.

     <p>If the verbosity level is set to &ldquo;1&rdquo; then the &ldquo;normal&rdquo; netperf
result output for each test is displayed.

     <p>If the verbosity level is set to &ldquo;2&rdquo; then &ldquo;extra&rdquo; information will
be displayed.  This may include, but is not limited to the number of
send or recv calls made and the average number of bytes per send or
recv call, or a histogram of the time spent in each send() call or for
each transaction if netperf was configured with
<samp><span class="option">--enable-histogram=yes</span></samp>. [Default: 1 - normal verbosity]

     <p>In an <a href="#The-Omni-Tests">omni</a> test the verbosity setting is largely
ignored, save for when asking for the time histogram to be displayed. 
In version 2.5.0 and later there is no <a href="#Omni-Output-Selectors">output selector</a> for the histogram and so it remains displayed only when the
verbosity level is set to 2.

     <p><a name="index-g_t_002dV_002c-Global-43"></a><br><dt><code>-V</code><dd>This option displays the netperf version and then exits.

     <p>Added in netperf 2.4.4.

     <p><a name="index-g_t_002dw_002c-Global-44"></a><br><dt><code>-w time</code><dd>If netperf was configured with <samp><span class="option">--enable-intervals=yes</span></samp> then
this value will set the inter-burst time to time milliseconds, and the
<samp><span class="option">-b</span></samp> option will set the number of sends per burst.  The actual
inter-burst time may vary depending on the system's timer resolution.

     <p><a name="index-g_t_002dW_002c-Global-45"></a><br><dt><code>-W &lt;sizespec&gt;</code><dd>This option controls the number of buffers in the send (first or only
value) and or receive (second or only value) buffer rings.  Unlike
some benchmarks, netperf does not continuously send or receive from a
single buffer.  Instead it rotates through a ring of
buffers. [Default: One more than the size of the send or receive
socket buffer sizes (<samp><span class="option">-s</span></samp> and/or <samp><span class="option">-S</span></samp> options) divided
by the send <samp><span class="option">-m</span></samp> or receive <samp><span class="option">-M</span></samp> buffer size
respectively]

     <p><a name="index-g_t_002d4_002c-Global-46"></a><br><dt><code>-4</code><dd>Specifying this option will set both the local and remote address
families to AF_INET - that is use only IPv4 addresses on the control
connection.  This can be overridden by a subsequent <samp><span class="option">-6</span></samp>,
<samp><span class="option">-H</span></samp> or <samp><span class="option">-L</span></samp> option.  Basically, the last option
explicitly specifying an address family wins.  Unless overridden by a
test-specific option, this will be inherited for the data connection
as well.

     <p><a name="index-g_t_002d6_002c-Global-47"></a><br><dt><code>-6</code><dd>Specifying this option will set both local and and remote address
families to AF_INET6 - that is use only IPv6 addresses on the control
connection.  This can be overridden by a subsequent <samp><span class="option">-4</span></samp>,
<samp><span class="option">-H</span></samp> or <samp><span class="option">-L</span></samp> option.  Basically, the last address family
explicitly specified wins.  Unless overridden by a test-specific
option, this will be inherited for the data connection as well.

</dl>

<div class="node">
<a name="Using-Netperf-to-Measure-Bulk-Data-Transfer"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Using-Netperf-to-Measure-Request_002fResponse">Using Netperf to Measure Request/Response</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Global-Command_002dline-Options">Global Command-line Options</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">5 Using Netperf to Measure Bulk Data Transfer</h2>

<p>The most commonly measured aspect of networked system performance is
that of bulk or unidirectional transfer performance.  Everyone wants
to know how many bits or bytes per second they can push across the
network. The classic netperf convention for a bulk data transfer test
name is to tack a &ldquo;_STREAM&rdquo; suffix to a test name.

<ul class="menu">
<li><a accesskey="1" href="#Issues-in-Bulk-Transfer">Issues in Bulk Transfer</a>
<li><a accesskey="2" href="#Options-common-to-TCP-UDP-and-SCTP-tests">Options common to TCP UDP and SCTP tests</a>
</ul>

<div class="node">
<a name="Issues-in-Bulk-Transfer"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Options-common-to-TCP-UDP-and-SCTP-tests">Options common to TCP UDP and SCTP tests</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Using-Netperf-to-Measure-Bulk-Data-Transfer">Using Netperf to Measure Bulk Data Transfer</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Using-Netperf-to-Measure-Bulk-Data-Transfer">Using Netperf to Measure Bulk Data Transfer</a>

</div>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">5.1 Issues in Bulk Transfer</h3>

<p>There are any number of things which can affect the performance of a
bulk transfer test.

   <p>Certainly, absent compression, bulk-transfer tests can be limited by
the speed of the slowest link in the path from the source to the
destination.  If testing over a gigabit link, you will not see more
than a gigabit :) Such situations can be described as being
<dfn>network-limited</dfn> or <dfn>NIC-limited</dfn>.

   <p>CPU utilization can also affect the results of a bulk-transfer test. 
If the networking stack requires a certain number of instructions or
CPU cycles per KB of data transferred, and the CPU is limited in the
number of instructions or cycles it can provide, then the transfer can
be described as being <dfn>CPU-bound</dfn>.

   <p>A bulk-transfer test can be CPU bound even when netperf reports less
than 100% CPU utilization.  This can happen on an MP system where one
or more of the CPUs saturate at 100% but other CPU's remain idle. 
Typically, a single flow of data, such as that from a single instance
of a netperf _STREAM test cannot make use of much more than the power
of one CPU. Exceptions to this generally occur when netperf and/or
netserver run on CPU(s) other than the CPU(s) taking interrupts from
the NIC(s). In that case, one might see as much as two CPUs' worth of
processing being used to service the flow of data.

   <p>Distance and the speed-of-light can affect performance for a
bulk-transfer; often this can be mitigated by using larger windows. 
One common limit to the performance of a transport using window-based
flow-control is:
<pre class="example">     Throughput &lt;= WindowSize/RoundTripTime
</pre>
   <p>As the sender can only have a window's-worth of data outstanding on
the network at any one time, and the soonest the sender can receive a
window update from the receiver is one RoundTripTime (RTT).  TCP and
SCTP are examples of such protocols.

   <p>Packet losses and their effects can be particularly bad for
performance.  This is especially true if the packet losses result in
retransmission timeouts for the protocol(s) involved.  By the time a
retransmission timeout has happened, the flow or connection has sat
idle for a considerable length of time.

   <p>On many platforms, some variant on the <samp><span class="command">netstat</span></samp> command can
be used to retrieve statistics about packet loss and
retransmission. For example:
<pre class="example">     netstat -p tcp
</pre>
   <p>will retrieve TCP statistics on the HP-UX Operating System.  On other
platforms, it may not be possible to retrieve statistics for a
specific protocol and something like:
<pre class="example">     netstat -s
</pre>
   <p>would be used instead.

   <p>Many times, such network statistics are keep since the time the stack
started, and we are only really interested in statistics from when
netperf was running.  In such situations something along the lines of:
<pre class="example">     netstat -p tcp &gt; before
     netperf -t TCP_mumble...
     netstat -p tcp &gt; after
</pre>
   <p>is indicated.  The
<a href="ftp://ftp.cup.hp.com/dist/networking/tools/">beforeafter</a> utility
can be used to subtract the statistics in <samp><span class="file">before</span></samp> from the
statistics in <samp><span class="file">after</span></samp>:
<pre class="example">     beforeafter before after &gt; delta
</pre>
   <p>and then one can look at the statistics in <samp><span class="file">delta</span></samp>.  Beforeafter
is distributed in source form so one can compile it on the platform(s)
of interest.

   <p>If running a version 2.5.0 or later &ldquo;omni&rdquo; test under Linux one can
include either or both of:
     <ul>
<li>LOCAL_TRANSPORT_RETRANS
<li>REMOTE_TRANSPORT_RETRANS
</ul>

   <p>in the values provided via a test-specific <samp><span class="option">-o</span></samp>, <samp><span class="option">-O</span></samp>,
or <samp><span class="option">-k</span></samp> output selction option and netperf will report the
retransmissions experienced on the data connection, as reported via a
<code>getsockopt(TCP_INFO)</code> call.  If confidence intervals have been
requested via the global <samp><span class="option">-I</span></samp> or <samp><span class="option">-i</span></samp> options, the
reported value(s) will be for the last iteration.  If the test is over
a protocol other than TCP, or on a platform other than Linux, the
results are undefined.

   <p>While it was written with HP-UX's netstat in mind, the
<a href="ftp://ftp.cup.hp.com/dist/networking/briefs/annotated_netstat.txt">annotated netstat</a> writeup may be helpful with other platforms as well.

<div class="node">
<a name="Options-common-to-TCP-UDP-and-SCTP-tests"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Issues-in-Bulk-Transfer">Issues in Bulk Transfer</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Using-Netperf-to-Measure-Bulk-Data-Transfer">Using Netperf to Measure Bulk Data Transfer</a>

</div>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">5.2 Options common to TCP UDP and SCTP tests</h3>

<p>Many &ldquo;test-specific&rdquo; options are actually common across the
different tests.  For those tests involving TCP, UDP and SCTP, whether
using the BSD Sockets or the XTI interface those common options
include:

     
<a name="index-g_t_002dh_002c-Test_002dspecific-48"></a>
<dl><dt><code>-h</code><dd>Display the test-suite-specific usage string and exit.  For a TCP_ or
UDP_ test this will be the usage string from the source file
nettest_bsd.c.  For an XTI_ test, this will be the usage string from
the source file nettest_xti.c.  For an SCTP test, this will be the
usage string from the source file nettest_sctp.c.

     <br><dt><code>-H &lt;optionspec&gt;</code><dd>Normally, the remote hostname|IP and address family information is
inherited from the settings for the control connection (eg global
command-line <samp><span class="option">-H</span></samp>, <samp><span class="option">-4</span></samp> and/or <samp><span class="option">-6</span></samp> options). 
The test-specific <samp><span class="option">-H</span></samp> will override those settings for the
data (aka test) connection only.  Settings for the control connection
are left unchanged.

     <p><a name="index-g_t_002dL_002c-Test_002dspecific-49"></a><br><dt><code>-L &lt;optionspec&gt;</code><dd>The test-specific <samp><span class="option">-L</span></samp> option is identical to the test-specific
<samp><span class="option">-H</span></samp> option except it affects the local hostname|IP and address
family information.  As with its global command-line counterpart, this
is generally only useful when measuring though those evil, end-to-end
breaking things called firewalls.

     <p><a name="index-g_t_002dm_002c-Test_002dspecific-50"></a><br><dt><code>-m bytes</code><dd>Set the size of the buffer passed-in to the &ldquo;send&rdquo; calls of a
_STREAM test.  Note that this may have only an indirect effect on the
size of the packets sent over the network, and certain Layer 4
protocols do _not_ preserve or enforce message boundaries, so setting
<samp><span class="option">-m</span></samp> for the send size does not necessarily mean the receiver
will receive that many bytes at any one time. By default the units are
bytes, but suffix of &ldquo;G,&rdquo; &ldquo;M,&rdquo; or &ldquo;K&rdquo; will specify the units to
be 2^30 (GB), 2^20 (MB) or 2^10 (KB) respectively. A suffix of &ldquo;g,&rdquo;
&ldquo;m&rdquo; or &ldquo;k&rdquo; will specify units of 10^9, 10^6 or 10^3 bytes
respectively. For example:
     <pre class="example">          <code>-m 32K</code>
</pre>
     <p>will set the size to 32KB or 32768 bytes. [Default: the local send
socket buffer size for the connection - either the system's default or
the value set via the <samp><span class="option">-s</span></samp> option.]

     <p><a name="index-g_t_002dM_002c-Test_002dspecific-51"></a><br><dt><code>-M bytes</code><dd>Set the size of the buffer passed-in to the &ldquo;recv&rdquo; calls of a
_STREAM test.  This will be an upper bound on the number of bytes
received per receive call. By default the units are bytes, but suffix
of &ldquo;G,&rdquo; &ldquo;M,&rdquo; or &ldquo;K&rdquo; will specify the units to be 2^30 (GB), 2^20
(MB) or 2^10 (KB) respectively.  A suffix of &ldquo;g,&rdquo; &ldquo;m&rdquo; or &ldquo;k&rdquo;
will specify units of 10^9, 10^6 or 10^3 bytes respectively. For
example:
     <pre class="example">          <code>-M 32K</code>
</pre>
     <p>will set the size to 32KB or 32768 bytes. [Default: the remote receive
socket buffer size for the data connection - either the system's
default or the value set via the <samp><span class="option">-S</span></samp> option.]

     <p><a name="index-g_t_002dP_002c-Test_002dspecific-52"></a><br><dt><code>-P &lt;optionspec&gt;</code><dd>Set the local and/or remote port numbers for the data connection.

     <p><a name="index-g_t_002ds_002c-Test_002dspecific-53"></a><br><dt><code>-s &lt;sizespec&gt;</code><dd>This option sets the local (netperf) send and receive socket buffer
sizes for the data connection to the value(s) specified.  Often, this
will affect the advertised and/or effective TCP or other window, but
on some platforms it may not. By default the units are bytes, but
suffix of &ldquo;G,&rdquo; &ldquo;M,&rdquo; or &ldquo;K&rdquo; will specify the units to be 2^30
(GB), 2^20 (MB) or 2^10 (KB) respectively.  A suffix of &ldquo;g,&rdquo; &ldquo;m&rdquo;
or &ldquo;k&rdquo; will specify units of 10^9, 10^6 or 10^3 bytes
respectively. For example:
     <pre class="example">          <code>-s 128K</code>
</pre>
     <p>Will request the local send and receive socket buffer sizes to be
128KB or 131072 bytes.

     <p>While the historic expectation is that setting the socket buffer size
has a direct effect on say the TCP window, today that may not hold
true for all stacks. Further, while the historic expectation is that
the value specified in a <code>setsockopt()</code> call will be the value returned
via a <code>getsockopt()</code> call, at least one stack is known to deliberately
ignore history.  When running under Windows a value of 0 may be used
which will be an indication to the stack the user wants to enable a
form of copy avoidance. [Default: -1 - use the system's default socket
buffer sizes]

     <p><a name="index-g_t_002dS-Test_002dspecific-54"></a><br><dt><code>-S &lt;sizespec&gt;</code><dd>This option sets the remote (netserver) send and/or receive socket
buffer sizes for the data connection to the value(s) specified. 
Often, this will affect the advertised and/or effective TCP or other
window, but on some platforms it may not. By default the units are
bytes, but suffix of &ldquo;G,&rdquo; &ldquo;M,&rdquo; or &ldquo;K&rdquo; will specify the units to
be 2^30 (GB), 2^20 (MB) or 2^10 (KB) respectively.  A suffix of &ldquo;g,&rdquo;
&ldquo;m&rdquo; or &ldquo;k&rdquo; will specify units of 10^9, 10^6 or 10^3 bytes
respectively.  For example:
     <pre class="example">          <code>-S 128K</code>
</pre>
     <p>Will request the remote send and receive socket buffer sizes to be
128KB or 131072 bytes.

     <p>While the historic expectation is that setting the socket buffer size
has a direct effect on say the TCP window, today that may not hold
true for all stacks.  Further, while the historic expectation is that
the value specified in a <code>setsockopt()</code> call will be the value returned
via a <code>getsockopt()</code> call, at least one stack is known to deliberately
ignore history.  When running under Windows a value of 0 may be used
which will be an indication to the stack the user wants to enable a
form of copy avoidance. [Default: -1 - use the system's default socket
buffer sizes]

     <p><a name="index-g_t_002d4_002c-Test_002dspecific-55"></a><br><dt><code>-4</code><dd>Set the local and remote address family for the data connection to
AF_INET - ie use IPv4 addressing only.  Just as with their global
command-line counterparts the last of the <samp><span class="option">-4</span></samp>, <samp><span class="option">-6</span></samp>,
<samp><span class="option">-H</span></samp> or <samp><span class="option">-L</span></samp> option wins for their respective address
families.

     <p><a name="index-g_t_002d6_002c-Test_002dspecific-56"></a><br><dt><code>-6</code><dd>This option is identical to its <samp><span class="option">-4</span></samp> cousin, but requests IPv6
addresses for the local and remote ends of the data connection.

   </dl>

<ul class="menu">
<li><a accesskey="1" href="#TCP_005fSTREAM">TCP_STREAM</a>
<li><a accesskey="2" href="#TCP_005fMAERTS">TCP_MAERTS</a>
<li><a accesskey="3" href="#TCP_005fSENDFILE">TCP_SENDFILE</a>
<li><a accesskey="4" href="#UDP_005fSTREAM">UDP_STREAM</a>
<li><a accesskey="5" href="#XTI_005fTCP_005fSTREAM">XTI_TCP_STREAM</a>
<li><a accesskey="6" href="#XTI_005fUDP_005fSTREAM">XTI_UDP_STREAM</a>
<li><a accesskey="7" href="#SCTP_005fSTREAM">SCTP_STREAM</a>
<li><a accesskey="8" href="#DLCO_005fSTREAM">DLCO_STREAM</a>
<li><a accesskey="9" href="#DLCL_005fSTREAM">DLCL_STREAM</a>
<li><a href="#STREAM_005fSTREAM">STREAM_STREAM</a>
<li><a href="#DG_005fSTREAM">DG_STREAM</a>
</ul>

<div class="node">
<a name="TCP_STREAM"></a>
<a name="TCP_005fSTREAM"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#TCP_005fMAERTS">TCP_MAERTS</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Options-common-to-TCP-UDP-and-SCTP-tests">Options common to TCP UDP and SCTP tests</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Options-common-to-TCP-UDP-and-SCTP-tests">Options common to TCP UDP and SCTP tests</a>

</div>

<h4 class="subsection">5.2.1 TCP_STREAM</h4>

<p>The TCP_STREAM test is the default test in netperf.  It is quite
simple, transferring some quantity of data from the system running
netperf to the system running netserver.  While time spent
establishing the connection is not included in the throughput
calculation, time spent flushing the last of the data to the remote at
the end of the test is.  This is how netperf knows that all the data
it sent was received by the remote.  In addition to the <a href="#Options-common-to-TCP-UDP-and-SCTP-tests">options common to STREAM tests</a>, the
following test-specific options can be included to possibly alter the
behavior of the test:

     <dl>
<dt><code>-C</code><dd>This option will set TCP_CORK mode on the data connection on those
systems where TCP_CORK is defined (typically Linux).  A full
description of TCP_CORK is beyond the scope of this manual, but in a
nutshell it forces sub-MSS sends to be buffered so every segment sent
is Maximum Segment Size (MSS) unless the application performs an
explicit flush operation or the connection is closed.  At present
netperf does not perform any explicit flush operations.  Setting
TCP_CORK may improve the bitrate of tests where the &ldquo;send size&rdquo;
(<samp><span class="option">-m</span></samp> option) is smaller than the MSS.  It should also improve
(make smaller) the service demand.

     <p>The Linux tcp(7) manpage states that TCP_CORK cannot be used in
conjunction with TCP_NODELAY (set via the <samp><span class="option">-d</span></samp> option), however
netperf does not validate command-line options to enforce that.

     <br><dt><code>-D</code><dd>This option will set TCP_NODELAY on the data connection on those
systems where TCP_NODELAY is defined.  This disables something known
as the Nagle Algorithm, which is intended to make the segments TCP
sends as large as reasonably possible.  Setting TCP_NODELAY for a
TCP_STREAM test should either have no effect when the send size
(<samp><span class="option">-m</span></samp> option) is larger than the MSS or will decrease reported
bitrate and increase service demand when the send size is smaller than
the MSS.  This stems from TCP_NODELAY causing each sub-MSS send to be
its own TCP segment rather than being aggregated with other small
sends.  This means more trips up and down the protocol stack per KB of
data transferred, which means greater CPU utilization.

     <p>If setting TCP_NODELAY with <samp><span class="option">-D</span></samp> affects throughput and/or
service demand for tests where the send size (<samp><span class="option">-m</span></samp>) is larger
than the MSS it suggests the TCP/IP stack's implementation of the
Nagle Algorithm _may_ be broken, perhaps interpreting the Nagle
Algorithm on a segment by segment basis rather than the proper user
send by user send basis.  However, a better test of this can be
achieved with the <a href="#TCP_005fRR">TCP_RR</a> test.

   </dl>

   <p>Here is an example of a basic TCP_STREAM test, in this case from a
Debian Linux (2.6 kernel) system to an HP-UX 11iv2 (HP-UX 11.23)
system:

<pre class="example">     $ netperf -H lag
     TCP STREAM TEST from 0.0.0.0 (0.0.0.0) port 0 AF_INET to lag.hpl.hp.com (15.4.89.214) port 0 AF_INET
     Recv   Send    Send
     Socket Socket  Message  Elapsed
     Size   Size    Size     Time     Throughput
     bytes  bytes   bytes    secs.    10^6bits/sec
     
      32768  16384  16384    10.00      80.42
</pre>
   <p>We see that the default receive socket buffer size for the receiver
(lag - HP-UX 11.23) is 32768 bytes, and the default socket send buffer
size for the sender (Debian 2.6 kernel) is 16384 bytes, however Linux
does &ldquo;auto tuning&rdquo; of socket buffer and TCP window sizes, which
means the send socket buffer size may be different at the end of the
test than it was at the beginning.  This is addressed in the <a href="#The-Omni-Tests">omni tests</a> added in version 2.5.0 and <a href="#Omni-Output-Selection">output selection</a>.  Throughput is expressed as 10^6 (aka
Mega) bits per second, and the test ran for 10 seconds.  IPv4
addresses (AF_INET) were used.

<div class="node">
<a name="TCP_MAERTS"></a>
<a name="TCP_005fMAERTS"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#TCP_005fSENDFILE">TCP_SENDFILE</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#TCP_005fSTREAM">TCP_STREAM</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Options-common-to-TCP-UDP-and-SCTP-tests">Options common to TCP UDP and SCTP tests</a>

</div>

<!-- node-name,  next,  previous,  up -->
<h4 class="subsection">5.2.2 TCP_MAERTS</h4>

<p>A TCP_MAERTS (MAERTS is STREAM backwards) test is &ldquo;just like&rdquo; a
<a href="#TCP_005fSTREAM">TCP_STREAM</a> test except the data flows from the netserver to the
netperf. The global command-line <samp><span class="option">-F</span></samp> option is ignored for
this test type.  The test-specific command-line <samp><span class="option">-C</span></samp> option is
ignored for this test type.

   <p>Here is an example of a TCP_MAERTS test between the same two systems
as in the example for the <a href="#TCP_005fSTREAM">TCP_STREAM</a> test.  This time we request
larger socket buffers with <samp><span class="option">-s</span></samp> and <samp><span class="option">-S</span></samp> options:

<pre class="example">     $ netperf -H lag -t TCP_MAERTS -- -s 128K -S 128K
     TCP MAERTS TEST from 0.0.0.0 (0.0.0.0) port 0 AF_INET to lag.hpl.hp.com (15.4.89.214) port 0 AF_INET
     Recv   Send    Send
     Socket Socket  Message  Elapsed
     Size   Size    Size     Time     Throughput
     bytes  bytes   bytes    secs.    10^6bits/sec
     
     221184 131072 131072    10.03      81.14
</pre>
   <p>Where we see that Linux, unlike HP-UX, may not return the same value
in a <code>getsockopt()</code> as was requested in the prior <code>setsockopt()</code>.

   <p>This test is included more for benchmarking convenience than anything
else.

<div class="node">
<a name="TCP_SENDFILE"></a>
<a name="TCP_005fSENDFILE"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#UDP_005fSTREAM">UDP_STREAM</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#TCP_005fMAERTS">TCP_MAERTS</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Options-common-to-TCP-UDP-and-SCTP-tests">Options common to TCP UDP and SCTP tests</a>

</div>

<!-- node-name,  next,  previous,  up -->
<h4 class="subsection">5.2.3 TCP_SENDFILE</h4>

<p>The TCP_SENDFILE test is &ldquo;just like&rdquo; a <a href="#TCP_005fSTREAM">TCP_STREAM</a> test except
netperf the platform's <code>sendfile()</code> call instead of calling
<code>send()</code>.  Often this results in a <dfn>zero-copy</dfn> operation
where data is sent directly from the filesystem buffer cache.  This
_should_ result in lower CPU utilization and possibly higher
throughput.  If it does not, then you may want to contact your
vendor(s) because they have a problem on their hands.

   <p>Zero-copy mechanisms may also alter the characteristics (size and
number of buffers per) of packets passed to the NIC.  In many stacks,
when a copy is performed, the stack can &ldquo;reserve&rdquo; space at the
beginning of the destination buffer for things like TCP, IP and Link
headers.  This then has the packet contained in a single buffer which
can be easier to DMA to the NIC.  When no copy is performed, there is
no opportunity to reserve space for headers and so a packet will be
contained in two or more buffers.

   <p>As of some time before version 2.5.0, the <a href="#Global-Options">global <samp><span class="option">-F</span></samp> option</a> is no longer required for this test.  If it is not
specified, netperf will create a temporary file, which it will delete
at the end of the test.  If the <samp><span class="option">-F</span></samp> option is specified it
must reference a file of at least the size of the send ring
(See <a href="#Global-Options">the global <samp><span class="option">-W</span></samp> option</a>.) multiplied by
the send size (See <a href="#Options-common-to-TCP-UDP-and-SCTP-tests">the test-specific <samp><span class="option">-m</span></samp> option</a>.).  All other TCP-specific options
remain available and optional.

   <p>In this first example:
<pre class="example">     $ netperf -H lag -F ../src/netperf -t TCP_SENDFILE -- -s 128K -S 128K
     TCP SENDFILE TEST from 0.0.0.0 (0.0.0.0) port 0 AF_INET to lag.hpl.hp.com (15.4.89.214) port 0 AF_INET
     alloc_sendfile_buf_ring: specified file too small.
     file must be larger than send_width * send_size
</pre>
   <p>we see what happens when the file is too small.  Here:

<pre class="example">     $ netperf -H lag -F /boot/vmlinuz-2.6.8-1-686 -t TCP_SENDFILE -- -s 128K -S 128K
     TCP SENDFILE TEST from 0.0.0.0 (0.0.0.0) port 0 AF_INET to lag.hpl.hp.com (15.4.89.214) port 0 AF_INET
     Recv   Send    Send
     Socket Socket  Message  Elapsed
     Size   Size    Size     Time     Throughput
     bytes  bytes   bytes    secs.    10^6bits/sec
     
     131072 221184 221184    10.02      81.83
</pre>
   <p>we resolve that issue by selecting a larger file.

<div class="node">
<a name="UDP_STREAM"></a>
<a name="UDP_005fSTREAM"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#XTI_005fTCP_005fSTREAM">XTI_TCP_STREAM</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#TCP_005fSENDFILE">TCP_SENDFILE</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Options-common-to-TCP-UDP-and-SCTP-tests">Options common to TCP UDP and SCTP tests</a>

</div>

<h4 class="subsection">5.2.4 UDP_STREAM</h4>

<p>A UDP_STREAM test is similar to a <a href="#TCP_005fSTREAM">TCP_STREAM</a> test except UDP is
used as the transport rather than TCP.

   <p><a name="index-Limiting-Bandwidth-57"></a>A UDP_STREAM test has no end-to-end flow control - UDP provides none
and neither does netperf.  However, if you wish, you can configure
netperf with <code>--enable-intervals=yes</code> to enable the global
command-line <samp><span class="option">-b</span></samp> and <samp><span class="option">-w</span></samp> options to pace bursts of
traffic onto the network.

   <p>This has a number of implications.

   <p>The biggest of these implications is the data which is sent might not
be received by the remote.  For this reason, the output of a
UDP_STREAM test shows both the sending and receiving throughput.  On
some platforms, it may be possible for the sending throughput to be
reported as a value greater than the maximum rate of the link.  This
is common when the CPU(s) are faster than the network and there is no
<dfn>intra-stack</dfn> flow-control.

   <p>Here is an example of a UDP_STREAM test between two systems connected
by a 10 Gigabit Ethernet link:
<pre class="example">     $ netperf -t UDP_STREAM -H 192.168.2.125 -- -m 32768
     UDP UNIDIRECTIONAL SEND TEST from 0.0.0.0 (0.0.0.0) port 0 AF_INET to 192.168.2.125 (192.168.2.125) port 0 AF_INET
     Socket  Message  Elapsed      Messages
     Size    Size     Time         Okay Errors   Throughput
     bytes   bytes    secs            #      #   10^6bits/sec
     
     124928   32768   10.00      105672      0    2770.20
     135168           10.00      104844           2748.50
     
</pre>
   <p>The first line of numbers are statistics from the sending (netperf)
side. The second line of numbers are from the receiving (netserver)
side.  In this case, 105672 - 104844 or 828 messages did not make it
all the way to the remote netserver process.

   <p>If the value of the <samp><span class="option">-m</span></samp> option is larger than the local send
socket buffer size (<samp><span class="option">-s</span></samp> option) netperf will likely abort with
an error message about how the send call failed:

<pre class="example">     netperf -t UDP_STREAM -H 192.168.2.125
     UDP UNIDIRECTIONAL SEND TEST from 0.0.0.0 (0.0.0.0) port 0 AF_INET to 192.168.2.125 (192.168.2.125) port 0 AF_INET
     udp_send: data send error: Message too long
</pre>
   <p>If the value of the <samp><span class="option">-m</span></samp> option is larger than the remote
socket receive buffer, the reported receive throughput will likely be
zero as the remote UDP will discard the messages as being too large to
fit into the socket buffer.

<pre class="example">     $ netperf -t UDP_STREAM -H 192.168.2.125 -- -m 65000 -S 32768
     UDP UNIDIRECTIONAL SEND TEST from 0.0.0.0 (0.0.0.0) port 0 AF_INET to 192.168.2.125 (192.168.2.125) port 0 AF_INET
     Socket  Message  Elapsed      Messages
     Size    Size     Time         Okay Errors   Throughput
     bytes   bytes    secs            #      #   10^6bits/sec
     
     124928   65000   10.00       53595      0    2786.99
      65536           10.00           0              0.00
</pre>
   <p>The example above was between a pair of systems running a &ldquo;Linux&rdquo;
kernel. Notice that the remote Linux system returned a value larger
than that passed-in to the <samp><span class="option">-S</span></samp> option.  In fact, this value
was larger than the message size set with the <samp><span class="option">-m</span></samp> option. 
That the remote socket buffer size is reported as 65536 bytes would
suggest to any sane person that a message of 65000 bytes would fit,
but the socket isn't _really_ 65536 bytes, even though Linux is
telling us so.  Go figure.

<div class="node">
<a name="XTI_TCP_STREAM"></a>
<a name="XTI_005fTCP_005fSTREAM"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#XTI_005fUDP_005fSTREAM">XTI_UDP_STREAM</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#UDP_005fSTREAM">UDP_STREAM</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Options-common-to-TCP-UDP-and-SCTP-tests">Options common to TCP UDP and SCTP tests</a>

</div>

<h4 class="subsection">5.2.5 XTI_TCP_STREAM</h4>

<p>An XTI_TCP_STREAM test is simply a <a href="#TCP_005fSTREAM">TCP_STREAM</a> test using the XTI
rather than BSD Sockets interface.  The test-specific <samp><span class="option">-X
&lt;devspec&gt;</span></samp> option can be used to specify the name of the local and/or
remote XTI device files, which is required by the <code>t_open()</code> call
made by netperf XTI tests.

   <p>The XTI_TCP_STREAM test is only present if netperf was configured with
<code>--enable-xti=yes</code>.  The remote netserver must have also been
configured with <code>--enable-xti=yes</code>.

<div class="node">
<a name="XTI_UDP_STREAM"></a>
<a name="XTI_005fUDP_005fSTREAM"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#SCTP_005fSTREAM">SCTP_STREAM</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#XTI_005fTCP_005fSTREAM">XTI_TCP_STREAM</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Options-common-to-TCP-UDP-and-SCTP-tests">Options common to TCP UDP and SCTP tests</a>

</div>

<h4 class="subsection">5.2.6 XTI_UDP_STREAM</h4>

<p>An XTI_UDP_STREAM test is simply a <a href="#UDP_005fSTREAM">UDP_STREAM</a> test using the XTI
rather than BSD Sockets Interface.  The test-specific <samp><span class="option">-X
&lt;devspec&gt;</span></samp> option can be used to specify the name of the local and/or
remote XTI device files, which is required by the <code>t_open()</code> call
made by netperf XTI tests.

   <p>The XTI_UDP_STREAM test is only present if netperf was configured with
<code>--enable-xti=yes</code>. The remote netserver must have also been
configured with <code>--enable-xti=yes</code>.

<div class="node">
<a name="SCTP_STREAM"></a>
<a name="SCTP_005fSTREAM"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#DLCO_005fSTREAM">DLCO_STREAM</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#XTI_005fUDP_005fSTREAM">XTI_UDP_STREAM</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Options-common-to-TCP-UDP-and-SCTP-tests">Options common to TCP UDP and SCTP tests</a>

</div>

<h4 class="subsection">5.2.7 SCTP_STREAM</h4>

<p>An SCTP_STREAM test is essentially a <a href="#TCP_005fSTREAM">TCP_STREAM</a> test using the SCTP
rather than TCP.  The <samp><span class="option">-D</span></samp> option will set SCTP_NODELAY, which
is much like the TCP_NODELAY option for TCP.  The <samp><span class="option">-C</span></samp> option
is not applicable to an SCTP test as there is no corresponding
SCTP_CORK option.  The author is still figuring-out what the
test-specific <samp><span class="option">-N</span></samp> option does :)

   <p>The SCTP_STREAM test is only present if netperf was configured with
<code>--enable-sctp=yes</code>. The remote netserver must have also been
configured with <code>--enable-sctp=yes</code>.

<div class="node">
<a name="DLCO_STREAM"></a>
<a name="DLCO_005fSTREAM"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#DLCL_005fSTREAM">DLCL_STREAM</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#SCTP_005fSTREAM">SCTP_STREAM</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Options-common-to-TCP-UDP-and-SCTP-tests">Options common to TCP UDP and SCTP tests</a>

</div>

<h4 class="subsection">5.2.8 DLCO_STREAM</h4>

<p>A DLPI Connection Oriented Stream (DLCO_STREAM) test is very similar
in concept to a <a href="#TCP_005fSTREAM">TCP_STREAM</a> test.  Both use reliable,
connection-oriented protocols.  The DLPI test differs from the TCP
test in that its protocol operates only at the link-level and does not
include TCP-style segmentation and reassembly.  This last difference
means that the value  passed-in  with the <samp><span class="option">-m</span></samp> option must be
less than the interface MTU.  Otherwise, the <samp><span class="option">-m</span></samp> and
<samp><span class="option">-M</span></samp> options are just like their TCP/UDP/SCTP counterparts.

   <p>Other DLPI-specific options include:

     <dl>
<dt><code>-D &lt;devspec&gt;</code><dd>This option is used to provide the fully-qualified names for the local
and/or remote DLPI device files.  The syntax is otherwise identical to
that of a <dfn>sizespec</dfn>. 
<br><dt><code>-p &lt;ppaspec&gt;</code><dd>This option is used to specify the local and/or remote DLPI PPA(s). 
The PPA is used to identify the interface over which traffic is to be
sent/received. The syntax of a <dfn>ppaspec</dfn> is otherwise the same as
a <dfn>sizespec</dfn>. 
<br><dt><code>-s sap</code><dd>This option specifies the 802.2 SAP for the test.  A SAP is somewhat
like either the port field of a TCP or UDP header or the protocol
field of an IP header.  The specified SAP should not conflict with any
other active SAPs on the specified PPA's (<samp><span class="option">-p</span></samp> option). 
<br><dt><code>-w &lt;sizespec&gt;</code><dd>This option specifies the local send and receive window sizes in units
of frames on those platforms which support setting such things. 
<br><dt><code>-W &lt;sizespec&gt;</code><dd>This option specifies the remote send and receive window sizes in
units of frames on those platforms which support setting such things. 
</dl>

   <p>The DLCO_STREAM test is only present if netperf was configured with
<code>--enable-dlpi=yes</code>. The remote netserver must have also been
configured with <code>--enable-dlpi=yes</code>.

<div class="node">
<a name="DLCL_STREAM"></a>
<a name="DLCL_005fSTREAM"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#STREAM_005fSTREAM">STREAM_STREAM</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#DLCO_005fSTREAM">DLCO_STREAM</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Options-common-to-TCP-UDP-and-SCTP-tests">Options common to TCP UDP and SCTP tests</a>

</div>

<h4 class="subsection">5.2.9 DLCL_STREAM</h4>

<p>A DLPI ConnectionLess Stream (DLCL_STREAM) test is analogous to a
<a href="#UDP_005fSTREAM">UDP_STREAM</a> test in that both make use of unreliable/best-effort,
connection-less transports.  The DLCL_STREAM test differs from the
<a href="#UDP_005fSTREAM">UDP_STREAM</a> test in that the message size (<samp><span class="option">-m</span></samp> option) must
always be less than the link MTU as there is no IP-like fragmentation
and reassembly available and netperf does not presume to provide one.

   <p>The test-specific command-line options for a DLCL_STREAM test are the
same as those for a <a href="#DLCO_005fSTREAM">DLCO_STREAM</a> test.

   <p>The DLCL_STREAM test is only present if netperf was configured with
<code>--enable-dlpi=yes</code>. The remote netserver must have also been
configured with <code>--enable-dlpi=yes</code>.

<div class="node">
<a name="STREAM_STREAM"></a>
<a name="STREAM_005fSTREAM"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#DG_005fSTREAM">DG_STREAM</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#DLCL_005fSTREAM">DLCL_STREAM</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Options-common-to-TCP-UDP-and-SCTP-tests">Options common to TCP UDP and SCTP tests</a>

</div>

<!-- node-name,  next,  previous,  up -->
<h4 class="subsection">5.2.10 STREAM_STREAM</h4>

<p>A Unix Domain Stream Socket Stream test (STREAM_STREAM) is similar in
concept to a <a href="#TCP_005fSTREAM">TCP_STREAM</a> test, but using Unix Domain sockets.  It is,
naturally, limited to intra-machine traffic.  A STREAM_STREAM test
shares the <samp><span class="option">-m</span></samp>, <samp><span class="option">-M</span></samp>, <samp><span class="option">-s</span></samp> and <samp><span class="option">-S</span></samp>
options of the other _STREAM tests.  In a STREAM_STREAM test the
<samp><span class="option">-p</span></samp> option sets the directory in which the pipes will be
created rather than setting a port number.  The default is to create
the pipes in the system default for the <code>tempnam()</code> call.

   <p>The STREAM_STREAM test is only present if netperf was configured with
<code>--enable-unixdomain=yes</code>. The remote netserver must have also been
configured with <code>--enable-unixdomain=yes</code>.

<div class="node">
<a name="DG_STREAM"></a>
<a name="DG_005fSTREAM"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#STREAM_005fSTREAM">STREAM_STREAM</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Options-common-to-TCP-UDP-and-SCTP-tests">Options common to TCP UDP and SCTP tests</a>

</div>

<!-- node-name,  next,  previous,  up -->
<h4 class="subsection">5.2.11 DG_STREAM</h4>

<p>A Unix Domain Datagram Socket Stream test (SG_STREAM) is very much
like a <a href="#TCP_005fSTREAM">TCP_STREAM</a> test except that message boundaries are preserved. 
In this way, it may also be considered similar to certain flavors of
SCTP test which can also preserve message boundaries.

   <p>All the options of a <a href="#STREAM_005fSTREAM">STREAM_STREAM</a> test are applicable to a DG_STREAM
test.

   <p>The DG_STREAM test is only present if netperf was configured with
<code>--enable-unixdomain=yes</code>. The remote netserver must have also been
configured with <code>--enable-unixdomain=yes</code>.

<div class="node">
<a name="Using-Netperf-to-Measure-Request%2fResponse"></a>
<a name="Using-Netperf-to-Measure-Request_002fResponse"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Using-Netperf-to-Measure-Aggregate-Performance">Using Netperf to Measure Aggregate Performance</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Using-Netperf-to-Measure-Bulk-Data-Transfer">Using Netperf to Measure Bulk Data Transfer</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">6 Using Netperf to Measure Request/Response</h2>

<p>Request/response performance is often overlooked, yet it is just as
important as bulk-transfer performance.  While things like larger
socket buffers and TCP windows, and stateless offloads like TSO and
LRO can cover a multitude of latency and even path-length sins, those
sins cannot easily hide from a request/response test.  The convention
for a request/response test is to have a _RR suffix.  There are
however a few &ldquo;request/response&rdquo; tests that have other suffixes.

   <p>A request/response test, particularly synchronous, one transaction at
a time test such as those found by default in netperf, is particularly
sensitive to the path-length of the networking stack.  An _RR test can
also uncover those platforms where the NICs are strapped by default
with overbearing interrupt avoidance settings in an attempt to
increase the bulk-transfer performance (or rather, decrease the CPU
utilization of a bulk-transfer test).  This sensitivity is most acute
for small request and response sizes, such as the single-byte default
for a netperf _RR test.

   <p>While a bulk-transfer test reports its results in units of bits or
bytes transferred per second, by default a mumble_RR test reports
transactions per second where a transaction is defined as the
completed exchange of a request and a response.  One can invert the
transaction rate to arrive at the average round-trip latency.  If one
is confident about the symmetry of the connection, the average one-way
latency can be taken as one-half the average round-trip latency. As of
version 2.5.0 (actually slightly before) netperf still does not do the
latter, but will do the former if one sets the verbosity to 2 for a
classic netperf test, or includes the appropriate <a href="#Omni-Output-Selectors">output selector</a> in an <a href="#The-Omni-Tests">omni test</a>.  It
will also allow the user to switch the throughput units from
transactions per second to bits or bytes per second with the global
<samp><span class="option">-f</span></samp> option.

<ul class="menu">
<li><a accesskey="1" href="#Issues-in-Request_002fResponse">Issues in Request/Response</a>
<li><a accesskey="2" href="#Options-Common-to-TCP-UDP-and-SCTP-_005fRR-tests">Options Common to TCP UDP and SCTP _RR tests</a>
</ul>

<div class="node">
<a name="Issues-in-Request%2fResponse"></a>
<a name="Issues-in-Request_002fResponse"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Options-Common-to-TCP-UDP-and-SCTP-_005fRR-tests">Options Common to TCP UDP and SCTP _RR tests</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Using-Netperf-to-Measure-Request_002fResponse">Using Netperf to Measure Request/Response</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Using-Netperf-to-Measure-Request_002fResponse">Using Netperf to Measure Request/Response</a>

</div>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">6.1 Issues in Request/Response</h3>

<p>Most if not all the <a href="#Issues-in-Bulk-Transfer">Issues in Bulk Transfer</a> apply to
request/response.  The issue of round-trip latency is even more
important as netperf generally only has one transaction outstanding at
a time.

   <p>A single instance of a one transaction outstanding _RR test should
_never_ completely saturate the CPU of a system.  If testing between
otherwise evenly matched systems, the symmetric nature of a _RR test
with equal request and response sizes should result in equal CPU
loading on both systems. However, this may not hold true on MP
systems, particularly if one CPU binds the netperf and netserver
differently via the global <samp><span class="option">-T</span></samp> option.

   <p>For smaller request and response sizes packet loss is a bigger issue
as there is no opportunity for a <dfn>fast retransmit</dfn> or
retransmission prior to a retransmission timer expiring.

   <p>Virtualization may considerably increase the effective path length of
a networking stack.  While this may not preclude achieving link-rate
on a comparatively slow link (eg 1 Gigabit Ethernet) on a _STREAM
test, it can show-up as measurably fewer transactions per second on an
_RR test.  However, this may still be masked by interrupt coalescing
in the NIC/driver.

   <p>Certain NICs have ways to minimize the number of interrupts sent to
the host.  If these are strapped badly they can significantly reduce
the performance of something like a single-byte request/response test. 
Such setups are distinguished by seriously low reported CPU utilization
and what seems like a low (even if in the thousands) transaction per
second rate.  Also, if you run such an OS/driver combination on faster
or slower hardware and do not see a corresponding change in the
transaction rate, chances are good that the driver is strapping the
NIC with aggressive interrupt avoidance settings.  Good for bulk
throughput, but bad for latency.

   <p>Some drivers may try to automagically adjust the interrupt avoidance
settings.  If they are not terribly good at it, you will see
considerable run-to-run variation in reported transaction rates. 
Particularly if you &ldquo;mix-up&rdquo; _STREAM and _RR tests.

<div class="node">
<a name="Options-Common-to-TCP-UDP-and-SCTP-_RR-tests"></a>
<a name="Options-Common-to-TCP-UDP-and-SCTP-_005fRR-tests"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Issues-in-Request_002fResponse">Issues in Request/Response</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Using-Netperf-to-Measure-Request_002fResponse">Using Netperf to Measure Request/Response</a>

</div>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">6.2 Options Common to TCP UDP and SCTP _RR tests</h3>

<p>Many &ldquo;test-specific&rdquo; options are actually common across the
different tests.  For those tests involving TCP, UDP and SCTP, whether
using the BSD Sockets or the XTI interface those common options
include:

     
<a name="index-g_t_002dh_002c-Test_002dspecific-58"></a>
<dl><dt><code>-h</code><dd>Display the test-suite-specific usage string and exit.  For a TCP_ or
UDP_ test this will be the usage string from the source file
<samp><span class="file">nettest_bsd.c</span></samp>.  For an XTI_ test, this will be the usage string
from the source file <samp><span class="file">src/nettest_xti.c</span></samp>.  For an SCTP test, this
will be the usage string from the source file
<samp><span class="file">src/nettest_sctp.c</span></samp>.

     <p><a name="index-g_t_002dH_002c-Test_002dspecific-59"></a><br><dt><code>-H &lt;optionspec&gt;</code><dd>Normally, the remote hostname|IP and address family information is
inherited from the settings for the control connection (eg global
command-line <samp><span class="option">-H</span></samp>, <samp><span class="option">-4</span></samp> and/or <samp><span class="option">-6</span></samp> options. 
The test-specific <samp><span class="option">-H</span></samp> will override those settings for the
data (aka test) connection only.  Settings for the control connection
are left unchanged.  This might be used to cause the control and data
connections to take different paths through the network.

     <p><a name="index-g_t_002dL_002c-Test_002dspecific-60"></a><br><dt><code>-L &lt;optionspec&gt;</code><dd>The test-specific <samp><span class="option">-L</span></samp> option is identical to the test-specific
<samp><span class="option">-H</span></samp> option except it affects the local hostname|IP and address
family information.  As with its global command-line counterpart, this
is generally only useful when measuring though those evil, end-to-end
breaking things called firewalls.

     <p><a name="index-g_t_002dP_002c-Test_002dspecific-61"></a><br><dt><code>-P &lt;optionspec&gt;</code><dd>Set the local and/or remote port numbers for the data connection.

     <p><a name="index-g_t_002dr_002c-Test_002dspecific-62"></a><br><dt><code>-r &lt;sizespec&gt;</code><dd>This option sets the request (first value) and/or response (second
value) sizes for an _RR test. By default the units are bytes, but a
suffix of &ldquo;G,&rdquo; &ldquo;M,&rdquo; or &ldquo;K&rdquo; will specify the units to be 2^30
(GB), 2^20 (MB) or 2^10 (KB) respectively.  A suffix of &ldquo;g,&rdquo; &ldquo;m&rdquo;
or &ldquo;k&rdquo; will specify units of 10^9, 10^6 or 10^3 bytes
respectively. For example:
     <pre class="example">          <code>-r 128,16K</code>
</pre>
     <p>Will set the request size to 128 bytes and the response size to 16 KB
or 16384 bytes. [Default: 1 - a single-byte request and response ]

     <p><a name="index-g_t_002ds_002c-Test_002dspecific-63"></a><br><dt><code>-s &lt;sizespec&gt;</code><dd>This option sets the local (netperf) send and receive socket buffer
sizes for the data connection to the value(s) specified.  Often, this
will affect the advertised and/or effective TCP or other window, but
on some platforms it may not. By default the units are bytes, but a
suffix of &ldquo;G,&rdquo; &ldquo;M,&rdquo; or &ldquo;K&rdquo; will specify the units to be 2^30
(GB), 2^20 (MB) or 2^10 (KB) respectively.  A suffix of &ldquo;g,&rdquo; &ldquo;m&rdquo;
or &ldquo;k&rdquo; will specify units of 10^9, 10^6 or 10^3 bytes
respectively. For example:
     <pre class="example">          <code>-s 128K</code>
</pre>
     <p>Will request the local send (netperf) and receive socket buffer sizes
to be 128KB or 131072 bytes.

     <p>While the historic expectation is that setting the socket buffer size
has a direct effect on say the TCP window, today that may not hold
true for all stacks.  When running under Windows a value of 0 may be
used which will be an indication to the stack the user wants to enable
a form of copy avoidance. [Default: -1 - use the system's default
socket buffer sizes]

     <p><a name="index-g_t_002dS_002c-Test_002dspecific-64"></a><br><dt><code>-S &lt;sizespec&gt;</code><dd>This option sets the remote (netserver) send and/or receive socket
buffer sizes for the data connection to the value(s) specified. 
Often, this will affect the advertised and/or effective TCP or other
window, but on some platforms it may not. By default the units are
bytes, but a suffix of &ldquo;G,&rdquo; &ldquo;M,&rdquo; or &ldquo;K&rdquo; will specify the units
to be 2^30 (GB), 2^20 (MB) or 2^10 (KB) respectively.  A suffix of
&ldquo;g,&rdquo; &ldquo;m&rdquo; or &ldquo;k&rdquo; will specify units of 10^9, 10^6 or 10^3 bytes
respectively.  For example:
     <pre class="example">          <code>-S 128K</code>
</pre>
     <p>Will request the remote (netserver) send and receive socket buffer
sizes to be 128KB or 131072 bytes.

     <p>While the historic expectation is that setting the socket buffer size
has a direct effect on say the TCP window, today that may not hold
true for all stacks.  When running under Windows a value of 0 may be
used which will be an indication to the stack the user wants to enable
a form of copy avoidance.  [Default: -1 - use the system's default
socket buffer sizes]

     <p><a name="index-g_t_002d4_002c-Test_002dspecific-65"></a><br><dt><code>-4</code><dd>Set the local and remote address family for the data connection to
AF_INET - ie use IPv4 addressing only.  Just as with their global
command-line counterparts the last of the <samp><span class="option">-4</span></samp>, <samp><span class="option">-6</span></samp>,
<samp><span class="option">-H</span></samp> or <samp><span class="option">-L</span></samp> option wins for their respective address
families.

     <p><a name="index-g_t_002d6-Test_002dspecific-66"></a><br><dt><code>-6</code><dd>This option is identical to its <samp><span class="option">-4</span></samp> cousin, but requests IPv6
addresses for the local and remote ends of the data connection.

   </dl>

<ul class="menu">
<li><a accesskey="1" href="#TCP_005fRR">TCP_RR</a>
<li><a accesskey="2" href="#TCP_005fCC">TCP_CC</a>
<li><a accesskey="3" href="#TCP_005fCRR">TCP_CRR</a>
<li><a accesskey="4" href="#UDP_005fRR">UDP_RR</a>
<li><a accesskey="5" href="#XTI_005fTCP_005fRR">XTI_TCP_RR</a>
<li><a accesskey="6" href="#XTI_005fTCP_005fCC">XTI_TCP_CC</a>
<li><a accesskey="7" href="#XTI_005fTCP_005fCRR">XTI_TCP_CRR</a>
<li><a accesskey="8" href="#XTI_005fUDP_005fRR">XTI_UDP_RR</a>
<li><a accesskey="9" href="#DLCL_005fRR">DLCL_RR</a>
<li><a href="#DLCO_005fRR">DLCO_RR</a>
<li><a href="#SCTP_005fRR">SCTP_RR</a>
</ul>

<div class="node">
<a name="TCP_RR"></a>
<a name="TCP_005fRR"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#TCP_005fCC">TCP_CC</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Options-Common-to-TCP-UDP-and-SCTP-_005fRR-tests">Options Common to TCP UDP and SCTP _RR tests</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Options-Common-to-TCP-UDP-and-SCTP-_005fRR-tests">Options Common to TCP UDP and SCTP _RR tests</a>

</div>

<h4 class="subsection">6.2.1 TCP_RR</h4>

<p><a name="index-Measuring-Latency-67"></a><a name="index-Latency_002c-Request_002dResponse-68"></a>
A TCP_RR (TCP Request/Response) test is requested by passing a value
of &ldquo;TCP_RR&rdquo; to the global <samp><span class="option">-t</span></samp> command-line option.  A TCP_RR
test can be thought-of as a user-space to user-space <code>ping</code> with
no think time - it is by default a synchronous, one transaction at a
time, request/response test.

   <p>The transaction rate is the number of complete transactions exchanged
divided by the length of time it took to perform those transactions.

   <p>If the two Systems Under Test are otherwise identical, a TCP_RR test
with the same request and response size should be symmetric - it
should not matter which way the test is run, and the CPU utilization
measured should be virtually the same on each system.  If not, it
suggests that the CPU utilization mechanism being used may have some,
well, issues measuring CPU utilization completely and accurately.

   <p>Time to establish the TCP connection is not counted in the result.  If
you want connection setup overheads included, you should consider the
<a href="#TCP_005fCC">TPC_CC</a> or <a href="#TCP_005fCRR">TCP_CRR</a> tests.

   <p>If specifying the <samp><span class="option">-D</span></samp> option to set TCP_NODELAY and disable
the Nagle Algorithm increases the transaction rate reported by a
TCP_RR test, it implies the stack(s) over which the TCP_RR test is
running have a broken implementation of the Nagle Algorithm.  Likely
as not they are interpreting Nagle on a segment by segment basis
rather than a user send by user send basis.  You should contact your
stack vendor(s) to report the problem to them.

   <p>Here is an example of two systems running a basic TCP_RR test over a
10 Gigabit Ethernet link:

<pre class="example">     netperf -t TCP_RR -H 192.168.2.125
     TCP REQUEST/RESPONSE TEST from 0.0.0.0 (0.0.0.0) port 0 AF_INET to 192.168.2.125 (192.168.2.125) port 0 AF_INET
     Local /Remote
     Socket Size   Request  Resp.   Elapsed  Trans.
     Send   Recv   Size     Size    Time     Rate
     bytes  Bytes  bytes    bytes   secs.    per sec
     
     16384  87380  1        1       10.00    29150.15
     16384  87380
</pre>
   <p>In this example the request and response sizes were one byte, the
socket buffers were left at their defaults, and the test ran for all
of 10 seconds.  The transaction per second rate was rather good for
the time :)

<div class="node">
<a name="TCP_CC"></a>
<a name="TCP_005fCC"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#TCP_005fCRR">TCP_CRR</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#TCP_005fRR">TCP_RR</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Options-Common-to-TCP-UDP-and-SCTP-_005fRR-tests">Options Common to TCP UDP and SCTP _RR tests</a>

</div>

<h4 class="subsection">6.2.2 TCP_CC</h4>

<p><a name="index-Connection-Latency-69"></a><a name="index-Latency_002c-Connection-Establishment-70"></a>
A TCP_CC (TCP Connect/Close) test is requested by passing a value of
&ldquo;TCP_CC&rdquo; to the global <samp><span class="option">-t</span></samp> option.  A TCP_CC test simply
measures how fast the pair of systems can open and close connections
between one another in a synchronous (one at a time) manner.  While
this is considered an _RR test, no request or response is exchanged
over the connection.

   <p><a name="index-Port-Reuse-71"></a><a name="index-TIME_005fWAIT-72"></a>The issue of TIME_WAIT reuse is an important one for a TCP_CC test. 
Basically, TIME_WAIT reuse is when a pair of systems churn through
connections fast enough that they wrap the 16-bit port number space in
less time than the length of the TIME_WAIT state.  While it is indeed
theoretically possible to &ldquo;reuse&rdquo; a connection in TIME_WAIT, the
conditions under which such reuse is possible are rather rare.  An
attempt to reuse a connection in TIME_WAIT can result in a non-trivial
delay in connection establishment.

   <p>Basically, any time the connection churn rate approaches:

   <p>Sizeof(clientportspace) / Lengthof(TIME_WAIT)

   <p>there is the risk of TIME_WAIT reuse.  To minimize the chances of this
happening, netperf will by default select its own client port numbers
from the range of 5000 to 65535.  On systems with a 60 second
TIME_WAIT state, this should allow roughly 1000 transactions per
second.  The size of the client port space used by netperf can be
controlled via the test-specific <samp><span class="option">-p</span></samp> option, which takes a
<dfn>sizespec</dfn> as a value setting the minimum (first value) and
maximum (second value) port numbers used by netperf at the client end.

   <p>Since no requests or responses are exchanged during a TCP_CC test,
only the <samp><span class="option">-H</span></samp>, <samp><span class="option">-L</span></samp>, <samp><span class="option">-4</span></samp> and <samp><span class="option">-6</span></samp> of the
&ldquo;common&rdquo; test-specific options are likely to have an effect, if any,
on the results.  The <samp><span class="option">-s</span></samp> and <samp><span class="option">-S</span></samp> options _may_ have
some effect if they alter the number and/or type of options carried in
the TCP SYNchronize segments, such as Window Scaling or Timestamps. 
The <samp><span class="option">-P</span></samp> and <samp><span class="option">-r</span></samp> options are utterly ignored.

   <p>Since connection establishment and tear-down for TCP is not symmetric,
a TCP_CC test is not symmetric in its loading of the two systems under
test.

<div class="node">
<a name="TCP_CRR"></a>
<a name="TCP_005fCRR"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#UDP_005fRR">UDP_RR</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#TCP_005fCC">TCP_CC</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Options-Common-to-TCP-UDP-and-SCTP-_005fRR-tests">Options Common to TCP UDP and SCTP _RR tests</a>

</div>

<h4 class="subsection">6.2.3 TCP_CRR</h4>

<p><a name="index-Latency_002c-Connection-Establishment-73"></a><a name="index-Latency_002c-Request_002dResponse-74"></a>
The TCP Connect/Request/Response (TCP_CRR) test is requested by
passing a value of &ldquo;TCP_CRR&rdquo; to the global <samp><span class="option">-t</span></samp> command-line
option.  A TCP_CRR test is like a merger of a <a href="#TCP_005fRR">TCP_RR</a> and
<a href="#TCP_005fCC">TCP_CC</a> test which measures the performance of establishing a
connection, exchanging a single request/response transaction, and
tearing-down that connection.  This is very much like what happens in
an HTTP 1.0 or HTTP 1.1 connection when HTTP Keepalives are not used. 
In fact, the TCP_CRR test was added to netperf to simulate just that.

   <p>Since a request and response are exchanged the <samp><span class="option">-r</span></samp>,
<samp><span class="option">-s</span></samp> and <samp><span class="option">-S</span></samp> options can have an effect on the
performance.

   <p>The issue of TIME_WAIT reuse exists for the TCP_CRR test just as it
does for the TCP_CC test.  Similarly, since connection establishment
and tear-down is not symmetric, a TCP_CRR test is not symmetric even
when the request and response sizes are the same.

<div class="node">
<a name="UDP_RR"></a>
<a name="UDP_005fRR"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#XTI_005fTCP_005fRR">XTI_TCP_RR</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#TCP_005fCRR">TCP_CRR</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Options-Common-to-TCP-UDP-and-SCTP-_005fRR-tests">Options Common to TCP UDP and SCTP _RR tests</a>

</div>

<h4 class="subsection">6.2.4 UDP_RR</h4>

<p><a name="index-Latency_002c-Request_002dResponse-75"></a><a name="index-Packet-Loss-76"></a>
A UDP Request/Response (UDP_RR) test is requested by passing a value
of &ldquo;UDP_RR&rdquo; to a global <samp><span class="option">-t</span></samp> option.  It is very much the
same as a TCP_RR test except UDP is used rather than TCP.

   <p>UDP does not provide for retransmission of lost UDP datagrams, and
netperf does not add anything for that either.  This means that if
_any_ request or response is lost, the exchange of requests and
responses will stop from that point until the test timer expires. 
Netperf will not really &ldquo;know&rdquo; this has happened - the only symptom
will be a low transaction per second rate.  If <samp><span class="option">--enable-burst</span></samp>
was included in the <code>configure</code> command and a test-specific
<samp><span class="option">-b</span></samp> option used, the UDP_RR test will &ldquo;survive&rdquo; the loss of
requests and responses until the sum is one more than the value passed
via the <samp><span class="option">-b</span></samp> option. It will though almost certainly run more
slowly.

   <p>The netperf side of a UDP_RR test will call <code>connect()</code> on its
data socket and thenceforth use the <code>send()</code> and <code>recv()</code>
socket calls.  The netserver side of a UDP_RR test will not call
<code>connect()</code> and will use <code>recvfrom()</code> and <code>sendto()</code>
calls.  This means that even if the request and response sizes are the
same, a UDP_RR test is _not_ symmetric in its loading of the two
systems under test.

   <p>Here is an example of a UDP_RR test between two otherwise
identical two-CPU systems joined via a 1 Gigabit Ethernet network:

<pre class="example">     $ netperf -T 1 -H 192.168.1.213 -t UDP_RR -c -C
     UDP REQUEST/RESPONSE TEST from 0.0.0.0 (0.0.0.0) port 0 AF_INET to 192.168.1.213 (192.168.1.213) port 0 AF_INET
     Local /Remote
     Socket Size   Request Resp.  Elapsed Trans.   CPU    CPU    S.dem   S.dem
     Send   Recv   Size    Size   Time    Rate     local  remote local   remote
     bytes  bytes  bytes   bytes  secs.   per sec  % I    % I    us/Tr   us/Tr
     
     65535  65535  1       1      10.01   15262.48   13.90  16.11  18.221  21.116
     65535  65535
</pre>
   <p>This example includes the <samp><span class="option">-c</span></samp> and <samp><span class="option">-C</span></samp> options to
enable CPU utilization reporting and shows the asymmetry in CPU
loading.  The <samp><span class="option">-T</span></samp> option was used to make sure netperf and
netserver ran on a given CPU and did not move around during the test.

<div class="node">
<a name="XTI_TCP_RR"></a>
<a name="XTI_005fTCP_005fRR"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#XTI_005fTCP_005fCC">XTI_TCP_CC</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#UDP_005fRR">UDP_RR</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Options-Common-to-TCP-UDP-and-SCTP-_005fRR-tests">Options Common to TCP UDP and SCTP _RR tests</a>

</div>

<h4 class="subsection">6.2.5 XTI_TCP_RR</h4>

<p><a name="index-Latency_002c-Request_002dResponse-77"></a>
An XTI_TCP_RR test is essentially the same as a <a href="#TCP_005fRR">TCP_RR</a> test only
using the XTI rather than BSD Sockets interface. It is requested by
passing a value of &ldquo;XTI_TCP_RR&rdquo; to the <samp><span class="option">-t</span></samp> global
command-line option.

   <p>The test-specific options for an XTI_TCP_RR test are the same as those
for a TCP_RR test with the addition of the <samp><span class="option">-X &lt;devspec&gt;</span></samp> option to
specify the names of the local and/or remote XTI device file(s).

<div class="node">
<a name="XTI_TCP_CC"></a>
<a name="XTI_005fTCP_005fCC"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#XTI_005fTCP_005fCRR">XTI_TCP_CRR</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#XTI_005fTCP_005fRR">XTI_TCP_RR</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Options-Common-to-TCP-UDP-and-SCTP-_005fRR-tests">Options Common to TCP UDP and SCTP _RR tests</a>

</div>

<!-- node-name,  next,  previous,  up -->
<h4 class="subsection">6.2.6 XTI_TCP_CC</h4>

<p><a name="index-Latency_002c-Connection-Establishment-78"></a>
An XTI_TCP_CC test is essentially the same as a <a href="#TCP_005fCC">TCP_CC</a>
test, only using the XTI rather than BSD Sockets interface.

   <p>The test-specific options for an XTI_TCP_CC test are the same as those
for a TCP_CC test with the addition of the <samp><span class="option">-X &lt;devspec&gt;</span></samp> option to
specify the names of the local and/or remote XTI device file(s).

<div class="node">
<a name="XTI_TCP_CRR"></a>
<a name="XTI_005fTCP_005fCRR"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#XTI_005fUDP_005fRR">XTI_UDP_RR</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#XTI_005fTCP_005fCC">XTI_TCP_CC</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Options-Common-to-TCP-UDP-and-SCTP-_005fRR-tests">Options Common to TCP UDP and SCTP _RR tests</a>

</div>

<!-- node-name,  next,  previous,  up -->
<h4 class="subsection">6.2.7 XTI_TCP_CRR</h4>

<p><a name="index-Latency_002c-Connection-Establishment-79"></a><a name="index-Latency_002c-Request_002dResponse-80"></a>
The XTI_TCP_CRR test is essentially the same as a
<a href="#TCP_005fCRR">TCP_CRR</a> test, only using the XTI rather than BSD Sockets
interface.

   <p>The test-specific options for an XTI_TCP_CRR test are the same as those
for a TCP_RR test with the addition of the <samp><span class="option">-X &lt;devspec&gt;</span></samp> option to
specify the names of the local and/or remote XTI device file(s).

<div class="node">
<a name="XTI_UDP_RR"></a>
<a name="XTI_005fUDP_005fRR"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#DLCL_005fRR">DLCL_RR</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#XTI_005fTCP_005fCRR">XTI_TCP_CRR</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Options-Common-to-TCP-UDP-and-SCTP-_005fRR-tests">Options Common to TCP UDP and SCTP _RR tests</a>

</div>

<h4 class="subsection">6.2.8 XTI_UDP_RR</h4>

<p><a name="index-Latency_002c-Request_002dResponse-81"></a>
An XTI_UDP_RR test is essentially the same as a UDP_RR test only using
the XTI rather than BSD Sockets interface.  It is requested by passing
a value of &ldquo;XTI_UDP_RR&rdquo; to the <samp><span class="option">-t</span></samp> global command-line
option.

   <p>The test-specific options for an XTI_UDP_RR test are the same as those
for a UDP_RR test with the addition of the <samp><span class="option">-X &lt;devspec&gt;</span></samp>
option to specify the name of the local and/or remote XTI device
file(s).

<div class="node">
<a name="DLCL_RR"></a>
<a name="DLCL_005fRR"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#DLCO_005fRR">DLCO_RR</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#XTI_005fUDP_005fRR">XTI_UDP_RR</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Options-Common-to-TCP-UDP-and-SCTP-_005fRR-tests">Options Common to TCP UDP and SCTP _RR tests</a>

</div>

<!-- node-name,  next,  previous,  up -->
<h4 class="subsection">6.2.9 DLCL_RR</h4>

<p><a name="index-Latency_002c-Request_002dResponse-82"></a>
<div class="node">
<a name="DLCO_RR"></a>
<a name="DLCO_005fRR"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#SCTP_005fRR">SCTP_RR</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#DLCL_005fRR">DLCL_RR</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Options-Common-to-TCP-UDP-and-SCTP-_005fRR-tests">Options Common to TCP UDP and SCTP _RR tests</a>

</div>

<!-- node-name,  next,  previous,  up -->
<h4 class="subsection">6.2.10 DLCO_RR</h4>

<p><a name="index-Latency_002c-Request_002dResponse-83"></a>
<div class="node">
<a name="SCTP_RR"></a>
<a name="SCTP_005fRR"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#DLCO_005fRR">DLCO_RR</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Options-Common-to-TCP-UDP-and-SCTP-_005fRR-tests">Options Common to TCP UDP and SCTP _RR tests</a>

</div>

<!-- node-name,  next,  previous,  up -->
<h4 class="subsection">6.2.11 SCTP_RR</h4>

<p><a name="index-Latency_002c-Request_002dResponse-84"></a>
<div class="node">
<a name="Using-Netperf-to-Measure-Aggregate-Performance"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Using-Netperf-to-Measure-Bidirectional-Transfer">Using Netperf to Measure Bidirectional Transfer</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Using-Netperf-to-Measure-Request_002fResponse">Using Netperf to Measure Request/Response</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<!-- node-name,  next,  previous,  up -->
<h2 class="chapter">7 Using Netperf to Measure Aggregate Performance</h2>

<p><a name="index-Aggregate-Performance-85"></a><a name="index-g_t_002d_002denable_002dburst_002c-Configure-86"></a>
Ultimately, <a href="#Netperf4">Netperf4</a> will be the preferred benchmark to
use when one wants to measure aggregate performance because netperf
has no support for explicit synchronization of concurrent tests. Until
netperf4 is ready for prime time, one can make use of the heuristics
and procedures mentioned here for the 85% solution.

   <p>There are a few ways to measure aggregate performance with netperf. 
The first is to run multiple, concurrent netperf tests and can be
applied to any of the netperf tests.  The second is to configure
netperf with <code>--enable-burst</code> and is applicable to the TCP_RR
test. The third is a variation on the first.

<ul class="menu">
<li><a accesskey="1" href="#Running-Concurrent-Netperf-Tests">Running Concurrent Netperf Tests</a>
<li><a accesskey="2" href="#Using-_002d_002denable_002dburst">Using --enable-burst</a>
<li><a accesskey="3" href="#Using-_002d_002denable_002ddemo">Using --enable-demo</a>
</ul>

<div class="node">
<a name="Running-Concurrent-Netperf-Tests"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Using-_002d_002denable_002dburst">Using --enable-burst</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Using-Netperf-to-Measure-Aggregate-Performance">Using Netperf to Measure Aggregate Performance</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Using-Netperf-to-Measure-Aggregate-Performance">Using Netperf to Measure Aggregate Performance</a>

</div>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">7.1 Running Concurrent Netperf Tests</h3>

<p><a href="#Netperf4">Netperf4</a> is the preferred benchmark to use when one
wants to measure aggregate performance because netperf has no support
for explicit synchronization of concurrent tests.  This leaves
netperf2 results vulnerable to <dfn>skew</dfn> errors.

   <p>However, since there are times when netperf4 is unavailable it may be
necessary to run netperf. The skew error can be minimized by making
use of the confidence interval functionality.  Then one simply
launches multiple tests from the shell using a <code>for</code> loop or the
like:

<pre class="example">     for i in 1 2 3 4
     do
     netperf -t TCP_STREAM -H tardy.cup.hp.com -i 10 -P 0 &amp;
     done
</pre>
   <p>which will run four, concurrent <a href="#TCP_005fSTREAM">TCP_STREAM</a> tests from
the system on which it is executed to tardy.cup.hp.com.  Each
concurrent netperf will iterate 10 times thanks to the <samp><span class="option">-i</span></samp>
option and will omit the test banners (option <samp><span class="option">-P</span></samp>) for
brevity.  The output looks something like this:

<pre class="example">      87380  16384  16384    10.03     235.15
      87380  16384  16384    10.03     235.09
      87380  16384  16384    10.03     235.38
      87380  16384  16384    10.03     233.96
</pre>
   <p>We can take the sum of the results and be reasonably confident that
the aggregate performance was 940 Mbits/s.  This method does not need
to be limited to one system speaking to one other system.  It can be
extended to one system talking to N other systems.  It could be as simple as:
<pre class="example">     for host in 'foo bar baz bing'
     do
     netperf -t TCP_STREAM -H $hosts -i 10 -P 0 &amp;
     done
</pre>
   <p>A more complicated/sophisticated example can be found in
<samp><span class="file">doc/examples/runemomniagg2.sh</span></samp> where.

   <p>If you see warnings about netperf not achieving the confidence
intervals, the best thing to do is to increase the number of
iterations with <samp><span class="option">-i</span></samp> and/or increase the run length of each
iteration with <samp><span class="option">-l</span></samp>.

   <p>You can also enable local (<samp><span class="option">-c</span></samp>) and/or remote (<samp><span class="option">-C</span></samp>)
CPU utilization:

<pre class="example">     for i in 1 2 3 4
     do
     netperf -t TCP_STREAM -H tardy.cup.hp.com -i 10 -P 0 -c -C &amp;
     done
     
     87380  16384  16384    10.03       235.47   3.67     5.09     10.226  14.180
     87380  16384  16384    10.03       234.73   3.67     5.09     10.260  14.225
     87380  16384  16384    10.03       234.64   3.67     5.10     10.263  14.231
     87380  16384  16384    10.03       234.87   3.67     5.09     10.253  14.215
</pre>
   <p>If the CPU utilizations reported for the same system are the same or
very very close you can be reasonably confident that skew error is
minimized.  Presumably one could then omit <samp><span class="option">-i</span></samp> but that is
not advised, particularly when/if the CPU utilization approaches 100
percent.  In the example above we see that the CPU utilization on the
local system remains the same for all four tests, and is only off by
0.01 out of 5.09 on the remote system.  As the number of CPUs in the
system increases, and so too the odds of saturating a single CPU, the
accuracy of similar CPU utilization implying little skew error is
diminished.  This is also the case for those increasingly rare single
CPU systems if the utilization is reported as 100% or very close to
it.

   <blockquote>
<b>NOTE: It is very important to remember that netperf is calculating
system-wide CPU utilization.  When calculating the service demand
(those last two columns in the output above) each netperf assumes it
is the only thing running on the system.  This means that for
concurrent tests the service demands reported by netperf will be
wrong.  One has to compute service demands for concurrent tests by
hand.</b>
</blockquote>

   <p>If you wish you can add a unique, global <samp><span class="option">-B</span></samp> option to each
command line to append the given string to the output:

<pre class="example">     for i in 1 2 3 4
     do
     netperf -t TCP_STREAM -H tardy.cup.hp.com -B "this is test $i" -i 10 -P 0 &amp;
     done
     
     87380  16384  16384    10.03     234.90   this is test 4
     87380  16384  16384    10.03     234.41   this is test 2
     87380  16384  16384    10.03     235.26   this is test 1
     87380  16384  16384    10.03     235.09   this is test 3
</pre>
   <p>You will notice that the tests completed in an order other than they
were started from the shell.  This underscores why there is a threat
of skew error and why netperf4 will eventually be the preferred tool
for aggregate tests.  Even if you see the Netperf Contributing Editor
acting to the contrary!-)

<ul class="menu">
<li><a accesskey="1" href="#Issues-in-Running-Concurrent-Tests">Issues in Running Concurrent Tests</a>
</ul>

<div class="node">
<a name="Issues-in-Running-Concurrent-Tests"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Running-Concurrent-Netperf-Tests">Running Concurrent Netperf Tests</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Running-Concurrent-Netperf-Tests">Running Concurrent Netperf Tests</a>

</div>

<h4 class="subsection">7.1.1 Issues in Running Concurrent Tests</h4>

<p>In addition to the aforementioned issue of skew error, there can be
other issues to consider when running concurrent netperf tests.

   <p>For example, when running concurrent tests over multiple interfaces,
one is not always assured that the traffic one thinks went over a
given interface actually did so.  In particular, the Linux networking
stack takes a particularly strong stance on its following the so
called &lsquo;<samp><span class="samp">weak end system model</span></samp>&rsquo;.  As such, it is willing to answer
ARP requests for any of its local IP addresses on any of its
interfaces.  If multiple interfaces are connected to the same
broadcast domain, then even if they are configured into separate IP
subnets there is no a priori way of knowing which interface was
actually used for which connection(s).  This can be addressed by
setting the &lsquo;<samp><span class="samp">arp_ignore</span></samp>&rsquo; sysctl before configuring interfaces.

   <p>As it is quite important, we will repeat that it is very important to
remember that each concurrent netperf instance is calculating
system-wide CPU utilization.  When calculating the service demand each
netperf assumes it is the only thing running on the system.  This
means that for concurrent tests the service demands reported by
netperf <b>will be wrong</b>.  One has to compute service demands for
concurrent tests by hand

   <p>Running concurrent tests can also become difficult when there is no
one &ldquo;central&rdquo; node.  Running tests between pairs of systems may be
more difficult, calling for remote shell commands in the for loop
rather than netperf commands.  This introduces more skew error, which
the confidence intervals may not be able to sufficiently mitigate. 
One possibility is to actually run three consecutive netperf tests on
each node - the first being a warm-up, the last being a cool-down. 
The idea then is to ensure that the time it takes to get all the
netperfs started is less than the length of the first netperf command
in the sequence of three.  Similarly, it assumes that all &ldquo;middle&rdquo;
netperfs will complete before the first of the &ldquo;last&rdquo; netperfs
complete.

<div class="node">
<a name="Using---enable-burst"></a>
<a name="Using-_002d_002denable_002dburst"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Using-_002d_002denable_002ddemo">Using --enable-demo</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Running-Concurrent-Netperf-Tests">Running Concurrent Netperf Tests</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Using-Netperf-to-Measure-Aggregate-Performance">Using Netperf to Measure Aggregate Performance</a>

</div>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">7.2 Using - -enable-burst</h3>

<p>Starting in version 2.5.0 <code>--enable-burst=yes</code> is the default,
which means one no longer must:

<pre class="example">     configure --enable-burst
</pre>
   <p>To have burst-mode functionality present in netperf.  This enables a
test-specific <samp><span class="option">-b num</span></samp> option in <a href="#TCP_005fRR">TCP_RR</a>,
<a href="#UDP_005fRR">UDP_RR</a> and <a href="#The-Omni-Tests">omni</a> tests.

   <p>Normally, netperf will attempt to ramp-up the number of outstanding
requests to <samp><span class="option">num</span></samp> plus one transactions in flight at one time. 
The ramp-up is to avoid transactions being smashed together into a
smaller number of segments when the transport's congestion window (if
any) is smaller at the time than what netperf wants to have
outstanding at one time. If, however, the user specifies a negative
value for <samp><span class="option">num</span></samp> this ramp-up is bypassed and the burst of sends
is made without consideration of transport congestion window.

   <p>This burst-mode is used as an alternative to or even in conjunction
with multiple-concurrent _RR tests and as a way to implement a
single-connection, bidirectional bulk-transfer test.  When run with
just a single instance of netperf, increasing the burst size can
determine the maximum number of transactions per second which can be
serviced by a single process:

<pre class="example">     for b in 0 1 2 4 8 16 32
     do
      netperf -v 0 -t TCP_RR -B "-b $b" -H hpcpc108 -P 0 -- -b $b
     done
     
     9457.59 -b 0
     9975.37 -b 1
     10000.61 -b 2
     20084.47 -b 4
     29965.31 -b 8
     71929.27 -b 16
     109718.17 -b 32
</pre>
   <p>The global <samp><span class="option">-v</span></samp> and <samp><span class="option">-P</span></samp> options were used to minimize
the output to the single figure of merit which in this case the
transaction rate.  The global <code>-B</code> option was used to more
clearly label the output, and the test-specific <samp><span class="option">-b</span></samp> option
enabled by <code>--enable-burst</code> increase the number of transactions
in flight at one time.

   <p>Now, since the test-specific <samp><span class="option">-D</span></samp> option was not specified to
set TCP_NODELAY, the stack was free to &ldquo;bundle&rdquo; requests and/or
responses into TCP segments as it saw fit, and since the default
request and response size is one byte, there could have been some
considerable bundling even in the absence of transport congestion
window issues.  If one wants to try to achieve a closer to
one-to-one correspondence between a request and response and a TCP
segment, add the test-specific <samp><span class="option">-D</span></samp> option:

<pre class="example">     for b in 0 1 2 4 8 16 32
     do
      netperf -v 0 -t TCP_RR -B "-b $b -D" -H hpcpc108 -P 0 -- -b $b -D
     done
     
      8695.12 -b 0 -D
      19966.48 -b 1 -D
      20691.07 -b 2 -D
      49893.58 -b 4 -D
      62057.31 -b 8 -D
      108416.88 -b 16 -D
      114411.66 -b 32 -D
</pre>
   <p>You can see that this has a rather large effect on the reported
transaction rate.  In this particular instance, the author believes it
relates to interactions between the test and interrupt coalescing
settings in the driver for the NICs used.

   <blockquote>
<b>NOTE: Even if you set the </b><samp><span class="option">-D</span></samp><b> option that is still not a
guarantee that each transaction is in its own TCP segments.  You
should get into the habit of verifying the relationship between the
transaction rate and the packet rate via other means.</b>
</blockquote>

   <p>You can also combine <code>--enable-burst</code> functionality with
concurrent netperf tests.  This would then be an &ldquo;aggregate of
aggregates&rdquo; if you like:

<pre class="example">     
     for i in 1 2 3 4
     do
      netperf -H hpcpc108 -v 0 -P 0 -i 10 -B "aggregate $i -b 8 -D" -t TCP_RR -- -b 8 -D &amp;
     done
     
      46668.38 aggregate 4 -b 8 -D
      44890.64 aggregate 2 -b 8 -D
      45702.04 aggregate 1 -b 8 -D
      46352.48 aggregate 3 -b 8 -D
     
</pre>
   <p>Since each netperf did hit the confidence intervals, we can be
reasonably certain that the aggregate transaction per second rate was
the sum of all four concurrent tests, or something just shy of 184,000
transactions per second.  To get some idea if that was also the packet
per second rate, we could bracket that <code>for</code> loop with something
to gather statistics and run the results through
<a href="ftp://ftp.cup.hp.com/dist/networking/tools">beforeafter</a>:

<pre class="example">     /usr/sbin/ethtool -S eth2 &gt; before
     for i in 1 2 3 4
     do
      netperf -H 192.168.2.108 -l 60 -v 0 -P 0 -B "aggregate $i -b 8 -D" -t TCP_RR -- -b 8 -D &amp;
     done
     wait
     /usr/sbin/ethtool -S eth2 &gt; after
     
      52312.62 aggregate 2 -b 8 -D
      50105.65 aggregate 4 -b 8 -D
      50890.82 aggregate 1 -b 8 -D
      50869.20 aggregate 3 -b 8 -D
     
     beforeafter before after &gt; delta
     
     grep packets delta
          rx_packets: 12251544
          tx_packets: 12251550
     
</pre>
   <p>This example uses <code>ethtool</code> because the system being used is
running Linux.  Other platforms have other tools - for example HP-UX
has lanadmin:

<pre class="example">     lanadmin -g mibstats &lt;ppa&gt;
</pre>
   <p>and of course one could instead use <code>netstat</code>.

   <p>The <code>wait</code> is important because we are launching concurrent
netperfs in the background.  Without it, the second ethtool command
would be run before the tests finished and perhaps even before the
last of them got started!

   <p>The sum of the reported transaction rates is 204178 over 60 seconds,
which is a total of 12250680 transactions.  Each transaction is the
exchange of a request and a response, so we multiply that by 2 to
arrive at 24501360.

   <p>The sum of the ethtool stats is 24503094 packets which matches what
netperf was reporting very well.

   <p>Had the request or response size differed, we would need to know how
it compared with the <dfn>MSS</dfn> for the connection.

   <p>Just for grins, here is the exercise repeated, using <code>netstat</code>
instead of <code>ethtool</code>

<pre class="example">     netstat -s -t &gt; before
     for i in 1 2 3 4
     do
      netperf -l 60 -H 192.168.2.108 -v 0 -P 0 -B "aggregate $i -b 8 -D" -t TCP_RR -- -b 8 -D &amp; done
     wait
     netstat -s -t &gt; after
     
      51305.88 aggregate 4 -b 8 -D
      51847.73 aggregate 2 -b 8 -D
      50648.19 aggregate 3 -b 8 -D
      53605.86 aggregate 1 -b 8 -D
     
     beforeafter before after &gt; delta
     
     grep segments delta
         12445708 segments received
         12445730 segments send out
         1 segments retransmited
         0 bad segments received.
</pre>
   <p>The sums are left as an exercise to the reader :)

   <p>Things become considerably more complicated if there are non-trvial
packet losses and/or retransmissions.

   <p>Of course all this checking is unnecessary if the test is a UDP_RR
test because UDP &ldquo;never&rdquo; aggregates multiple sends into the same UDP
datagram, and there are no ACKnowledgements in UDP.  The loss of a
single request or response will not bring a &ldquo;burst&rdquo; UDP_RR test to a
screeching halt, but it will reduce the number of transactions
outstanding at any one time.  A &ldquo;burst&rdquo; UDP_RR test <b>will</b> come to a
halt if the sum of the lost requests and responses reaches the value
specified in the test-specific <samp><span class="option">-b</span></samp> option.

<div class="node">
<a name="Using---enable-demo"></a>
<a name="Using-_002d_002denable_002ddemo"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Using-_002d_002denable_002dburst">Using --enable-burst</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Using-Netperf-to-Measure-Aggregate-Performance">Using Netperf to Measure Aggregate Performance</a>

</div>

<h3 class="section">7.3 Using - -enable-demo</h3>

<p>One can
<pre class="example">     configure --enable-demo
</pre>
   <p>and compile netperf to enable netperf to emit &ldquo;interim results&rdquo; at
semi-regular intervals.  This enables a global <code>-D</code> option which
takes a reporting interval as an argument.  With that specified, the
output of netperf will then look something like

<pre class="example">     $ src/netperf -D 1.25
     MIGRATED TCP STREAM TEST from 0.0.0.0 (0.0.0.0) port 0 AF_INET to localhost.localdomain () port 0 AF_INET : demo
     Interim result: 25425.52 10^6bits/s over 1.25 seconds ending at 1327962078.405
     Interim result: 25486.82 10^6bits/s over 1.25 seconds ending at 1327962079.655
     Interim result: 25474.96 10^6bits/s over 1.25 seconds ending at 1327962080.905
     Interim result: 25523.49 10^6bits/s over 1.25 seconds ending at 1327962082.155
     Interim result: 25053.57 10^6bits/s over 1.27 seconds ending at 1327962083.429
     Interim result: 25349.64 10^6bits/s over 1.25 seconds ending at 1327962084.679
     Interim result: 25292.84 10^6bits/s over 1.25 seconds ending at 1327962085.932
     Recv   Send    Send
     Socket Socket  Message  Elapsed
     Size   Size    Size     Time     Throughput
     bytes  bytes   bytes    secs.    10^6bits/sec
     
      87380  16384  16384    10.00    25375.66
</pre>
   <p>The units of the &ldquo;Interim result&rdquo; lines will follow the units
selected via the global <code>-f</code> option.  If the test-specific
<code>-o</code> option is specified on the command line, the format will be
CSV:
<pre class="example">     ...
     2978.81,MBytes/s,1.25,1327962298.035
     ...
</pre>
   <p>If the test-specific <code>-k</code> option is used the format will be
keyval with each keyval being given an index:
<pre class="example">     ...
     NETPERF_INTERIM_RESULT[2]=25.00
     NETPERF_UNITS[2]=10^9bits/s
     NETPERF_INTERVAL[2]=1.25
     NETPERF_ENDING[2]=1327962357.249
     ...
</pre>
   <p>The expectation is it may be easier to utilize the keyvals if they
have indices.

   <p>But how does this help with aggregate tests?  Well, what one can do is
start the netperfs via a script, giving each a Very Long (tm) run
time.  Direct the output to a file per instance.  Then, once all the
netperfs have been started, take a timestamp and wait for some desired
test interval.  Once that interval expires take another timestamp and
then start terminating the netperfs by sending them a SIGALRM signal
via the likes of the <code>kill</code> or <code>pkill</code> command.  The
netperfs will terminate and emit the rest of the &ldquo;usual&rdquo; output, and
you can then bring the files to a central location for post
processing to find the aggregate performance over the &ldquo;test interval.&rdquo;

   <p>This method has the advantage that it does not require advance
knowledge of how long it takes to get netperf tests started and/or
stopped.  It does though require sufficiently synchronized clocks on
all the test systems.

   <p>While calls to get the current time can be inexpensive, that neither
has been nor is universally true.  For that reason netperf tries to
minimize the number of such &ldquo;timestamping&rdquo; calls (eg
<code>gettimeofday</code>) calls it makes when in demo mode.  Rather than
take a timestamp after each <code>send</code> or <code>recv</code> call completes
netperf tries to guess how many units of work will be performed over
the desired interval.  Only once that many units of work have been
completed will netperf check the time.  If the reporting interval has
passed, netperf will emit an &ldquo;interim result.&rdquo;  If the interval has
not passed, netperf will update its estimate for units and continue.

   <p>After a bit of thought one can see that if things &ldquo;speed-up&rdquo; netperf
will still honor the interval.  However, if things &ldquo;slow-down&rdquo;
netperf may be late with an &ldquo;interim result.&rdquo;  Here is an example of
both of those happening during a test - with the interval being
honored while throughput increases, and then about half-way through
when another netperf (not shown) is started we see things slowing down
and netperf not hitting the interval as desired.
<pre class="example">     $ src/netperf -D 2 -H tardy.hpl.hp.com -l 20
     MIGRATED TCP STREAM TEST from 0.0.0.0 (0.0.0.0) port 0 AF_INET to tardy.hpl.hp.com () port 0 AF_INET : demo
     Interim result:   36.46 10^6bits/s over 2.01 seconds ending at 1327963880.565
     Interim result:   59.19 10^6bits/s over 2.00 seconds ending at 1327963882.569
     Interim result:   73.39 10^6bits/s over 2.01 seconds ending at 1327963884.576
     Interim result:   84.01 10^6bits/s over 2.03 seconds ending at 1327963886.603
     Interim result:   75.63 10^6bits/s over 2.21 seconds ending at 1327963888.814
     Interim result:   55.52 10^6bits/s over 2.72 seconds ending at 1327963891.538
     Interim result:   70.94 10^6bits/s over 2.11 seconds ending at 1327963893.650
     Interim result:   80.66 10^6bits/s over 2.13 seconds ending at 1327963895.777
     Interim result:   86.42 10^6bits/s over 2.12 seconds ending at 1327963897.901
     Recv   Send    Send
     Socket Socket  Message  Elapsed
     Size   Size    Size     Time     Throughput
     bytes  bytes   bytes    secs.    10^6bits/sec
     
      87380  16384  16384    20.34      68.87
</pre>
   <p>So long as your post-processing mechanism can account for that, there
should be no problem.  As time passes there may be changes to try to
improve the netperf's honoring the interval but one should not
ass-u-me it will always do so.  One should not assume the precision
will remain fixed - future versions may change it - perhaps going
beyond tenths of seconds in reporting the interval length etc.

<div class="node">
<a name="Using-Netperf-to-Measure-Bidirectional-Transfer"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#The-Omni-Tests">The Omni Tests</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Using-Netperf-to-Measure-Aggregate-Performance">Using Netperf to Measure Aggregate Performance</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<!-- node-name,  next,  previous,  up -->
<h2 class="chapter">8 Using Netperf to Measure Bidirectional Transfer</h2>

<p>There are two ways to use netperf to measure the performance of
bidirectional transfer.  The first is to run concurrent netperf tests
from the command line.  The second is to configure netperf with
<code>--enable-burst</code> and use a single instance of the
<a href="#TCP_005fRR">TCP_RR</a> test.

   <p>While neither method is more &ldquo;correct&rdquo; than the other, each is doing
so in different ways, and that has possible implications.  For
instance, using the concurrent netperf test mechanism means that
multiple TCP connections and multiple processes are involved, whereas
using the single instance of TCP_RR there is only one TCP connection
and one process on each end.  They may behave differently, especially
on an MP system.

<ul class="menu">
<li><a accesskey="1" href="#Bidirectional-Transfer-with-Concurrent-Tests">Bidirectional Transfer with Concurrent Tests</a>
<li><a accesskey="2" href="#Bidirectional-Transfer-with-TCP_005fRR">Bidirectional Transfer with TCP_RR</a>
<li><a accesskey="3" href="#Implications-of-Concurrent-Tests-vs-Burst-Request_002fResponse">Implications of Concurrent Tests vs Burst Request/Response</a>
</ul>

<div class="node">
<a name="Bidirectional-Transfer-with-Concurrent-Tests"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Bidirectional-Transfer-with-TCP_005fRR">Bidirectional Transfer with TCP_RR</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Using-Netperf-to-Measure-Bidirectional-Transfer">Using Netperf to Measure Bidirectional Transfer</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Using-Netperf-to-Measure-Bidirectional-Transfer">Using Netperf to Measure Bidirectional Transfer</a>

</div>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">8.1 Bidirectional Transfer with Concurrent Tests</h3>

<p>If we had two hosts Fred and Ethel, we could simply run a netperf
<a href="#TCP_005fSTREAM">TCP_STREAM</a> test on Fred pointing at Ethel, and a
concurrent netperf TCP_STREAM test on Ethel pointing at Fred, but
since there are no mechanisms to synchronize netperf tests and we
would be starting tests from two different systems, there is a
considerable risk of skew error.

   <p>Far better would be to run simultaneous TCP_STREAM and
<a href="#TCP_005fMAERTS">TCP_MAERTS</a> tests from just <b>one</b> system, using the
concepts and procedures outlined in <a href="#Running-Concurrent-Netperf-Tests">Running Concurrent Netperf Tests</a>. Here then is an example:

<pre class="example">     for i in 1
     do
      netperf -H 192.168.2.108 -t TCP_STREAM -B "outbound" -i 10 -P 0 -v 0 \
        -- -s 256K -S 256K &amp;
      netperf -H 192.168.2.108 -t TCP_MAERTS -B "inbound"  -i 10 -P 0 -v 0 \
        -- -s 256K -S 256K &amp;
     done
     
      892.66 outbound
      891.34 inbound
</pre>
   <p>We have used a <code>for</code> loop in the shell with just one iteration
because that will be <b>much</b> easier to get both tests started at more or
less the same time than doing it by hand.  The global <samp><span class="option">-P</span></samp> and
<samp><span class="option">-v</span></samp> options are used because we aren't interested in anything
other than the throughput, and the global <samp><span class="option">-B</span></samp> option is used
to tag each output so we know which was inbound and which outbound
relative to the system on which we were running netperf.  Of course
that sense is switched on the system running netserver :)  The use of
the global <samp><span class="option">-i</span></samp> option is explained in <a href="#Running-Concurrent-Netperf-Tests">Running Concurrent Netperf Tests</a>.

   <p>Beginning with version 2.5.0 we can accomplish a similar result with
the <a href="#The-Omni-Tests">the omni tests</a> and <a href="#Omni-Output-Selectors">output selectors</a>:

<pre class="example">     for i in 1
     do
       netperf -H 192.168.1.3 -t omni -l 10 -P 0 -- \
         -d stream -s 256K -S 256K -o throughput,direction &amp;
       netperf -H 192.168.1.3 -t omni -l 10 -P 0 -- \
         -d maerts -s 256K -S 256K -o throughput,direction &amp;
     done
     
     805.26,Receive
     828.54,Send
</pre>
   <div class="node">
<a name="Bidirectional-Transfer-with-TCP_RR"></a>
<a name="Bidirectional-Transfer-with-TCP_005fRR"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Implications-of-Concurrent-Tests-vs-Burst-Request_002fResponse">Implications of Concurrent Tests vs Burst Request/Response</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Bidirectional-Transfer-with-Concurrent-Tests">Bidirectional Transfer with Concurrent Tests</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Using-Netperf-to-Measure-Bidirectional-Transfer">Using Netperf to Measure Bidirectional Transfer</a>

</div>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">8.2 Bidirectional Transfer with TCP_RR</h3>

<p>Starting with version 2.5.0 the <code>--enable-burst</code> configure option
defaults to <code>yes</code>, and starting some time before version 2.5.0
but after 2.4.0 the global <samp><span class="option">-f</span></samp> option would affect the
&ldquo;throughput&rdquo; reported by request/response tests.  If one uses the
test-specific <samp><span class="option">-b</span></samp> option to have several &ldquo;transactions&rdquo; in
flight at one time and the test-specific <samp><span class="option">-r</span></samp> option to
increase their size, the test looks more and more like a
single-connection bidirectional transfer than a simple
request/response test.

   <p>So, putting it all together one can do something like:

<pre class="example">     netperf -f m -t TCP_RR -H 192.168.1.3 -v 2 -- -b 6 -r 32K -S 256K -S 256K
     MIGRATED TCP REQUEST/RESPONSE TEST from 0.0.0.0 (0.0.0.0) port 0 AF_INET to 192.168.1.3 (192.168.1.3) port 0 AF_INET : interval : first burst 6
     Local /Remote
     Socket Size   Request  Resp.   Elapsed
     Send   Recv   Size     Size    Time     Throughput
     bytes  Bytes  bytes    bytes   secs.    10^6bits/sec
     
     16384  87380  32768    32768   10.00    1821.30
     524288 524288
     Alignment      Offset         RoundTrip  Trans    Throughput
     Local  Remote  Local  Remote  Latency    Rate     10^6bits/s
     Send   Recv    Send   Recv    usec/Tran  per sec  Outbound   Inbound
         8      0       0      0   2015.402   3473.252 910.492    910.492
</pre>
   <p>to get a bidirectional bulk-throughput result. As one can see, the -v
2 output will include a number of interesting, related values.

   <blockquote>
<b>NOTE: The logic behind </b><code>--enable-burst</code><b> is very simple, and there
are no calls to </b><code>poll()</code><b> or </b><code>select()</code><b> which means we want
to make sure that the </b><code>send()</code><b> calls will never block, or we run
the risk of deadlock with each side stuck trying to call </b><code>send()</code><b>
and neither calling </b><code>recv()</code><b>.</b>
</blockquote>

   <p>Fortunately, this is easily accomplished by setting a &ldquo;large enough&rdquo;
socket buffer size with the test-specific <samp><span class="option">-s</span></samp> and <samp><span class="option">-S</span></samp>
options.  Presently this must be performed by the user.  Future
versions of netperf might attempt to do this automagically, but there
are some issues to be worked-out.

<div class="node">
<a name="Implications-of-Concurrent-Tests-vs-Burst-Request%2fResponse"></a>
<a name="Implications-of-Concurrent-Tests-vs-Burst-Request_002fResponse"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Bidirectional-Transfer-with-TCP_005fRR">Bidirectional Transfer with TCP_RR</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Using-Netperf-to-Measure-Bidirectional-Transfer">Using Netperf to Measure Bidirectional Transfer</a>

</div>

<h3 class="section">8.3 Implications of Concurrent Tests vs Burst Request/Response</h3>

<p>There are perhaps subtle but important differences between using
concurrent unidirectional tests vs a burst-mode request to measure
bidirectional performance.

   <p>Broadly speaking, a single &ldquo;connection&rdquo; or &ldquo;flow&rdquo; of traffic
cannot make use of the services of more than one or two CPUs at either
end.  Whether one or two CPUs will be used processing a flow will
depend on the specifics of the stack(s) involved and whether or not
the global <samp><span class="option">-T</span></samp> option has been used to bind netperf/netserver
to specific CPUs.

   <p>When using concurrent tests there will be two concurrent connections
or flows, which means that upwards of four CPUs will be employed
processing the packets (global <samp><span class="option">-T</span></samp> used, no more than two if
not), however, with just a single, bidirectional request/response test
no more than two CPUs will be employed (only one if the global
<samp><span class="option">-T</span></samp> is not used).

   <p>If there is a CPU bottleneck on either system this may result in
rather different results between the two methods.

   <p>Also, with a bidirectional request/response test there is something of
a natural balance or synchronization between inbound and outbound - a
response will not be sent until a request is received, and (once the
burst level is reached) a subsequent request will not be sent until a
response is received.  This may mask favoritism in the NIC between
inbound and outbound processing.

   <p>With two concurrent unidirectional tests there is no such
synchronization or balance and any favoritism in the NIC may be exposed.

<div class="node">
<a name="The-Omni-Tests"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Other-Netperf-Tests">Other Netperf Tests</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Using-Netperf-to-Measure-Bidirectional-Transfer">Using Netperf to Measure Bidirectional Transfer</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">9 The Omni Tests</h2>

<p>Beginning with version 2.5.0, netperf begins a migration to the
&lsquo;<samp><span class="samp">omni</span></samp>&rsquo; tests or &ldquo;Two routines to measure them all.&rdquo;  The code for
the omni tests can be found in <samp><span class="file">src/nettest_omni.c</span></samp> and the goal
is to make it easier for netperf to support multiple protocols and
report a great many additional things about the systems under test. 
Additionally, a flexible output selection mechanism is present which
allows the user to chose specifically what values she wishes to have
reported and in what format.

   <p>The omni tests are included by default in version 2.5.0.  To disable
them, one must:
<pre class="example">     ./configure --enable-omni=no ...
</pre>
   <p>and remake netperf.  Remaking netserver is optional because even in
2.5.0 it has &ldquo;unmigrated&rdquo; netserver side routines for the classic
(eg <samp><span class="file">src/nettest_bsd.c</span></samp>) tests.

<ul class="menu">
<li><a accesskey="1" href="#Native-Omni-Tests">Native Omni Tests</a>
<li><a accesskey="2" href="#Migrated-Tests">Migrated Tests</a>
<li><a accesskey="3" href="#Omni-Output-Selection">Omni Output Selection</a>
</ul>

<div class="node">
<a name="Native-Omni-Tests"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Migrated-Tests">Migrated Tests</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#The-Omni-Tests">The Omni Tests</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#The-Omni-Tests">The Omni Tests</a>

</div>

<h3 class="section">9.1 Native Omni Tests</h3>

<p>One access the omni tests &ldquo;natively&rdquo; by using a value of &ldquo;OMNI&rdquo;
with the global <samp><span class="option">-t</span></samp> test-selection option.  This will then
cause netperf to use the code in <samp><span class="file">src/nettest_omni.c</span></samp> and in
particular the test-specific options parser for the omni tests.  The
test-specific options for the omni tests are a superset of those for
&ldquo;classic&rdquo; tests.  The options added by the omni tests are:

     
<a name="index-g_t_002dc_002c-Test_002dspecific-87"></a>
<dl><dt><code>-c</code><dd>This explicitly declares that the test is to include connection
establishment and tear-down as in either a TCP_CRR or TCP_CC test.

     <p><a name="index-g_t_002dd_002c-Test_002dspecific-88"></a><br><dt><code>-d &lt;direction&gt;</code><dd>This option sets the direction of the test relative to the netperf
process.  As of version 2.5.0 one can use the following in a
case-insensitive manner:

          <dl>
<dt><code>send, stream, transmit, xmit or 2</code><dd>Any of which will cause netperf to send to the netserver. 
<br><dt><code>recv, receive, maerts or 4</code><dd>Any of which will cause netserver to send to netperf. 
<br><dt><code>rr or 6</code><dd>Either of which will cause a request/response test. 
</dl>

     <p>Additionally, one can specify two directions separated by a '|'
character and they will be OR'ed together.  In this way one can use
the &rdquo;Send|Recv&rdquo; that will be emitted by the <a href="#Omni-Output-Selectors">DIRECTION</a> <a href="#Omni-Output-Selection">output selector</a> when
used with a request/response test.

     <p><a name="index-g_t_002dk_002c-Test_002dspecific-89"></a><br><dt><code>-k [<a href="#Omni-Output-Selection">output selector</a>]</code><dd>This option sets the style of output to &ldquo;keyval&rdquo; where each line of
output has the form:
     <pre class="example">          key=value
</pre>
     <p>For example:
     <pre class="example">          $ netperf -t omni -- -d rr -k "THROUGHPUT,THROUGHPUT_UNITS"
          OMNI TEST from 0.0.0.0 (0.0.0.0) port 0 AF_INET to localhost.localdomain (127.0.0.1) port 0 AF_INET : demo
          THROUGHPUT=59092.65
          THROUGHPUT_UNITS=Trans/s
</pre>
     <p>Using the <samp><span class="option">-k</span></samp> option will override any previous, test-specific
<samp><span class="option">-o</span></samp> or <samp><span class="option">-O</span></samp> option.

     <p><a name="index-g_t_002do_002c-Test_002dspecific-90"></a><br><dt><code>-o [<a href="#Omni-Output-Selection">output selector</a>]</code><dd>This option sets the style of output to &ldquo;CSV&rdquo; where there will be
one line of comma-separated values, preceded by one line of column
names unless the global <samp><span class="option">-P</span></samp> option is used with a value of 0:
     <pre class="example">          $ netperf -t omni -- -d rr -o "THROUGHPUT,THROUGHPUT_UNITS"
          OMNI TEST from 0.0.0.0 (0.0.0.0) port 0 AF_INET to localhost.localdomain (127.0.0.1) port 0 AF_INET : demo
          Throughput,Throughput Units
          60999.07,Trans/s
</pre>
     <p>Using the <samp><span class="option">-o</span></samp> option will override any previous, test-specific
<samp><span class="option">-k</span></samp> or <samp><span class="option">-O</span></samp> option.

     <p><a name="index-g_t_002dO_002c-Test_002dspecific-91"></a><br><dt><code>-O [<a href="#Omni-Output-Selection">output selector</a>]</code><dd>This option sets the style of output to &ldquo;human readable&rdquo; which will
look quite similar to classic netperf output:
     <pre class="example">          $ netperf -t omni -- -d rr -O "THROUGHPUT,THROUGHPUT_UNITS"
          OMNI TEST from 0.0.0.0 (0.0.0.0) port 0 AF_INET to localhost.localdomain (127.0.0.1) port 0 AF_INET : demo
          Throughput Throughput
                     Units
          
          
          60492.57   Trans/s
</pre>
     <p>Using the <samp><span class="option">-O</span></samp> option will override any previous, test-specific
<samp><span class="option">-k</span></samp> or <samp><span class="option">-o</span></samp> option.

     <p><a name="index-g_t_002dt_002c-Test_002dspecific-92"></a><br><dt><code>-t</code><dd>This option explicitly sets the socket type for the test's data
connection. As of version 2.5.0 the known socket types include
&ldquo;stream&rdquo; and &ldquo;dgram&rdquo; for SOCK_STREAM and SOCK_DGRAM respectively.

     <p><a name="index-g_t_002dT_002c-Test_002dspecific-93"></a><br><dt><code>-T &lt;protocol&gt;</code><dd>This option is used to explicitly set the protocol used for the
test. It is case-insensitive. As of version 2.5.0 the protocols known
to netperf include:
          <dl>
<dt><code>TCP</code><dd>Select the Transmission Control Protocol
<br><dt><code>UDP</code><dd>Select the User Datagram Protocol
<br><dt><code>SDP</code><dd>Select the Sockets Direct Protocol
<br><dt><code>DCCP</code><dd>Select the Datagram Congestion Control Protocol
<br><dt><code>SCTP</code><dd>Select the Stream Control Transport Protocol
<br><dt><code>udplite</code><dd>Select UDP Lite
</dl>

     <p>The default is implicit based on other settings. 
</dl>

   <p>The omni tests also extend the interpretation of some of the classic,
test-specific options for the BSD Sockets tests:

     <dl>
<dt><code>-m &lt;optionspec&gt;</code><dd>This can set the send size for either or both of the netperf and
netserver sides of the test:
     <pre class="example">          -m 32K
</pre>
     <p>sets only the netperf-side send size to 32768 bytes, and or's-in
transmit for the direction. This is effectively the same behaviour as
for the classic tests.
     <pre class="example">          -m ,32K
</pre>
     <p>sets only the netserver side send size to 32768 bytes and or's-in
receive for the direction.
     <pre class="example">          -m 16K,32K
          sets the netperf side send size to 16284 bytes, the netserver side
          send size to 32768 bytes and the direction will be "Send|Recv."
</pre>
     <br><dt><code>-M &lt;optionspec&gt;</code><dd>This can set the receive size for either or both of the netperf and
netserver sides of the test:
     <pre class="example">          -M 32K
</pre>
     <p>sets only the netserver side receive size to 32768 bytes and or's-in
send for the test direction.
     <pre class="example">          -M ,32K
</pre>
     <p>sets only the netperf side receive size to 32768 bytes and or's-in
receive for the test direction.
     <pre class="example">          -M 16K,32K
</pre>
     <p>sets the netserver side receive size to 16384 bytes and the netperf
side receive size to 32768 bytes and the direction will be "Send|Recv." 
</dl>

<div class="node">
<a name="Migrated-Tests"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Omni-Output-Selection">Omni Output Selection</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Native-Omni-Tests">Native Omni Tests</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#The-Omni-Tests">The Omni Tests</a>

</div>

<h3 class="section">9.2 Migrated Tests</h3>

<p>As of version 2.5.0 several tests have been migrated to use the omni
code in <samp><span class="file">src/nettest_omni.c</span></samp> for the core of their testing.  A
migrated test retains all its previous output code and so should still
&ldquo;look and feel&rdquo; just like a pre-2.5.0 test with one exception - the
first line of the test banners will include the word &ldquo;MIGRATED&rdquo; at
the beginning as in:

<pre class="example">     $ netperf
     MIGRATED TCP STREAM TEST from 0.0.0.0 (0.0.0.0) port 0 AF_INET to localhost.localdomain (127.0.0.1) port 0 AF_INET : demo
     Recv   Send    Send
     Socket Socket  Message  Elapsed
     Size   Size    Size     Time     Throughput
     bytes  bytes   bytes    secs.    10^6bits/sec
     
      87380  16384  16384    10.00    27175.27
</pre>
   <p>The tests migrated in version 2.5.0 are:
     <ul>
<li>TCP_STREAM
<li>TCP_MAERTS
<li>TCP_RR
<li>TCP_CRR
<li>UDP_STREAM
<li>UDP_RR
</ul>

   <p>It is expected that future releases will have additional tests
migrated to use the &ldquo;omni&rdquo; functionality.

   <p>If one uses &ldquo;omni-specific&rdquo; test-specific options in conjunction
with a migrated test, instead of using the classic output code, the
new omni output code will be used. For example if one uses the
<samp><span class="option">-k</span></samp> test-specific option with a value of
&ldquo;MIN_LATENCY,MAX_LATENCY&rdquo; with a migrated TCP_RR test one will see:

<pre class="example">     $ netperf -t tcp_rr -- -k THROUGHPUT,THROUGHPUT_UNITS
     MIGRATED TCP REQUEST/RESPONSE TEST from 0.0.0.0 (0.0.0.0) port 0 AF_INET to localhost.localdomain (127.0.0.1) port 0 AF_INET : demo
     THROUGHPUT=60074.74
     THROUGHPUT_UNITS=Trans/s
</pre>
   <p>rather than:
<pre class="example">     $ netperf -t tcp_rr
     MIGRATED TCP REQUEST/RESPONSE TEST from 0.0.0.0 (0.0.0.0) port 0 AF_INET to localhost.localdomain (127.0.0.1) port 0 AF_INET : demo
     Local /Remote
     Socket Size   Request  Resp.   Elapsed  Trans.
     Send   Recv   Size     Size    Time     Rate
     bytes  Bytes  bytes    bytes   secs.    per sec
     
     16384  87380  1        1       10.00    59421.52
     16384  87380
</pre>
   <div class="node">
<a name="Omni-Output-Selection"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Migrated-Tests">Migrated Tests</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#The-Omni-Tests">The Omni Tests</a>

</div>

<h3 class="section">9.3 Omni Output Selection</h3>

<p>The omni test-specific <samp><span class="option">-k</span></samp>, <samp><span class="option">-o</span></samp> and <samp><span class="option">-O</span></samp>
options take an optional <code>output selector</code> by which the user can
configure what values are reported.  The output selector can take
several forms:

     <dl>
<dt><samp><span class="file">filename</span></samp><dd>The output selections will be read from the named file. Within the
file there can be up to four lines of comma-separated output
selectors. This controls how many multi-line blocks of output are emitted
when the <samp><span class="option">-O</span></samp> option is used.  This output, while not identical to
&ldquo;classic&rdquo; netperf output, is inspired by it.  Multiple lines have no
effect for <samp><span class="option">-k</span></samp> and <samp><span class="option">-o</span></samp> options.  Putting output
selections in a file can be useful when the list of selections is long. 
<br><dt><code>comma and/or semi-colon-separated list</code><dd>The output selections will be parsed from a comma and/or
semi-colon-separated list of output selectors. When the list is given
to a <samp><span class="option">-O</span></samp> option a semi-colon specifies a new output block
should be started.  Semi-colons have the same meaning as commas when
used with the <samp><span class="option">-k</span></samp> or <samp><span class="option">-o</span></samp> options.  Depending on the
command interpreter being used, the semi-colon may have to be escaped
somehow to keep it from being interpreted by the command interpreter. 
This can often be done by enclosing the entire list in quotes. 
<br><dt><code>all</code><dd>If the keyword <b>all</b> is specified it means that all known output
values should be displayed at the end of the test.  This can be a
great deal of output.  As of version 2.5.0 there are 157 different
output selectors. 
<br><dt><code>?</code><dd>If a &ldquo;?&rdquo; is given as the output selection, the list of all known
output selectors will be displayed and no test actually run.  When
passed to the <samp><span class="option">-O</span></samp> option they will be listed one per
line. Otherwise they will be listed as a comma-separated list.  It may
be necessary to protect the &ldquo;?&rdquo; from the command interpreter by
escaping it or enclosing it in quotes. 
<br><dt><code>no selector</code><dd>If nothing is given to the <samp><span class="option">-k</span></samp>, <samp><span class="option">-o</span></samp> or <samp><span class="option">-O</span></samp>
option then the code selects a default set of output selectors
inspired by classic netperf output. The format will be the &lsquo;<samp><span class="samp">human
readable</span></samp>&rsquo; format emitted by the test-specific <samp><span class="option">-O</span></samp> option. 
</dl>

   <p>The order of evaluation will first check for an output selection.  If
none is specified with the <samp><span class="option">-k</span></samp>, <samp><span class="option">-o</span></samp> or <samp><span class="option">-O</span></samp>
option netperf will select a default based on the characteristics of the
test.  If there is an output selection, the code will first check for
&lsquo;<samp><span class="samp">?</span></samp>&rsquo;, then check to see if it is the magic &lsquo;<samp><span class="samp">all</span></samp>&rsquo; keyword. 
After that it will check for either &lsquo;<samp><span class="samp">,</span></samp>&rsquo; or &lsquo;<samp><span class="samp">;</span></samp>&rsquo; in the
selection and take that to mean it is a comma and/or
semi-colon-separated list. If none of those checks match, netperf will then
assume the output specification is a filename and attempt to open and
parse the file.

<ul class="menu">
<li><a accesskey="1" href="#Omni-Output-Selectors">Omni Output Selectors</a>
</ul>

<div class="node">
<a name="Omni-Output-Selectors"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Omni-Output-Selection">Omni Output Selection</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Omni-Output-Selection">Omni Output Selection</a>

</div>

<h4 class="subsection">9.3.1 Omni Output Selectors</h4>

<p>As of version 2.5.0 the output selectors are:

     <dl>
<dt><code>OUTPUT_NONE</code><dd>This is essentially a null output.  For <samp><span class="option">-k</span></samp> output it will
simply add a line that reads &ldquo;OUTPUT_NONE=&rdquo; to the output. For
<samp><span class="option">-o</span></samp> it will cause an empty &ldquo;column&rdquo; to be included. For
<samp><span class="option">-O</span></samp> output it will cause extra spaces to separate &ldquo;real&rdquo; output. 
<br><dt><code>SOCKET_TYPE</code><dd>This will cause the socket type (eg SOCK_STREAM, SOCK_DGRAM) for the
data connection to be output. 
<br><dt><code>PROTOCOL</code><dd>This will cause the protocol used for the data connection to be displayed. 
<br><dt><code>DIRECTION</code><dd>This will display the data flow direction relative to the netperf
process. Units: Send or Recv for a unidirectional bulk-transfer test,
or Send|Recv for a request/response test. 
<br><dt><code>ELAPSED_TIME</code><dd>This will display the elapsed time in seconds for the test. 
<br><dt><code>THROUGHPUT</code><dd>This will display the throughput for the test. Units: As requested via
the global <samp><span class="option">-f</span></samp> option and displayed by the THROUGHPUT_UNITS
output selector. 
<br><dt><code>THROUGHPUT_UNITS</code><dd>This will display the units for what is displayed by the
<code>THROUGHPUT</code> output selector. 
<br><dt><code>LSS_SIZE_REQ</code><dd>This will display the local (netperf) send socket buffer size (aka
SO_SNDBUF) requested via the command line. Units: Bytes. 
<br><dt><code>LSS_SIZE</code><dd>This will display the local (netperf) send socket buffer size
(SO_SNDBUF) immediately after the data connection socket was created. 
Peculiarities of different networking stacks may lead to this
differing from the size requested via the command line. Units: Bytes. 
<br><dt><code>LSS_SIZE_END</code><dd>This will display the local (netperf) send socket buffer size
(SO_SNDBUF) immediately before the data connection socket is closed. 
Peculiarities of different networking stacks may lead this to differ
from the size requested via the command line and/or the size
immediately after the data connection socket was created. Units: Bytes. 
<br><dt><code>LSR_SIZE_REQ</code><dd>This will display the local (netperf) receive socket buffer size (aka
SO_RCVBUF) requested via the command line. Units: Bytes. 
<br><dt><code>LSR_SIZE</code><dd>This will display the local (netperf) receive socket buffer size
(SO_RCVBUF) immediately after the data connection socket was created. 
Peculiarities of different networking stacks may lead to this
differing from the size requested via the command line. Units: Bytes. 
<br><dt><code>LSR_SIZE_END</code><dd>This will display the local (netperf) receive socket buffer size
(SO_RCVBUF) immediately before the data connection socket is closed. 
Peculiarities of different networking stacks may lead this to differ
from the size requested via the command line and/or the size
immediately after the data connection socket was created. Units: Bytes. 
<br><dt><code>RSS_SIZE_REQ</code><dd>This will display the remote (netserver) send socket buffer size (aka
SO_SNDBUF) requested via the command line. Units: Bytes. 
<br><dt><code>RSS_SIZE</code><dd>This will display the remote (netserver) send socket buffer size
(SO_SNDBUF) immediately after the data connection socket was created. 
Peculiarities of different networking stacks may lead to this
differing from the size requested via the command line. Units: Bytes. 
<br><dt><code>RSS_SIZE_END</code><dd>This will display the remote (netserver) send socket buffer size
(SO_SNDBUF) immediately before the data connection socket is closed. 
Peculiarities of different networking stacks may lead this to differ
from the size requested via the command line and/or the size
immediately after the data connection socket was created. Units: Bytes. 
<br><dt><code>RSR_SIZE_REQ</code><dd>This will display the remote (netserver) receive socket buffer size (aka
SO_RCVBUF) requested via the command line. Units: Bytes. 
<br><dt><code>RSR_SIZE</code><dd>This will display the remote (netserver) receive socket buffer size
(SO_RCVBUF) immediately after the data connection socket was created. 
Peculiarities of different networking stacks may lead to this
differing from the size requested via the command line. Units: Bytes. 
<br><dt><code>RSR_SIZE_END</code><dd>This will display the remote (netserver) receive socket buffer size
(SO_RCVBUF) immediately before the data connection socket is closed. 
Peculiarities of different networking stacks may lead this to differ
from the size requested via the command line and/or the size
immediately after the data connection socket was created. Units: Bytes. 
<br><dt><code>LOCAL_SEND_SIZE</code><dd>This will display the size of the buffers netperf passed in any
&ldquo;send&rdquo; calls it made on the data connection for a
non-request/response test. Units: Bytes. 
<br><dt><code>LOCAL_RECV_SIZE</code><dd>This will display the size of the buffers netperf passed in any
&ldquo;receive&rdquo; calls it made on the data connection for a
non-request/response test. Units: Bytes. 
<br><dt><code>REMOTE_SEND_SIZE</code><dd>This will display the size of the buffers netserver passed in any
&ldquo;send&rdquo; calls it made on the data connection for a
non-request/response test. Units: Bytes. 
<br><dt><code>REMOTE_RECV_SIZE</code><dd>This will display the size of the buffers netserver passed in any
&ldquo;receive&rdquo; calls it made on the data connection for a
non-request/response test. Units: Bytes. 
<br><dt><code>REQUEST_SIZE</code><dd>This will display the size of the requests netperf sent in a
request-response test. Units: Bytes. 
<br><dt><code>RESPONSE_SIZE</code><dd>This will display the size of the responses netserver sent in a
request-response test. Units: Bytes. 
<br><dt><code>LOCAL_CPU_UTIL</code><dd>This will display the overall CPU utilization during the test as
measured by netperf. Units: 0 to 100 percent. 
<br><dt><code>LOCAL_CPU_METHOD</code><dd>This will display the method used by netperf to measure CPU
utilization. Units: single character denoting method. 
<br><dt><code>LOCAL_SD</code><dd>This will display the service demand, or units of CPU consumed per
unit of work, as measured by netperf. Units: microseconds of CPU
consumed per either KB (K==1024) of data transferred or request/response
transaction. 
<br><dt><code>REMOTE_CPU_UTIL</code><dd>This will display the overall CPU utilization during the test as
measured by netserver. Units 0 to 100 percent. 
<br><dt><code>REMOTE_CPU_METHOD</code><dd>This will display the method used by netserver to measure CPU
utilization. Units: single character denoting method. 
<br><dt><code>REMOTE_SD</code><dd>This will display the service demand, or units of CPU consumed per
unit of work, as measured by netserver. Units: microseconds of CPU
consumed per either KB (K==1024) of data transferred or
request/response transaction. 
<br><dt><code>SD_UNITS</code><dd>This will display the units for LOCAL_SD and REMOTE_SD
<br><dt><code>CONFIDENCE_LEVEL</code><dd>This will display the confidence level requested by the user either
explicitly via the global <samp><span class="option">-I</span></samp> option, or implicitly via the
global <samp><span class="option">-i</span></samp> option.  The value will be either 95 or 99 if
confidence intervals have been requested or 0 if they were not. Units:
Percent
<br><dt><code>CONFIDENCE_INTERVAL</code><dd>This will display the width of the confidence interval requested
either explicitly via the global <samp><span class="option">-I</span></samp> option or implicitly via
the global <samp><span class="option">-i</span></samp> option.  Units: Width in percent of mean value
computed. A value of -1.0 means that confidence intervals were not requested. 
<br><dt><code>CONFIDENCE_ITERATION</code><dd>This will display the number of test iterations netperf undertook,
perhaps while attempting to achieve the requested confidence interval
and level. If confidence intervals were requested via the command line
then the value will be between 3 and 30.  If confidence intervals were
not requested the value will be 1.  Units: Iterations
<br><dt><code>THROUGHPUT_CONFID</code><dd>This will display the width of the confidence interval actually
achieved for <code>THROUGHPUT</code> during the test.  Units: Width of
interval as percentage of reported throughput value. 
<br><dt><code>LOCAL_CPU_CONFID</code><dd>This will display the width of the confidence interval actually
achieved for overall CPU utilization on the system running netperf
(<code>LOCAL_CPU_UTIL</code>) during the test, if CPU utilization measurement
was enabled.  Units: Width of interval as percentage of reported CPU
utilization. 
<br><dt><code>REMOTE_CPU_CONFID</code><dd>This will display the width of the confidence interval actually
achieved for overall CPU utilization on the system running netserver
(<code>REMOTE_CPU_UTIL</code>) during the test, if CPU utilization
measurement was enabled. Units: Width of interval as percentage of
reported CPU utilization. 
<br><dt><code>TRANSACTION_RATE</code><dd>This will display the transaction rate in transactions per second for
a request/response test even if the user has requested a throughput in
units of bits or bytes per second via the global <samp><span class="option">-f</span></samp>
option. It is undefined for a non-request/response test. Units:
Transactions per second. 
<br><dt><code>RT_LATENCY</code><dd>This will display the average round-trip latency for a
request/response test, accounting for number of transactions in flight
at one time. It is undefined for a non-request/response test. Units:
Microseconds per transaction
<br><dt><code>BURST_SIZE</code><dd>This will display the &ldquo;burst size&rdquo; or added transactions in flight
in a request/response test as requested via a test-specific
<samp><span class="option">-b</span></samp> option.  The number of transactions in flight at one time
will be one greater than this value.  It is undefined for a
non-request/response test. Units: added Transactions in flight. 
<br><dt><code>LOCAL_TRANSPORT_RETRANS</code><dd>This will display the number of retransmissions experienced on the
data connection during the test as determined by netperf.  A value of
-1 means the attempt to determine the number of retransmissions failed
or the concept was not valid for the given protocol or the mechanism
is not known for the platform. A value of -2 means it was not
attempted. As of version 2.5.0 the meaning of values are in flux and
subject to change.  Units: number of retransmissions. 
<br><dt><code>REMOTE_TRANSPORT_RETRANS</code><dd>This will display the number of retransmissions experienced on the
data connection during the test as determined by netserver.  A value
of -1 means the attempt to determine the number of retransmissions
failed or the concept was not valid for the given protocol or the
mechanism is not known for the platform. A value of -2 means it was
not attempted. As of version 2.5.0 the meaning of values are in flux
and subject to change.  Units: number of retransmissions. 
<br><dt><code>TRANSPORT_MSS</code><dd>This will display the Maximum Segment Size (aka MSS) or its equivalent
for the protocol being used during the test.  A value of -1 means
either the concept of an MSS did not apply to the protocol being used,
or there was an error in retrieving it. Units: Bytes. 
<br><dt><code>LOCAL_SEND_THROUGHPUT</code><dd>The throughput as measured by netperf for the successful &ldquo;send&rdquo;
calls it made on the data connection. Units: as requested via the
global <samp><span class="option">-f</span></samp> option and displayed via the <code>THROUGHPUT_UNITS</code>
output selector. 
<br><dt><code>LOCAL_RECV_THROUGHPUT</code><dd>The throughput as measured by netperf for the successful &ldquo;receive&rdquo;
calls it made on the data connection. Units: as requested via the
global <samp><span class="option">-f</span></samp> option and displayed via the <code>THROUGHPUT_UNITS</code>
output selector. 
<br><dt><code>REMOTE_SEND_THROUGHPUT</code><dd>The throughput as measured by netserver for the successful &ldquo;send&rdquo;
calls it made on the data connection. Units: as requested via the
global <samp><span class="option">-f</span></samp> option and displayed via the <code>THROUGHPUT_UNITS</code>
output selector. 
<br><dt><code>REMOTE_RECV_THROUGHPUT</code><dd>The throughput as measured by netserver for the successful &ldquo;receive&rdquo;
calls it made on the data connection. Units: as requested via the
global <samp><span class="option">-f</span></samp> option and displayed via the <code>THROUGHPUT_UNITS</code>
output selector. 
<br><dt><code>LOCAL_CPU_BIND</code><dd>The CPU to which netperf was bound, if at all, during the test. A
value of -1 means that netperf was not explicitly bound to a CPU
during the test. Units: CPU ID
<br><dt><code>LOCAL_CPU_COUNT</code><dd>The number of CPUs (cores, threads) detected by netperf. Units: CPU count. 
<br><dt><code>LOCAL_CPU_PEAK_UTIL</code><dd>The utilization of the CPU most heavily utilized during the test, as
measured by netperf. This can be used to see if any one CPU of a
multi-CPU system was saturated even though the overall CPU utilization
as reported by <code>LOCAL_CPU_UTIL</code> was low. Units: 0 to 100%
<br><dt><code>LOCAL_CPU_PEAK_ID</code><dd>The id of the CPU most heavily utilized during the test as determined
by netperf. Units: CPU ID. 
<br><dt><code>LOCAL_CPU_MODEL</code><dd>Model information for the processor(s) present on the system running
netperf. Assumes all processors in the system (as perceived by
netperf) on which netperf is running are the same model. Units: Text
<br><dt><code>LOCAL_CPU_FREQUENCY</code><dd>The frequency of the processor(s) on the system running netperf, at
the time netperf made the call.  Assumes that all processors present
in the system running netperf are running at the same
frequency. Units: MHz
<br><dt><code>REMOTE_CPU_BIND</code><dd>The CPU to which netserver was bound, if at all, during the test. A
value of -1 means that netperf was not explicitly bound to a CPU
during the test. Units: CPU ID
<br><dt><code>REMOTE_CPU_COUNT</code><dd>The number of CPUs (cores, threads) detected by netserver. Units: CPU
count. 
<br><dt><code>REMOTE_CPU_PEAK_UTIL</code><dd>The utilization of the CPU most heavily utilized during the test, as
measured by netserver. This can be used to see if any one CPU of a
multi-CPU system was saturated even though the overall CPU utilization
as reported by <code>REMOTE_CPU_UTIL</code> was low. Units: 0 to 100%
<br><dt><code>REMOTE_CPU_PEAK_ID</code><dd>The id of the CPU most heavily utilized during the test as determined
by netserver. Units: CPU ID. 
<br><dt><code>REMOTE_CPU_MODEL</code><dd>Model information for the processor(s) present on the system running
netserver. Assumes all processors in the system (as perceived by
netserver) on which netserver is running are the same model. Units:
Text
<br><dt><code>REMOTE_CPU_FREQUENCY</code><dd>The frequency of the processor(s) on the system running netserver, at
the time netserver made the call.  Assumes that all processors present
in the system running netserver are running at the same
frequency. Units: MHz
<br><dt><code>SOURCE_PORT</code><dd>The port ID/service name to which the data socket created by netperf
was bound.  A value of 0 means the data socket was not explicitly
bound to a port number. Units: ASCII text. 
<br><dt><code>SOURCE_ADDR</code><dd>The name/address to which the data socket created by netperf was
bound. A value of 0.0.0.0 means the data socket was not explicitly
bound to an address. Units: ASCII text. 
<br><dt><code>SOURCE_FAMILY</code><dd>The address family to which the data socket created by netperf was
bound.  A value of 0 means the data socket was not explicitly bound to
a given address family. Units: ASCII text. 
<br><dt><code>DEST_PORT</code><dd>The port ID to which the data socket created by netserver was bound. A
value of 0 means the data socket was not explicitly bound to a port
number.  Units: ASCII text. 
<br><dt><code>DEST_ADDR</code><dd>The name/address of the data socket created by netserver.  Units:
ASCII text. 
<br><dt><code>DEST_FAMILY</code><dd>The address family to which the data socket created by netserver was
bound. A value of 0 means the data socket was not explicitly bound to
a given address family. Units: ASCII text. 
<br><dt><code>LOCAL_SEND_CALLS</code><dd>The number of successful &ldquo;send&rdquo; calls made by netperf against its
data socket. Units: Calls. 
<br><dt><code>LOCAL_RECV_CALLS</code><dd>The number of successful &ldquo;receive&rdquo; calls made by netperf against its
data socket. Units: Calls. 
<br><dt><code>LOCAL_BYTES_PER_RECV</code><dd>The average number of bytes per &ldquo;receive&rdquo; call made by netperf
against its data socket. Units: Bytes. 
<br><dt><code>LOCAL_BYTES_PER_SEND</code><dd>The average number of bytes per &ldquo;send&rdquo; call made by netperf against
its data socket. Units: Bytes. 
<br><dt><code>LOCAL_BYTES_SENT</code><dd>The number of bytes successfully sent by netperf through its data
socket. Units: Bytes. 
<br><dt><code>LOCAL_BYTES_RECVD</code><dd>The number of bytes successfully received by netperf through its data
socket. Units: Bytes. 
<br><dt><code>LOCAL_BYTES_XFERD</code><dd>The sum of bytes sent and received by netperf through its data
socket. Units: Bytes. 
<br><dt><code>LOCAL_SEND_OFFSET</code><dd>The offset from the alignment of the buffers passed by netperf in its
&ldquo;send&rdquo; calls. Specified via the global <samp><span class="option">-o</span></samp> option and
defaults to 0. Units: Bytes. 
<br><dt><code>LOCAL_RECV_OFFSET</code><dd>The offset from the alignment of the buffers passed by netperf in its
&ldquo;receive&rdquo; calls. Specified via the global <samp><span class="option">-o</span></samp> option and
defaults to 0. Units: Bytes. 
<br><dt><code>LOCAL_SEND_ALIGN</code><dd>The alignment of the buffers passed by netperf in its &ldquo;send&rdquo; calls
as specified via the global <samp><span class="option">-a</span></samp> option. Defaults to 8. Units:
Bytes. 
<br><dt><code>LOCAL_RECV_ALIGN</code><dd>The alignment of the buffers passed by netperf in its &ldquo;receive&rdquo;
calls as specified via the global <samp><span class="option">-a</span></samp> option. Defaults to
8. Units: Bytes. 
<br><dt><code>LOCAL_SEND_WIDTH</code><dd>The &ldquo;width&rdquo; of the ring of buffers through which netperf cycles as
it makes its &ldquo;send&rdquo; calls.  Defaults to one more than the local send
socket buffer size divided by the send size as determined at the time
the data socket is created. Can be used to make netperf more processor
data cache unfriendly. Units: number of buffers. 
<br><dt><code>LOCAL_RECV_WIDTH</code><dd>The &ldquo;width&rdquo; of the ring of buffers through which netperf cycles as
it makes its &ldquo;receive&rdquo; calls.  Defaults to one more than the local
receive socket buffer size divided by the receive size as determined
at the time the data socket is created. Can be used to make netperf
more processor data cache unfriendly. Units: number of buffers. 
<br><dt><code>LOCAL_SEND_DIRTY_COUNT</code><dd>The number of bytes to &ldquo;dirty&rdquo; (write to) before netperf makes a
&ldquo;send&rdquo; call. Specified via the global <samp><span class="option">-k</span></samp> option, which
requires that &ndash;enable-dirty=yes was specified with the configure
command prior to building netperf. Units: Bytes. 
<br><dt><code>LOCAL_RECV_DIRTY_COUNT</code><dd>The number of bytes to &ldquo;dirty&rdquo; (write to) before netperf makes a
&ldquo;recv&rdquo; call. Specified via the global <samp><span class="option">-k</span></samp> option which
requires that &ndash;enable-dirty was specified with the configure command
prior to building netperf. Units: Bytes. 
<br><dt><code>LOCAL_RECV_CLEAN_COUNT</code><dd>The number of bytes netperf should read &ldquo;cleanly&rdquo; before making a
&ldquo;receive&rdquo; call. Specified via the global <samp><span class="option">-k</span></samp> option which
requires that &ndash;enable-dirty was specified with configure command
prior to building netperf.  Clean reads start were dirty writes ended. 
Units: Bytes. 
<br><dt><code>LOCAL_NODELAY</code><dd>Indicates whether or not setting the test protocol-specific &ldquo;no
delay&rdquo; (eg TCP_NODELAY) option on the data socket used by netperf was
requested by the test-specific <samp><span class="option">-D</span></samp> option and
successful. Units: 0 means no, 1 means yes. 
<br><dt><code>LOCAL_CORK</code><dd>Indicates whether or not TCP_CORK was set on the data socket used by
netperf as requested via the test-specific <samp><span class="option">-C</span></samp> option. 1 means
yes, 0 means no/not applicable. 
<br><dt><code>REMOTE_SEND_CALLS</code><br><dt><code>REMOTE_RECV_CALLS</code><br><dt><code>REMOTE_BYTES_PER_RECV</code><br><dt><code>REMOTE_BYTES_PER_SEND</code><br><dt><code>REMOTE_BYTES_SENT</code><br><dt><code>REMOTE_BYTES_RECVD</code><br><dt><code>REMOTE_BYTES_XFERD</code><br><dt><code>REMOTE_SEND_OFFSET</code><br><dt><code>REMOTE_RECV_OFFSET</code><br><dt><code>REMOTE_SEND_ALIGN</code><br><dt><code>REMOTE_RECV_ALIGN</code><br><dt><code>REMOTE_SEND_WIDTH</code><br><dt><code>REMOTE_RECV_WIDTH</code><br><dt><code>REMOTE_SEND_DIRTY_COUNT</code><br><dt><code>REMOTE_RECV_DIRTY_COUNT</code><br><dt><code>REMOTE_RECV_CLEAN_COUNT</code><br><dt><code>REMOTE_NODELAY</code><br><dt><code>REMOTE_CORK</code><dd>These are all like their &ldquo;LOCAL_&rdquo; counterparts only for the
netserver rather than netperf. 
<br><dt><code>LOCAL_SYSNAME</code><dd>The name of the OS (eg &ldquo;Linux&rdquo;) running on the system on which
netperf was running. Units: ASCII Text
<br><dt><code>LOCAL_SYSTEM_MODEL</code><dd>The model name of the system on which netperf was running. Units:
ASCII Text. 
<br><dt><code>LOCAL_RELEASE</code><dd>The release name/number of the OS running on the system on which
netperf  was running. Units: ASCII Text
<br><dt><code>LOCAL_VERSION</code><dd>The version number of the OS running on the system on which netperf
was running. Units: ASCII Text
<br><dt><code>LOCAL_MACHINE</code><dd>The machine architecture of the machine on which netperf was
running. Units: ASCII Text. 
<br><dt><code>REMOTE_SYSNAME</code><br><dt><code>REMOTE_SYSTEM_MODEL</code><br><dt><code>REMOTE_RELEASE</code><br><dt><code>REMOTE_VERSION</code><br><dt><code>REMOTE_MACHINE</code><dd>These are all like their &ldquo;LOCAL_&rdquo; counterparts only for the
netserver rather than netperf. 
<br><dt><code>LOCAL_INTERFACE_NAME</code><dd>The name of the probable egress interface through which the data
connection went on the system running netperf. Example: eth0. Units:
ASCII Text. 
<br><dt><code>LOCAL_INTERFACE_VENDOR</code><dd>The vendor ID of the probable egress interface through which traffic
on the data connection went on the system running netperf. Units:
Hexadecimal IDs as might be found in a <samp><span class="file">pci.ids</span></samp> file or at
<a href="http://pciids.sourceforge.net/">the PCI ID Repository</a>. 
<br><dt><code>LOCAL_INTERFACE_DEVICE</code><dd>The device ID of the probable egress interface through which traffic
on the data connection went on the system running netperf. Units:
Hexadecimal IDs as might be found in a <samp><span class="file">pci.ids</span></samp> file or at
<a href="http://pciids.sourceforge.net/">the PCI ID Repository</a>. 
<br><dt><code>LOCAL_INTERFACE_SUBVENDOR</code><dd>The sub-vendor ID of the probable egress interface through which
traffic on the data connection went on the system running
netperf. Units: Hexadecimal IDs as might be found in a <samp><span class="file">pci.ids</span></samp>
file or at <a href="http://pciids.sourceforge.net/">the PCI ID Repository</a>. 
<br><dt><code>LOCAL_INTERFACE_SUBDEVICE</code><dd>The sub-device ID of the probable egress interface through which
traffic on the data connection went on the system running
netperf. Units: Hexadecimal IDs as might be found in a <samp><span class="file">pci.ids</span></samp>
file or at <a href="http://pciids.sourceforge.net/">the PCI ID Repository</a>. 
<br><dt><code>LOCAL_DRIVER_NAME</code><dd>The name of the driver used for the probable egress interface through
which traffic on the data connection went on the system running
netperf. Units: ASCII Text. 
<br><dt><code>LOCAL_DRIVER_VERSION</code><dd>The version string for the driver used for the probable egress
interface through which traffic on the data connection went on the
system running netperf. Units: ASCII Text. 
<br><dt><code>LOCAL_DRIVER_FIRMWARE</code><dd>The firmware version for the driver used for the probable egress
interface through which traffic on the data connection went on the
system running netperf. Units: ASCII Text. 
<br><dt><code>LOCAL_DRIVER_BUS</code><dd>The bus address of the probable egress interface through which traffic
on the data connection went on the system running netperf. Units:
ASCII Text. 
<br><dt><code>LOCAL_INTERFACE_SLOT</code><dd>The slot ID of the probable egress interface through which traffic
on the data connection went on the system running netperf. Units:
ASCII Text. 
<br><dt><code>REMOTE_INTERFACE_NAME</code><br><dt><code>REMOTE_INTERFACE_VENDOR</code><br><dt><code>REMOTE_INTERFACE_DEVICE</code><br><dt><code>REMOTE_INTERFACE_SUBVENDOR</code><br><dt><code>REMOTE_INTERFACE_SUBDEVICE</code><br><dt><code>REMOTE_DRIVER_NAME</code><br><dt><code>REMOTE_DRIVER_VERSION</code><br><dt><code>REMOTE_DRIVER_FIRMWARE</code><br><dt><code>REMOTE_DRIVER_BUS</code><br><dt><code>REMOTE_INTERFACE_SLOT</code><dd>These are all like their &ldquo;LOCAL_&rdquo; counterparts only for the
netserver rather than netperf. 
<br><dt><code>LOCAL_INTERVAL_USECS</code><dd>The interval at which bursts of operations (sends, receives,
transactions) were attempted by netperf.  Specified by the
global <samp><span class="option">-w</span></samp> option which requires &ndash;enable-intervals to have
been specified with the configure command prior to building
netperf. Units: Microseconds (though specified by default in
milliseconds on the command line)
<br><dt><code>LOCAL_INTERVAL_BURST</code><dd>The number of operations (sends, receives, transactions depending on
the test) which were attempted by netperf each LOCAL_INTERVAL_USECS
units of time. Specified by the global <samp><span class="option">-b</span></samp> option which
requires &ndash;enable-intervals to have been specified with the configure
command prior to building netperf.  Units: number of operations per burst. 
<br><dt><code>REMOTE_INTERVAL_USECS</code><dd>The interval at which bursts of operations (sends, receives,
transactions) were attempted by netserver.  Specified by the
global <samp><span class="option">-w</span></samp> option which requires &ndash;enable-intervals to have
been specified with the configure command prior to building
netperf. Units: Microseconds (though specified by default in
milliseconds on the command line)
<br><dt><code>REMOTE_INTERVAL_BURST</code><dd>The number of operations (sends, receives, transactions depending on
the test) which were attempted by netperf each LOCAL_INTERVAL_USECS
units of time. Specified by the global <samp><span class="option">-b</span></samp> option which
requires &ndash;enable-intervals to have been specified with the configure
command prior to building netperf.  Units: number of operations per burst. 
<br><dt><code>LOCAL_SECURITY_TYPE_ID</code><br><dt><code>LOCAL_SECURITY_TYPE</code><br><dt><code>LOCAL_SECURITY_ENABLED_NUM</code><br><dt><code>LOCAL_SECURITY_ENABLED</code><br><dt><code>LOCAL_SECURITY_SPECIFIC</code><br><dt><code>REMOTE_SECURITY_TYPE_ID</code><br><dt><code>REMOTE_SECURITY_TYPE</code><br><dt><code>REMOTE_SECURITY_ENABLED_NUM</code><br><dt><code>REMOTE_SECURITY_ENABLED</code><br><dt><code>REMOTE_SECURITY_SPECIFIC</code><dd>A bunch of stuff related to what sort of security mechanisms (eg
SELINUX) were enabled on the systems during the test. 
<br><dt><code>RESULT_BRAND</code><dd>The string specified by the user with the global <samp><span class="option">-B</span></samp>
option. Units: ASCII Text. 
<br><dt><code>UUID</code><dd>The universally unique identifier associated with this test, either
generated automagically by netperf, or passed to netperf via an omni
test-specific <samp><span class="option">-u</span></samp> option. Note: Future versions may make this
a global command-line option. Units: ASCII Text. 
<br><dt><code>MIN_LATENCY</code><dd>The minimum &ldquo;latency&rdquo; or operation time (send, receive or
request/response exchange depending on the test) as measured on the
netperf side when the global <samp><span class="option">-j</span></samp> option was specified. Units:
Microseconds. 
<br><dt><code>MAX_LATENCY</code><dd>The maximum &ldquo;latency&rdquo; or operation time (send, receive or
request/response exchange depending on the test) as measured on the
netperf side when the global <samp><span class="option">-j</span></samp> option was specified. Units:
Microseconds. 
<br><dt><code>P50_LATENCY</code><dd>The 50th percentile value of &ldquo;latency&rdquo; or operation time (send, receive or
request/response exchange depending on the test) as measured on the
netperf side when the global <samp><span class="option">-j</span></samp> option was specified. Units:
Microseconds. 
<br><dt><code>P90_LATENCY</code><dd>The 90th percentile value of &ldquo;latency&rdquo; or operation time (send, receive or
request/response exchange depending on the test) as measured on the
netperf side when the global <samp><span class="option">-j</span></samp> option was specified. Units:
Microseconds. 
<br><dt><code>P99_LATENCY</code><dd>The 99th percentile value of &ldquo;latency&rdquo; or operation time (send, receive or
request/response exchange depending on the test) as measured on the
netperf side when the global <samp><span class="option">-j</span></samp> option was specified. Units:
Microseconds. 
<br><dt><code>MEAN_LATENCY</code><dd>The average &ldquo;latency&rdquo; or operation time (send, receive or
request/response exchange depending on the test) as measured on the
netperf side when the global <samp><span class="option">-j</span></samp> option was specified. Units:
Microseconds. 
<br><dt><code>STDDEV_LATENCY</code><dd>The standard deviation of &ldquo;latency&rdquo; or operation time (send, receive or
request/response exchange depending on the test) as measured on the
netperf side when the global <samp><span class="option">-j</span></samp> option was specified. Units:
Microseconds. 
<br><dt><code>COMMAND_LINE</code><dd>The full command line used when invoking netperf. Units: ASCII Text. 
<br><dt><code>OUTPUT_END</code><dd>While emitted with the list of output selectors, it is ignored when
specified as an output selector. 
</dl>

<div class="node">
<a name="Other-Netperf-Tests"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Address-Resolution">Address Resolution</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#The-Omni-Tests">The Omni Tests</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">10 Other Netperf Tests</h2>

<p>Apart from the typical performance tests, netperf contains some tests
which can be used to streamline measurements and reporting.  These
include CPU rate calibration (present) and host identification (future
enhancement).

<ul class="menu">
<li><a accesskey="1" href="#CPU-rate-calibration">CPU rate calibration</a>
<li><a accesskey="2" href="#UUID-Generation">UUID Generation</a>
</ul>

<div class="node">
<a name="CPU-rate-calibration"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#UUID-Generation">UUID Generation</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Other-Netperf-Tests">Other Netperf Tests</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Other-Netperf-Tests">Other Netperf Tests</a>

</div>

<h3 class="section">10.1 CPU rate calibration</h3>

<p>Some of the CPU utilization measurement mechanisms of netperf work by
comparing the rate at which some counter increments when the system is
idle with the rate at which that same counter increments when the
system is running a netperf test.  The ratio of those rates is used to
arrive at a CPU utilization percentage.

   <p>This means that netperf must know the rate at which the counter
increments when the system is presumed to be &ldquo;idle.&rdquo;  If it does not
know the rate, netperf will measure it before starting a data transfer
test.  This calibration step takes 40 seconds for each of the local or
remote systems, and if repeated for each netperf test would make taking
repeated measurements rather slow.

   <p>Thus, the netperf CPU utilization options <samp><span class="option">-c</span></samp> and and
<samp><span class="option">-C</span></samp> can take an optional calibration value.  This value is
used as the &ldquo;idle rate&rdquo; and the calibration step is not
performed. To determine the idle rate, netperf can be used to run
special tests which only report the value of the calibration - they
are the LOC_CPU and REM_CPU tests.  These return the calibration value
for the local and remote system respectively.  A common way to use
these tests is to store their results into an environment variable and
use that in subsequent netperf commands:

<pre class="example">     LOC_RATE=`netperf -t LOC_CPU`
     REM_RATE=`netperf -H &lt;remote&gt; -t REM_CPU`
     netperf -H &lt;remote&gt; -c $LOC_RATE -C $REM_RATE ... -- ...
     ...
     netperf -H &lt;remote&gt; -c $LOC_RATE -C $REM_RATE ... -- ...
</pre>
   <p>If you are going to use netperf to measure aggregate results, it is
important to use the LOC_CPU and REM_CPU tests to get the calibration
values first to avoid issues with some of the aggregate netperf tests
transferring data while others are &ldquo;idle&rdquo; and getting bogus
calibration values.  When running aggregate tests, it is very
important to remember that any one instance of netperf does not know
about the other instances of netperf.  It will report global CPU
utilization and will calculate service demand believing it was the
only thing causing that CPU utilization.  So, you can use the CPU
utilization reported by netperf in an aggregate test, but you have to
calculate service demands by hand.

<div class="node">
<a name="UUID-Generation"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#CPU-rate-calibration">CPU rate calibration</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Other-Netperf-Tests">Other Netperf Tests</a>

</div>

<h3 class="section">10.2 UUID Generation</h3>

<p>Beginning with version 2.5.0 netperf can generate Universally Unique
IDentifiers (UUIDs).  This can be done explicitly via the &ldquo;UUID&rdquo;
test:
<pre class="example">     $ netperf -t UUID
     2c8561ae-9ebd-11e0-a297-0f5bfa0349d0
</pre>
   <p>In and of itself, this is not terribly useful, but used in conjunction
with the test-specific <samp><span class="option">-u</span></samp> option of an &ldquo;omni&rdquo; test to set
the UUID emitted by the <a href="#Omni-Output-Selectors">UUID</a> output
selector, it can be used to tie-together the separate instances of an
aggregate netperf test.  Say, for instance if they were inserted into
a database of some sort.

<div class="node">
<a name="Address-Resolution"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Enhancing-Netperf">Enhancing Netperf</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Other-Netperf-Tests">Other Netperf Tests</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<!-- node-name,  next,  previous,  up -->
<h2 class="chapter">11 Address Resolution</h2>

<p>Netperf versions 2.4.0 and later have merged IPv4 and IPv6 tests so
the functionality of the tests in <samp><span class="file">src/nettest_ipv6.c</span></samp> has been
subsumed into the tests in <samp><span class="file">src/nettest_bsd.c</span></samp>  This has been
accomplished in part by switching from <code>gethostbyname()</code>to
<code>getaddrinfo()</code> exclusively.  While it was theoretically possible
to get multiple results for a hostname from <code>gethostbyname()</code> it
was generally unlikely and netperf's ignoring of the second and later
results was not much of an issue.

   <p>Now with <code>getaddrinfo</code> and particularly with AF_UNSPEC it is
increasingly likely that a given hostname will have multiple
associated addresses.  The <code>establish_control()</code> routine of
<samp><span class="file">src/netlib.c</span></samp> will indeed attempt to chose from among all the
matching IP addresses when establishing the control connection. 
Netperf does not _really_ care if the control connection is IPv4 or
IPv6 or even mixed on either end.

   <p>However, the individual tests still ass-u-me that the first result in
the address list is the one to be used.  Whether or not this will
turn-out to be an issue has yet to be determined.

   <p>If you do run into problems with this, the easiest workaround is to
specify IP addresses for the data connection explicitly in the
test-specific <samp><span class="option">-H</span></samp> and <samp><span class="option">-L</span></samp> options.  At some point, the
netperf tests _may_ try to be more sophisticated in their parsing of
returns from <code>getaddrinfo()</code> - straw-man patches to
<a href="mailto:netperf-feedback@netperf.org">netperf-feedback@netperf.org</a> would of course be most welcome
:)

   <p>Netperf has leveraged code from other open-source projects with
amenable licensing to provide a replacement <code>getaddrinfo()</code> call
on those platforms where the <samp><span class="command">configure</span></samp> script believes there
is no native getaddrinfo call.  As of this writing, the replacement
<code>getaddrinfo()</code> as been tested on HP-UX 11.0 and then presumed to
run elsewhere.

<div class="node">
<a name="Enhancing-Netperf"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Netperf4">Netperf4</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Address-Resolution">Address Resolution</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<!-- node-name,  next,  previous,  up -->
<h2 class="chapter">12 Enhancing Netperf</h2>

<p>Netperf is constantly evolving.  If you find you want to make
enhancements to netperf, by all means do so.  If you wish to add a new
&ldquo;suite&rdquo; of tests to netperf the general idea is to:

     <ol type=1 start=1>
<li>Add files <samp><span class="file">src/nettest_mumble.c</span></samp> and <samp><span class="file">src/nettest_mumble.h</span></samp>
where mumble is replaced with something meaningful for the test-suite. 
<li>Add support for an appropriate <samp><span class="option">--enable-mumble</span></samp> option in
<samp><span class="file">configure.ac</span></samp>. 
<li>Edit <samp><span class="file">src/netperf.c</span></samp>, <samp><span class="file">netsh.c</span></samp>, and <samp><span class="file">netserver.c</span></samp> as
required, using #ifdef WANT_MUMBLE. 
<li>Compile and test
        </ol>

   <p>However, with the addition of the &ldquo;omni&rdquo; tests in version 2.5.0 it
is preferred that one attempt to make the necessary changes to
<samp><span class="file">src/nettest_omni.c</span></samp> rather than adding new source files, unless
this would make the omni tests entirely too complicated.

   <p>If you wish to submit your changes for possible inclusion into the
mainline sources, please try to base your changes on the latest
available sources. (See <a href="#Getting-Netperf-Bits">Getting Netperf Bits</a>.) and then send email
describing the changes at a high level to
<a href="mailto:netperf-feedback@netperf.org">netperf-feedback@netperf.org</a> or perhaps
<a href="mailto:netperf-talk@netperf.org">netperf-talk@netperf.org</a>.  If the consensus is positive, then
sending context <samp><span class="command">diff</span></samp> results to
<a href="mailto:netperf-feedback@netperf.org">netperf-feedback@netperf.org</a> is the next step.  From that
point, it is a matter of pestering the Netperf Contributing Editor
until he gets the changes incorporated :)

<div class="node">
<a name="Netperf4"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Concept-Index">Concept Index</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Enhancing-Netperf">Enhancing Netperf</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<!-- node-name,  next,  previous,  up -->
<h2 class="chapter">13 Netperf4</h2>

<p>Netperf4 is the shorthand name given to version 4.X.X of netperf. 
This is really a separate benchmark more than a newer version of
netperf, but it is a descendant of netperf so the netperf name is
kept.  The facetious way to describe netperf4 is to say it is the
egg-laying-woolly-milk-pig version of netperf :)  The more respectful
way to describe it is to say it is the version of netperf with support
for synchronized, multiple-thread, multiple-test, multiple-system,
network-oriented benchmarking.

   <p>Netperf4 is still undergoing evolution. Those wishing to work with or
on netperf4 are encouraged to join the
<a href="http://www.netperf.org/cgi-bin/mailman/listinfo/netperf-dev">netperf-dev</a>
mailing list and/or peruse the
<a href="http://www.netperf.org/svn/netperf4/trunk">current sources</a>.

<div class="node">
<a name="Concept-Index"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Option-Index">Option Index</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Netperf4">Netperf4</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="unnumbered">Concept Index</h2>

<ul class="index-cp" compact>
<li><a href="#index-Aggregate-Performance-85">Aggregate Performance</a>: <a href="#Using-Netperf-to-Measure-Aggregate-Performance">Using Netperf to Measure Aggregate Performance</a></li>
<li><a href="#index-Bandwidth-Limitation-10">Bandwidth Limitation</a>: <a href="#Installing-Netperf-Bits">Installing Netperf Bits</a></li>
<li><a href="#index-Connection-Latency-69">Connection Latency</a>: <a href="#TCP_005fCC">TCP_CC</a></li>
<li><a href="#index-CPU-Utilization-14">CPU Utilization</a>: <a href="#CPU-Utilization">CPU Utilization</a></li>
<li><a href="#index-Design-of-Netperf-13">Design of Netperf</a>: <a href="#The-Design-of-Netperf">The Design of Netperf</a></li>
<li><a href="#index-Installation-2">Installation</a>: <a href="#Installing-Netperf">Installing Netperf</a></li>
<li><a href="#index-Introduction-1">Introduction</a>: <a href="#Introduction">Introduction</a></li>
<li><a href="#index-Latency_002c-Connection-Establishment-79">Latency, Connection Establishment</a>: <a href="#XTI_005fTCP_005fCRR">XTI_TCP_CRR</a></li>
<li><a href="#index-Latency_002c-Connection-Establishment-78">Latency, Connection Establishment</a>: <a href="#XTI_005fTCP_005fCC">XTI_TCP_CC</a></li>
<li><a href="#index-Latency_002c-Connection-Establishment-73">Latency, Connection Establishment</a>: <a href="#TCP_005fCRR">TCP_CRR</a></li>
<li><a href="#index-Latency_002c-Connection-Establishment-70">Latency, Connection Establishment</a>: <a href="#TCP_005fCC">TCP_CC</a></li>
<li><a href="#index-Latency_002c-Request_002dResponse-84">Latency, Request-Response</a>: <a href="#SCTP_005fRR">SCTP_RR</a></li>
<li><a href="#index-Latency_002c-Request_002dResponse-83">Latency, Request-Response</a>: <a href="#DLCO_005fRR">DLCO_RR</a></li>
<li><a href="#index-Latency_002c-Request_002dResponse-82">Latency, Request-Response</a>: <a href="#DLCL_005fRR">DLCL_RR</a></li>
<li><a href="#index-Latency_002c-Request_002dResponse-81">Latency, Request-Response</a>: <a href="#XTI_005fUDP_005fRR">XTI_UDP_RR</a></li>
<li><a href="#index-Latency_002c-Request_002dResponse-80">Latency, Request-Response</a>: <a href="#XTI_005fTCP_005fCRR">XTI_TCP_CRR</a></li>
<li><a href="#index-Latency_002c-Request_002dResponse-77">Latency, Request-Response</a>: <a href="#XTI_005fTCP_005fRR">XTI_TCP_RR</a></li>
<li><a href="#index-Latency_002c-Request_002dResponse-75">Latency, Request-Response</a>: <a href="#UDP_005fRR">UDP_RR</a></li>
<li><a href="#index-Latency_002c-Request_002dResponse-74">Latency, Request-Response</a>: <a href="#TCP_005fCRR">TCP_CRR</a></li>
<li><a href="#index-Latency_002c-Request_002dResponse-68">Latency, Request-Response</a>: <a href="#TCP_005fRR">TCP_RR</a></li>
<li><a href="#index-Limiting-Bandwidth-57">Limiting Bandwidth</a>: <a href="#UDP_005fSTREAM">UDP_STREAM</a></li>
<li><a href="#index-Limiting-Bandwidth-9">Limiting Bandwidth</a>: <a href="#Installing-Netperf-Bits">Installing Netperf Bits</a></li>
<li><a href="#index-Measuring-Latency-67">Measuring Latency</a>: <a href="#TCP_005fRR">TCP_RR</a></li>
<li><a href="#index-Packet-Loss-76">Packet Loss</a>: <a href="#UDP_005fRR">UDP_RR</a></li>
<li><a href="#index-Port-Reuse-71">Port Reuse</a>: <a href="#TCP_005fCC">TCP_CC</a></li>
<li><a href="#index-TIME_005fWAIT-72">TIME_WAIT</a>: <a href="#TCP_005fCC">TCP_CC</a></li>
   </ul><div class="node">
<a name="Option-Index"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Concept-Index">Concept Index</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<!-- node-name,  next,  previous,  up -->
<h2 class="unnumbered">Option Index</h2>



<ul class="index-vr" compact>
<li><a href="#index-g_t_002d_002denable_002dburst_002c-Configure-86"><code>--enable-burst, Configure</code></a>: <a href="#Using-Netperf-to-Measure-Aggregate-Performance">Using Netperf to Measure Aggregate Performance</a></li>
<li><a href="#index-g_t_002d_002denable_002dcpuutil_002c-Configure-3"><code>--enable-cpuutil, Configure</code></a>: <a href="#Installing-Netperf-Bits">Installing Netperf Bits</a></li>
<li><a href="#index-g_t_002d_002denable_002ddlpi_002c-Configure-6"><code>--enable-dlpi, Configure</code></a>: <a href="#Installing-Netperf-Bits">Installing Netperf Bits</a></li>
<li><a href="#index-g_t_002d_002denable_002dhistogram_002c-Configure-12"><code>--enable-histogram, Configure</code></a>: <a href="#Installing-Netperf-Bits">Installing Netperf Bits</a></li>
<li><a href="#index-g_t_002d_002denable_002dintervals_002c-Configure-11"><code>--enable-intervals, Configure</code></a>: <a href="#Installing-Netperf-Bits">Installing Netperf Bits</a></li>
<li><a href="#index-g_t_002d_002denable_002domni_002c-Configure-8"><code>--enable-omni, Configure</code></a>: <a href="#Installing-Netperf-Bits">Installing Netperf Bits</a></li>
<li><a href="#index-g_t_002d_002denable_002dsctp_002c-Configure-7"><code>--enable-sctp, Configure</code></a>: <a href="#Installing-Netperf-Bits">Installing Netperf Bits</a></li>
<li><a href="#index-g_t_002d_002denable_002dunixdomain_002c-Configure-5"><code>--enable-unixdomain, Configure</code></a>: <a href="#Installing-Netperf-Bits">Installing Netperf Bits</a></li>
<li><a href="#index-g_t_002d_002denable_002dxti_002c-Configure-4"><code>--enable-xti, Configure</code></a>: <a href="#Installing-Netperf-Bits">Installing Netperf Bits</a></li>
<li><a href="#index-g_t_002d4_002c-Global-46"><code>-4, Global</code></a>: <a href="#Global-Options">Global Options</a></li>
<li><a href="#index-g_t_002d4_002c-Test_002dspecific-65"><code>-4, Test-specific</code></a>: <a href="#Options-Common-to-TCP-UDP-and-SCTP-_005fRR-tests">Options Common to TCP UDP and SCTP _RR tests</a></li>
<li><a href="#index-g_t_002d4_002c-Test_002dspecific-55"><code>-4, Test-specific</code></a>: <a href="#Options-common-to-TCP-UDP-and-SCTP-tests">Options common to TCP UDP and SCTP tests</a></li>
<li><a href="#index-g_t_002d6-Test_002dspecific-66"><code>-6 Test-specific</code></a>: <a href="#Options-Common-to-TCP-UDP-and-SCTP-_005fRR-tests">Options Common to TCP UDP and SCTP _RR tests</a></li>
<li><a href="#index-g_t_002d6_002c-Global-47"><code>-6, Global</code></a>: <a href="#Global-Options">Global Options</a></li>
<li><a href="#index-g_t_002d6_002c-Test_002dspecific-56"><code>-6, Test-specific</code></a>: <a href="#Options-common-to-TCP-UDP-and-SCTP-tests">Options common to TCP UDP and SCTP tests</a></li>
<li><a href="#index-g_t_002dA_002c-Global-16"><code>-A, Global</code></a>: <a href="#Global-Options">Global Options</a></li>
<li><a href="#index-g_t_002da_002c-Global-15"><code>-a, Global</code></a>: <a href="#Global-Options">Global Options</a></li>
<li><a href="#index-g_t_002dB_002c-Global-18"><code>-B, Global</code></a>: <a href="#Global-Options">Global Options</a></li>
<li><a href="#index-g_t_002db_002c-Global-17"><code>-b, Global</code></a>: <a href="#Global-Options">Global Options</a></li>
<li><a href="#index-g_t_002dC_002c-Global-20"><code>-C, Global</code></a>: <a href="#Global-Options">Global Options</a></li>
<li><a href="#index-g_t_002dc_002c-Global-19"><code>-c, Global</code></a>: <a href="#Global-Options">Global Options</a></li>
<li><a href="#index-g_t_002dc_002c-Test_002dspecific-87"><code>-c, Test-specific</code></a>: <a href="#Native-Omni-Tests">Native Omni Tests</a></li>
<li><a href="#index-g_t_002dD_002c-Global-22"><code>-D, Global</code></a>: <a href="#Global-Options">Global Options</a></li>
<li><a href="#index-g_t_002dd_002c-Global-21"><code>-d, Global</code></a>: <a href="#Global-Options">Global Options</a></li>
<li><a href="#index-g_t_002dd_002c-Test_002dspecific-88"><code>-d, Test-specific</code></a>: <a href="#Native-Omni-Tests">Native Omni Tests</a></li>
<li><a href="#index-g_t_002dF_002c-Global-24"><code>-F, Global</code></a>: <a href="#Global-Options">Global Options</a></li>
<li><a href="#index-g_t_002df_002c-Global-23"><code>-f, Global</code></a>: <a href="#Global-Options">Global Options</a></li>
<li><a href="#index-g_t_002dH_002c-Global-26"><code>-H, Global</code></a>: <a href="#Global-Options">Global Options</a></li>
<li><a href="#index-g_t_002dh_002c-Global-25"><code>-h, Global</code></a>: <a href="#Global-Options">Global Options</a></li>
<li><a href="#index-g_t_002dH_002c-Test_002dspecific-59"><code>-H, Test-specific</code></a>: <a href="#Options-Common-to-TCP-UDP-and-SCTP-_005fRR-tests">Options Common to TCP UDP and SCTP _RR tests</a></li>
<li><a href="#index-g_t_002dh_002c-Test_002dspecific-58"><code>-h, Test-specific</code></a>: <a href="#Options-Common-to-TCP-UDP-and-SCTP-_005fRR-tests">Options Common to TCP UDP and SCTP _RR tests</a></li>
<li><a href="#index-g_t_002dh_002c-Test_002dspecific-48"><code>-h, Test-specific</code></a>: <a href="#Options-common-to-TCP-UDP-and-SCTP-tests">Options common to TCP UDP and SCTP tests</a></li>
<li><a href="#index-g_t_002di_002c-Global-28"><code>-i, Global</code></a>: <a href="#Global-Options">Global Options</a></li>
<li><a href="#index-g_t_002dI_002c-Global-27"><code>-I, Global</code></a>: <a href="#Global-Options">Global Options</a></li>
<li><a href="#index-g_t_002dj_002c-Global-29"><code>-j, Global</code></a>: <a href="#Global-Options">Global Options</a></li>
<li><a href="#index-g_t_002dk_002c-Test_002dspecific-89"><code>-k, Test-specific</code></a>: <a href="#Native-Omni-Tests">Native Omni Tests</a></li>
<li><a href="#index-g_t_002dL_002c-Global-31"><code>-L, Global</code></a>: <a href="#Global-Options">Global Options</a></li>
<li><a href="#index-g_t_002dl_002c-Global-30"><code>-l, Global</code></a>: <a href="#Global-Options">Global Options</a></li>
<li><a href="#index-g_t_002dL_002c-Test_002dspecific-60"><code>-L, Test-specific</code></a>: <a href="#Options-Common-to-TCP-UDP-and-SCTP-_005fRR-tests">Options Common to TCP UDP and SCTP _RR tests</a></li>
<li><a href="#index-g_t_002dL_002c-Test_002dspecific-49"><code>-L, Test-specific</code></a>: <a href="#Options-common-to-TCP-UDP-and-SCTP-tests">Options common to TCP UDP and SCTP tests</a></li>
<li><a href="#index-g_t_002dM_002c-Test_002dspecific-51"><code>-M, Test-specific</code></a>: <a href="#Options-common-to-TCP-UDP-and-SCTP-tests">Options common to TCP UDP and SCTP tests</a></li>
<li><a href="#index-g_t_002dm_002c-Test_002dspecific-50"><code>-m, Test-specific</code></a>: <a href="#Options-common-to-TCP-UDP-and-SCTP-tests">Options common to TCP UDP and SCTP tests</a></li>
<li><a href="#index-g_t_002dN_002c-Global-33"><code>-N, Global</code></a>: <a href="#Global-Options">Global Options</a></li>
<li><a href="#index-g_t_002dn_002c-Global-32"><code>-n, Global</code></a>: <a href="#Global-Options">Global Options</a></li>
<li><a href="#index-g_t_002dO_002c-Global-35"><code>-O, Global</code></a>: <a href="#Global-Options">Global Options</a></li>
<li><a href="#index-g_t_002do_002c-Global-34"><code>-o, Global</code></a>: <a href="#Global-Options">Global Options</a></li>
<li><a href="#index-g_t_002dO_002c-Test_002dspecific-91"><code>-O, Test-specific</code></a>: <a href="#Native-Omni-Tests">Native Omni Tests</a></li>
<li><a href="#index-g_t_002do_002c-Test_002dspecific-90"><code>-o, Test-specific</code></a>: <a href="#Native-Omni-Tests">Native Omni Tests</a></li>
<li><a href="#index-g_t_002dP_002c-Global-37"><code>-P, Global</code></a>: <a href="#Global-Options">Global Options</a></li>
<li><a href="#index-g_t_002dp_002c-Global-36"><code>-p, Global</code></a>: <a href="#Global-Options">Global Options</a></li>
<li><a href="#index-g_t_002dP_002c-Test_002dspecific-61"><code>-P, Test-specific</code></a>: <a href="#Options-Common-to-TCP-UDP-and-SCTP-_005fRR-tests">Options Common to TCP UDP and SCTP _RR tests</a></li>
<li><a href="#index-g_t_002dP_002c-Test_002dspecific-52"><code>-P, Test-specific</code></a>: <a href="#Options-common-to-TCP-UDP-and-SCTP-tests">Options common to TCP UDP and SCTP tests</a></li>
<li><a href="#index-g_t_002dr_002c-Test_002dspecific-62"><code>-r, Test-specific</code></a>: <a href="#Options-Common-to-TCP-UDP-and-SCTP-_005fRR-tests">Options Common to TCP UDP and SCTP _RR tests</a></li>
<li><a href="#index-g_t_002dS-Test_002dspecific-54"><code>-S Test-specific</code></a>: <a href="#Options-common-to-TCP-UDP-and-SCTP-tests">Options common to TCP UDP and SCTP tests</a></li>
<li><a href="#index-g_t_002dS_002c-Global-39"><code>-S, Global</code></a>: <a href="#Global-Options">Global Options</a></li>
<li><a href="#index-g_t_002ds_002c-Global-38"><code>-s, Global</code></a>: <a href="#Global-Options">Global Options</a></li>
<li><a href="#index-g_t_002dS_002c-Test_002dspecific-64"><code>-S, Test-specific</code></a>: <a href="#Options-Common-to-TCP-UDP-and-SCTP-_005fRR-tests">Options Common to TCP UDP and SCTP _RR tests</a></li>
<li><a href="#index-g_t_002ds_002c-Test_002dspecific-63"><code>-s, Test-specific</code></a>: <a href="#Options-Common-to-TCP-UDP-and-SCTP-_005fRR-tests">Options Common to TCP UDP and SCTP _RR tests</a></li>
<li><a href="#index-g_t_002ds_002c-Test_002dspecific-53"><code>-s, Test-specific</code></a>: <a href="#Options-common-to-TCP-UDP-and-SCTP-tests">Options common to TCP UDP and SCTP tests</a></li>
<li><a href="#index-g_t_002dT_002c-Global-41"><code>-T, Global</code></a>: <a href="#Global-Options">Global Options</a></li>
<li><a href="#index-g_t_002dt_002c-Global-40"><code>-t, Global</code></a>: <a href="#Global-Options">Global Options</a></li>
<li><a href="#index-g_t_002dT_002c-Test_002dspecific-93"><code>-T, Test-specific</code></a>: <a href="#Native-Omni-Tests">Native Omni Tests</a></li>
<li><a href="#index-g_t_002dt_002c-Test_002dspecific-92"><code>-t, Test-specific</code></a>: <a href="#Native-Omni-Tests">Native Omni Tests</a></li>
<li><a href="#index-g_t_002dV_002c-Global-43"><code>-V, Global</code></a>: <a href="#Global-Options">Global Options</a></li>
<li><a href="#index-g_t_002dv_002c-Global-42"><code>-v, Global</code></a>: <a href="#Global-Options">Global Options</a></li>
<li><a href="#index-g_t_002dW_002c-Global-45"><code>-W, Global</code></a>: <a href="#Global-Options">Global Options</a></li>
<li><a href="#index-g_t_002dw_002c-Global-44"><code>-w, Global</code></a>: <a href="#Global-Options">Global Options</a></li>
   </ul></body></html>

