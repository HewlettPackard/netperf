<?xml version="1.0"?><!DOCTYPE texinfo PUBLIC "-//GNU//DTD TexinfoML V4.7//EN" "http://www.gnu.org/software/texinfo/dtd/4.7/texinfo.dtd">
<texinfo xml:lang="en">
  <setfilename>netperf.xml</setfilename>
  <settitle>Care and Feeding of Netperf 2.4.X</settitle>
<!-- %**end of header -->
  <para>This is Rick Jones' feeble attempt at a Texinfo-based manual for the netperf benchmark.</para>
  <para>Copyright &copyright; 2005 Hewlett-Packard Company</para>
  <quotation>
    <para>Permission is granted to copy, distribute and/or modify this document per the terms of the netperf source licence, a copy of which can be found in the file <file>COPYING</file> of the basic netperf distribution.</para>
  </quotation>
  <titlepage>
    <booktitle>Care and Feeding of Netperf</booktitle>
    <booksubtitle>Versions 2.4.0 and Later</booksubtitle>
    <author>Rick Jones &lt;email>&lt;emailaddress>rick.jones2@hp.com&lt;/emailaddress>&lt;/email></author>
<!-- this is here to start the copyright page -->
    <para>This is Rick Jones' feeble attempt at a Texinfo-based manual for the netperf benchmark.</para>
    <para>Copyright &copyright; 2005 Hewlett-Packard Company</para>
    <quotation>
      <para>Permission is granted to copy, distribute and/or modify this document per the terms of the netperf source licence, a copy of which can be found in the file <file>COPYING</file> of the basic netperf distribution.</para>
    </quotation>
  </titlepage>
<!-- begin with a table of contents -->
  <contents></contents>
  <node>
    <nodename>Top</nodename>
    <nodenext>Introduction</nodenext>
    <nodeprev>(dir)</nodeprev>
    <nodeup>(dir)</nodeup>
    <unnumbered>
      <title>Netperf Manual</title>
      <para>This is Rick Jones' feeble attempt at a Texinfo-based manual for the netperf benchmark.</para>
      <para>Copyright &copyright; 2005 Hewlett-Packard Company</para>
      <quotation>
        <para>Permission is granted to copy, distribute and/or modify this document per the terms of the netperf source licence, a copy of which can be found in the file <file>COPYING</file> of the basic netperf distribution.</para>
      </quotation>
      <menu>
        <menuentry>
          <menunode>Introduction</menunode>
          <menutitle>Introduction</menutitle>
          <menucomment>An introduction to netperf - what it is and whatit is not.</menucomment>
        </menuentry>
        <menuentry>
          <menunode>Installing Netperf</menunode>
          <menutitle>Installing Netperf</menutitle>
          <menucomment>How to go about installing netperf.</menucomment>
        </menuentry>
        <menuentry>
          <menunode>The Design of Netperf</menunode>
          <menutitle>The Design of Netperf</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Global Command-line Options</menunode>
          <menutitle>Global Command-line Options</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Using Netperf to Measure Bulk Data Transfer</menunode>
          <menutitle>Using Netperf to Measure Bulk Data Transfer</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Using Netperf to Measure Request/Response</menunode>
          <menutitle>Using Netperf to Measure Request/Response </menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Other Netperf Tests</menunode>
          <menutitle>Other Netperf Tests</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Address Resolution</menunode>
          <menutitle>Address Resolution</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Enhancing Netperf</menunode>
          <menutitle>Enhancing Netperf</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Index</menunode>
          <menutitle>Index</menutitle>
          <menucomment>Index for this manual.</menucomment>
        </menuentry>
      </menu>
    </unnumbered>
  </node>
  <node>
    <nodename>Introduction</nodename>
    <nodenext>Installing Netperf</nodenext>
    <nodeprev>Top</nodeprev>
    <nodeup>Top</nodeup>
    <chapter>
      <title>Introduction</title>
      <para><indexterm index="cp">chapter, Introduction</indexterm> Netperf is a benchmark that can be use to measure various aspect of networking performance.  The primary foci are bulk (aka unidirectional) data transfer and request/response performance using either TCP or UDP and the Berkeley Sockets interface.  As of this writing, the tests available either unconditionally or conditionally include:</para>
      <itemize>
        <itemfunction>&bullet;</itemfunction>
        <item>
          <para>TCP and UDP unidirectional transfer and request/response over IPv4 and IPv6 using the Sockets interface.</para>
        </item>
        <item>
          <para>TCP and UDP unidirectional transfer and request/response over IPv4 using the XTI interface.</para>
        </item>
        <item>
          <para>Link-level unidirectional transfer and request/response using the DLPI interface.</para>
        </item>
        <item>
          <para>Unix domain sockets</para>
        </item>
        <item>
          <para>SCTP unidirectional transfer and request/response over IPv4 and IPv6 using the sockets interface.</para>
        </item>
      </itemize>
      <para>While not every revision of netperf will work on every platform listed, the intention is that at least some version of netperf will work on the following platforms:</para>
      <itemize>
        <itemfunction>&bullet;</itemfunction>
        <item>
          <para>Unix - at least all the major variants.</para>
        </item>
        <item>
          <para>Linux</para>
        </item>
        <item>
          <para>Windows</para>
        </item>
        <item>
          <para>OpenVMS</para>
        </item>
        <item>
          <para>Others</para>
        </item>
      </itemize>
      <para>Netperf is maintained and informally supported primarily by Rick Jones, who can perhaps be best described as Netperf Contributing Editor.  Non-trivial and very appreciated assistance comes from others in the network performance community, who are too numerous to mention here. Netperf is NOT supported via any of the formal Hewlett-Packard support channels.  You should feel free to make enhancements and modifications to netperf to suit your nefarious porpoises, so long as you stay within the guidelines of the netperf copyright.  If you feel so inclined, you can send your changes to <email><emailaddress>netperf-feedback@netperf.org</emailaddress><emailname>netperf-feedback</emailname></email> for possible inclusion into subsequent versions of netperf.</para>
      <para>The <email><emailaddress>netperf-talk@netperf.org</emailaddress><emailname>netperf-talk</emailname></email> mailing list is available to discuss the care and feeding of netperf with others who share your interest in network performance benchmarking. The netperf-talk mailing list is a closed list and you must first subscribe by sending email to <email><emailaddress>netperf-talk-request@netperf.org</emailaddress><emailname>netperf-talk-request</emailname></email>.</para>
      <menu>
        <menuentry>
          <menunode>Conventions</menunode>
          <menutitle>Conventions</menutitle>
          <menucomment></menucomment>
        </menuentry>
      </menu>
    </chapter>
  </node>
  <node>
    <nodename>Conventions</nodename>
    <nodeprev>Introduction</nodeprev>
    <nodeup>Introduction</nodeup>
    <section>
      <title>Conventions</title>
      <para>A <dfn>sizespec</dfn> is a one or two item, comma-separated list used as an argument to a command-line option that can set one or two, related netperf parameters.  If you wish to set both parameters to separate values, items should be separated by a comma:</para>
      <example xml:space="preserve">parameter1,parameter2</example>
      <para>If you wish to set the first parameter without altering the value of the second from its default, you should follow the first item with a comma:</para>
      <example xml:space="preserve">parameter1,</example>
      <para>Likewise, precede the item with a comma if you wish to set only the second parameter:</para>
      <example xml:space="preserve">,parameter2</example>
      <para>An item with no commas:</para>
      <example xml:space="preserve">parameter1and2</example>
      <para>will set both parameters to the same value.  This last mode is one of the most frequently used.</para>
      <para>There is another variant of the comma-separated, two-item list called a <dfn>optionspec</dfn> which is like a sizespec with the exception that a single item with no comma:</para>
      <example xml:space="preserve">parameter1</example>
      <para>will only set the value of the first parameter and will leave the second parameter at its default value.</para>
      <para>Netperf has two types of command-line options.  The first are global command line options.  They are essentially any option not tied to a particular test or group of tests.  An example of a global command-line option is the one which sets the test type - <option>-t</option>.</para>
      <para>The second type of options are test-specific options.  These are options which are only applicable to a particular test or set of tests.  An example of a test-specific option would be the send socket buffer size for a TCP_STREAM test.</para>
      <para>Global command-line options are specified first with test-specific options following after a <code>--</code> as in:</para>
      <example xml:space="preserve">netperf &lt;global&gt; -- &lt;test-specific&gt;</example>
    </section>
  </node>
  <node>
    <nodename>Installing Netperf</nodename>
    <nodenext>The Design of Netperf</nodenext>
    <nodeprev>Introduction</nodeprev>
    <nodeup>Top</nodeup>
    <chapter>
      <title>Installing Netperf</title>
      <para><indexterm index="cp">chapter, Installing Netperf</indexterm> Netperf's primary form of distribution is source code.  This allows installation on systems other than those to which the authors have ready access and thus the ability to create binaries.  There are two styles of netperf installation.  The first runs the netperf server program - netserver - as a child of inetd.  This requires the installer to have sufficient privileges to edit the files <file>/etc/services</file> and <file>/etc/inetd.conf</file> or their platform-specific equivalents.</para>
      <para>The second style is to run netserver as a standalone daemon.  This second method does not require edit privileges on <file>/etc/services</file> and <file>/etc/inetd.conf</file> but does mean you must remember to run the netserver program explicitly after every system reboot.</para>
      <para>This manual assumes that those wishing to measure networking performance already know how to use anonymous FTP and/or a web browser. It is also expected that you have at least a passing familiarity with the networking protocols and interfaces involved. In all honesty, if you do not have such familiarity, likely as not you have some experience to gain before attempting network performance measurements.  The excellent texts by authors such as Stevens, Fenner and Rudoff and/or Stallings would be good starting points. There are likely other excellent sources out there as well.</para>
      <menu>
        <menuentry>
          <menunode>Getting Netperf Bits</menunode>
          <menutitle>Getting Netperf Bits</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Installing Netperf Bits</menunode>
          <menutitle>Installing Netperf Bits</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Verifying Installation</menunode>
          <menutitle>Verifying Installation</menutitle>
          <menucomment></menucomment>
        </menuentry>
      </menu>
    </chapter>
  </node>
  <node>
    <nodename>Getting Netperf Bits</nodename>
    <nodenext>Installing Netperf Bits</nodenext>
    <nodeprev>Installing Netperf</nodeprev>
    <nodeup>Installing Netperf</nodeup>
    <section>
      <title>Getting Netperf Bits</title>
      <para>Gzipped tar files of netperf sources can be retrieved via <uref><urefurl>ftp://ftp.cup.hp.com/dist/networking/benchmarks/netperf/</urefurl><urefdesc>anonymous FTP</urefdesc></uref> for &ldquo;released&rdquo; versions of the bits.  Pre-release versions of the bits can be retrieved via anonymous FTP from the <uref><urefurl>ftp://ftp.cup.hp.com/dist/networking/benchmarks/netperf/experimental/</urefurl><urefdesc>experimental</urefdesc></uref> subdirectory.</para>
      <para>For convenience and ease of remembering, a link to the download site is provided via the <uref><urefurl>http://www.netperf.org/</urefurl><urefdesc>NetperfPage</urefdesc></uref></para>
      <para>There are likely other places around the Internet from which one can download netperf bits.  These may be simple mirrors of the main netperf site, or they may be local variants on netperf.  As with anything one downloads from the Internet, take care to make sure it is what you really wanted and isn't some malicious Trojan or whatnot. Caveat downloader.</para>
      <para>As a general rule, binaries of netperf and netserver are not distributed from ftp.cup.hp.com.  From time to time a kind soul or souls has packaged netperf as a Debian package available via the apt-get mechanism.  I would be most interested in learning how to enhance the makefiles to make that easier for people, and perhaps to generate RPM's and HP-UX swinstall&ldquo;depots.&rdquo;</para>
    </section>
  </node>
  <node>
    <nodename>Installing Netperf Bits</nodename>
    <nodenext>Verifying Installation</nodenext>
    <nodeprev>Getting Netperf Bits</nodeprev>
    <nodeup>Installing Netperf</nodeup>
    <section>
      <title>Installing Netperf</title>
      <para>Once you have downloaded the tar file of netperf sources onto your system(s), it is necessary to unpack the tar file, cd to the netperf directory, run configure and then make.  Most of the time it should be sufficient to just:</para>
      <example xml:space="preserve">gzcat &lt;netperf-version&gt;.tar.gz | tar xf -
cd &lt;netperf-version&gt;
./configure
make
make install</example>
      <para>Most of the &ldquo;usual&rdquo; configure script options should be present dealing with where to install binaries and whatnot.</para>
      <example xml:space="preserve">./configure --help</example>
      <para>should list all of those and more.</para>
      <para>If the netperf configure script does not know how to automagically detect which CPU utilization mechanism to use on your platform you may want to add a <code>--enable-cpuutil=mumble</code> option to the configure command.   If you have knowledge and/or experience to contribute to that area, feel free to contact <email><emailaddress>netperf-feedback@netperf.org</emailaddress></email>.</para>
      <para>Similarly, if you want tests using the XTI interface, Unix Domain Sockets, DLPI or SCTP it will be necessary to add one or more <code>--enable-[xti|unix|dlpi|sctp]=yes</code> options to the configure command.  As of this writing, the configure script will not include those tests automagically.</para>
      <para>On some platforms, it may be necessary to precede the configure command with a CFLAGS and/or LIBS variable as the netperf configure script is not yet smart enough to set them itself.  Whenever possible, these requirements will be found in <file>README.<var>platform</var></file> files. Expertise and assistance in making that more automagical in the configure script would be most welcome.</para>
      <para>Other optional configure-time settings include <code>--enable-intervals=yes</code> to give netperf the ability to &ldquo;pace&rdquo; its _STREAM tests and <code>--enable-histogram=yes</code> to have netperf keep a histogram of interesting times.  Each of these will have some effect on the measured result.  If your system supports <code>gethrtime()</code> the effect of the histogram measurement should be minimized but probably still measurable.  For example, the histogram of a netperf TCP_RR test will be of the individual transaction times:</para>
      <example xml:space="preserve">netperf -t TCP_RR -H lag -v 2
TCP REQUEST/RESPONSE TEST from 0.0.0.0 (0.0.0.0) port 0 AF_INET to lag.hpl.hp.com (15.4.89.214) port 0 AF_INET : histogram
Local /Remote
Socket Size   Request  Resp.   Elapsed  Trans.
Send   Recv   Size     Size    Time     Rate
bytes  Bytes  bytes    bytes   secs.    per sec

16384  87380  1        1       10.00    3538.82
32768  32768
Alignment      Offset
Local  Remote  Local  Remote
Send   Recv    Send   Recv
    8      0       0      0
Histogram of request/response times
UNIT_USEC     :    0:    0:    0:    0:    0:    0:    0:    0:    0:    0
TEN_USEC      :    0:    0:    0:    0:    0:    0:    0:    0:    0:    0
HUNDRED_USEC  :    0: 34480:  111:   13:   12:    6:    9:    3:    4:    7
UNIT_MSEC     :    0:   60:   50:   51:   44:   44:   72:  119:  100:  101
TEN_MSEC      :    0:  105:    0:    0:    0:    0:    0:    0:    0:    0
HUNDRED_MSEC  :    0:    0:    0:    0:    0:    0:    0:    0:    0:    0
UNIT_SEC      :    0:    0:    0:    0:    0:    0:    0:    0:    0:    0
TEN_SEC       :    0:    0:    0:    0:    0:    0:    0:    0:    0:    0
&gt;100_SECS: 0
HIST_TOTAL:      35391</example>
      <para>Long-time users of netperf will notice the expansion of the main test header.  This stems from the merging-in of IPv6 with the standard IPv4 tests and the addition of code to specify addressing information for both sides of the data connection.</para>
      <para>The histogram you see above is basically a base-10 log histogram where we can see that most of the transaction times were on the order of one hundred to one-hundred, ninety-nine microseconds, but they were occasionally as long as ten to nineteen milliseconds</para>
      <para>The <option>--enable-demo=yes</option> configure option will cause code to be included to report interim results during a test run.  The rate at which interim results are reported can then be controlled via the global <option>-D</option> option.  Here is an example of &ndash;enable-demo mode output:</para>
      <example xml:space="preserve">src/netperf -D 1.35 -H lag -f M
TCP STREAM TEST from 0.0.0.0 (0.0.0.0) port 0 AF_INET to lag.hpl.hp.com (15.4.89.214) port 0 AF_INET : demo
Interim result:    9.66 MBytes/s over 1.67 seconds
Interim result:    9.64 MBytes/s over 1.35 seconds
Interim result:    9.58 MBytes/s over 1.36 seconds
Interim result:    9.51 MBytes/s over 1.36 seconds
Interim result:    9.71 MBytes/s over 1.35 seconds
Interim result:    9.66 MBytes/s over 1.36 seconds
Interim result:    9.61 MBytes/s over 1.36 seconds
Recv   Send    Send
Socket Socket  Message  Elapsed
Size   Size    Size     Time     Throughput
bytes  bytes   bytes    secs.    MBytes/sec

 32768  16384  16384    10.00       9.61</example>
      <para>Notice how the units of the interim result track that requested by the <option>-f</option> option.  Also notice that sometimes the interval will be longer than the value specified in the <option>-D</option> option.  This is normal and stems from how demo mode is implemented without relying on interval timers, but by calculating how many units of work must be performed to take at least the desired interval.</para>
      <para>As of this writing, a <code>make install</code> will not actually update the files <file>/etc/services</file> and/or <file>/etc/inetd.conf</file> or their platform-specific equivalents.  It remains necessary to perform that bit of installation magic by hand.  Patches to the makefile sources to effect an automagic editing of the necessary files to have netperf installed as a child of inetd would be most welcome.</para>
      <para>Starting the netserver as a standalone daemon should be as easy as:</para>
      <example xml:space="preserve">$ netserver
Starting netserver at port 12865
Starting netserver at hostname 0.0.0.0 port 12865 and family 0</example>
      <para>Over time the specifics of the messages netserver prints to the screen may change but the gist will remain the same.</para>
      <para>If the compilation of netperf or netserver happens to fail, feel free to contact <email><emailaddress>netperf-feedback@netperf.org</emailaddress></email> or join and ask in <email><emailaddress>netperf-talk@netperf.org</emailaddress></email>.  However, it is quite important that you include the actual compilation errors and perhaps even the configure log in your email.  Otherwise, it will be that much more difficult for someone to assist you.</para>
    </section>
  </node>
  <node>
    <nodename>Verifying Installation</nodename>
    <nodeprev>Installing Netperf Bits</nodeprev>
    <nodeup>Installing Netperf</nodeup>
    <section>
      <title>Verifying Installation</title>
      <para>Basically, once netperf is installed and netserver is configured as a child of inetd, or launched as a standalone daemon, simply typing:</para>
      <example xml:space="preserve">netperf</example>
      <para>should result in output similar to the following:</para>
      <example xml:space="preserve">$ netperf
TCP STREAM TEST from 0.0.0.0 (0.0.0.0) port 0 AF_INET to localhost.localdomain (127.0.0.1) port 0 AF_INET
Recv   Send    Send
Socket Socket  Message  Elapsed
Size   Size    Size     Time     Throughput
bytes  bytes   bytes    secs.    10^6bits/sec

 87380  16384  16384    10.00    2997.84</example>
    </section>
  </node>
  <node>
    <nodename>The Design of Netperf</nodename>
    <nodenext>Global Command-line Options</nodenext>
    <nodeprev>Installing Netperf</nodeprev>
    <nodeup>Top</nodeup>
    <chapter>
      <title>The Design of Netperf</title>
      <para><indexterm index="cp">chapter, The Design of Netperf</indexterm> Netperf is designed around a basic client-server model.  There are two executables - netperf and netserver.  Generally you will only execute the netperf program, with the netserver program being invoked by the remote system's inetd or equivalent. When you execute netperf, the first that that will happen is the establishment of a control connection to the remote system.  This connection will be used to pass test configuration information and results to and from the remote system.  Regardless of the type of test to be run, the control connection will be a TCP connection using BSD sockets.  The control connection can use either IPv4 or IPv6.</para>
      <para>Once the control connection is up and the configuration information has been passed, a separate &ldquo;data&rdquo; connection will be opened for the measurement itself using the API's and protocols appropriate for the specified test.  When the test is completed, the data connection will be torn-down and results from the netserver will be passed-back via the control connection and combined with netperf's result for display to the user.</para>
      <para>Netperf places no traffic on the control connection while a test is in progress.  Certain TCP options, such as SO_KEEPALIVE, if set as your systems' default, may put packets out on the control connection while a test is in progress.  Generally speaking this will have no effect on the results.</para>
      <menu>
        <menuentry>
          <menunode>CPU Utilization</menunode>
          <menutitle>CPU Utilization</menutitle>
          <menucomment></menucomment>
        </menuentry>
      </menu>
    </chapter>
  </node>
  <node>
    <nodename>CPU Utilization</nodename>
    <nodeprev>The Design of Netperf</nodeprev>
    <nodeup>The Design of Netperf</nodeup>
    <section>
      <title>CPU Utilization</title>
      <para>CPU utilization is an important, and alas all-too infrequently reported component of networking performance.  Unfortunately, it can be one of the most difficult metrics to measure accurately as many systems offer mechanisms that are at best il-suited to measuring CPU utilization in high interrupt rate (eg networking) situations.</para>
      <para>CPU utilization in netperf is reported as a value between 0 and 100% regardless of the number of CPUs involved.  In addition to CPU utilization, netperf will report a metric called a <dfn>service demand</dfn>.  The service demand is the normalization of CPU utilization and work performed.  For a _STREAM test it is the microseconds of CPU time consumed to transfer on KB (K == 1024) of data.  For a _RR test it is the microseconds of CPU time consumed processing a single transaction.   For both CPU utilization and service demand, lower is better.</para>
      <para>Service demand can be particularly useful when trying to gauge the effect of a performance change.  It is essentially a measure of efficiency, with smaller values being more efficient.</para>
      <para>Netperf is coded to be able to use one of several, generally platform-specific CPU utilization measurement mechanisms.  Single letter codes will be included in the CPU portion of the test banner to indicate which mechanism was used on each of the local (netperf) and remote (netserver) system.</para>
      <para>As of this writing those codes are:</para>
      <table>
        <tableitem>
          <tableterm><code>U</code></tableterm>
          <item>
            <para>The CPU utilization measurement mechanism was unknown to netperf or netperf/netserver was not compiled to include CPU utilization measurements. The code for the null CPU utilization mechanism can be found in <file>src/netcpu_none.c</file>.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>I</code></tableterm>
          <item>
            <para>An HP-UX-specific CPU utilization mechanism whereby the kernel incremented a per-CPU counter by one for each trip through the idle loop. This mechanism was only available on specially-compiled HP-UX kernels prior to HP-UX 10 and is mentioned here only for the sake of historical completeness and perhaps as a suggestion to those who might be altering other operating systems. While rather simple, perhaps even simplistic, this mechanism was quite robust and was not affected by the concerns of statistical methods, or methods attempting to track time in each of user, kernel, interrupt and idle modes which require quite careful accounting.  It can be thought-of as the in-kernel version of the looper <code>L</code> mechanism without the context switch overhead. This mechanism required calibration.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>P</code></tableterm>
          <item>
            <para>An HP-UX-specific CPU utilization mechanism whereby the kernel keeps-track of time (in the form of CPU cycles) spent in the kernel idle loop (HP-UX 10.0 to 11.23 inclusive), or where the kernel keeps track of time spent in idle, user, kernel and interrupt processing (HP-UX 11.23 and later).  The former requires calibration, the latter does not.  Values in either case are retrieved via one of the pstat(2) family of calls, hence the use of the letter <code>P</code>.  The code for these mechanisms is found in <file>src/netcpu_pstat.c</file> and <file>src/netcpu_pstatnew.c</file> respectively.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>K</code></tableterm>
          <item>
            <para>A Solaris-specific CPU utilization mechanism where by the kernel keeps track of ticks (eg HZ) spent in the idle loop.  This method is statistical and is known to be inaccurate when the interrupt rate is above epsilon as time spent processing interrupts is not subtracted from idle.  The value is retrieved via a kstat() call - hence the use of the letter <code>K</code>.  Since this mechanism uses units of ticks (HZ) the calibration value should invariably match HZ. (Eg 100)  The code for this mechanism is implemented in <file>src/netcpu_kstat.c</file>.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>M</code></tableterm>
          <item>
            <para>A Solaris-specific mechanism available on Solaris 10 and latter which uses the new microstate accounting mechanisms.  There are two, alas, overlapping, mechanisms.  The first tracks nanoseconds spent in user, kernel, and idle modes. The second mechanism tracks nanoseconds spent in interrupt.  Since the mechanisms overlap, netperf goes through some hand-waving to try to &ldquo;fix&rdquo; the problem.  Since the accuracy of the handwaving cannot be completely determined, one must presume that while better than the <code>K</code> mechanism, this mechanism too is not without issues.  The values are retrieved via kstat() calls, but the letter code is set to <code>M</code> to distinguish this mechanism from the even less accurate <code>K</code> mechanism.  The code for this mechanism is implemented in <file>src/netcpu_kstat10.c</file>.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>L</code></tableterm>
          <item>
            <para>A mechanism based on &ldquo;looper&rdquo;or &ldquo;soaker&rdquo; processes which sit in tight loops counting as fast as they possibly can. This mechanism starts a looper process for each known CPU on the system.  The effect of processor hyperthreading on the mechanism is not yet known.  This mechanism definitely requires calibration.  The code for the &ldquo;looper&rdquo;mechanism can be found in <file>src/netcpu_looper.c</file></para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>N</code></tableterm>
          <item>
            <para>A Microsoft Windows-specific mechanism, the code for which can be found in <file>src/netcpu_ntperf.c</file>.  This mechanism too is based on what appears to be a form of micro-state accounting and requires no calibration.  On laptops, or other systems which may dynamically alter the CPU frequency to minimize power consumtion, it has been suggested that this mechanism may become slightly confsed, in which case using BIOS settings to disable the power saving would be indicated.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>S</code></tableterm>
          <item>
            <para>This mechanism uses <file>/proc/stat</file> on Linux to retrieve time (ticks) spent in idle mode.  It is thought but not known to be reasonably accurate.  The code for this mechanism can be found in <file>src/netcpu_procstat.c</file>.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>C</code></tableterm>
          <item>
            <para>A mechanism somewhat similar to <code>S</code> but using the sysctl() call on BSD-like Operating systems (*BSD and MacOS X).  The code for this mechanism can be found in <file>src/netcpu_sysctl.c</file>.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>Others</code></tableterm>
          <item>
            <para>Other mechanisms included in netperf in the past have included using the times() and getrusage() calls.  These calls are actually rather poorly suited to the task of measuring CPU overhead for networking as they tend to be process-specific and much network-related  processing can happen outside the context of a process, in places where it is not a given it will be charged to the correct, or even a process.  They are mentioned here as a warning to anyone seeing those mechanisms used in other networking benchmarks.  These mechanisms are not available in netperf 2.4.0 and later.</para>
          </item>
        </tableitem>
      </table>
      <para>For many platforms, the configure script will chose the best available CPU utilization mechanism.  However, some platforms have no particularly good mechanisms.  On those platforms, it is probably best to use the &ldquo;LOOPER&rdquo; mechanism which is basically some number of processes (as many as there are processors) sitting in tight little loops counting as fast as they can.  The rate at which the loopers count when the system is believed to be idle is compared with the rate when the system is running netperf and the ratio is used to compute CPU utilization.</para>
      <para>In the past, netperf included some mechanisms that only reported CPU time charged to the calling process.  Those mechanisms have been removed from netperf versions 2.4.0 and later because they are hopelessly inaccurate.  Networking can and often results in CPU time being spent in places - such as interrupt contexts - that do not get charged to a or the correct process.</para>
      <para>In fact, time spent in the processing of interrupts is a common issue for many CPU utilization mechanisms.  In particular, the &ldquo;PSTAT&rdquo; mechanism was eventually known to have problems accounting for certain interrupt time prior to HP-UX 11.11 (11iv1).  HP-UX 11iv1 and later are known to be good. The &ldquo;KSTAT&rdquo; mechanism is known to have problems on all versions of Solaris up to and including Solaris 10. Even the microstate accounting available via kstat in Solaris 10 has issues, though perhaps not as bad as those of prior versions.</para>
      <para>The /proc/stat mechanism under Linux is in what the author would consider an &ldquo;uncertain&rdquo; category as it appears to be statistical, which may also have issues with time spent processing interrupts.</para>
      <para>In summary, be sure to &ldquo;sanity-check&rdquo; the CPU utilization figures with other mechanisms.  However, platform tools such as top, vmstat or mpstat are often based on the same mechanisms used by netperf.</para>
    </section>
  </node>
  <node>
    <nodename>Global Command-line Options</nodename>
    <nodenext>Using Netperf to Measure Bulk Data Transfer</nodenext>
    <nodeprev>The Design of Netperf</nodeprev>
    <nodeup>Top</nodeup>
    <chapter>
      <title>Global Command-line Options</title>
      <para>This section describes each of the global command-line options available in the netperf and netserver binaries.  Essentially, it is an expanded version of the usage information displayed by netperf or netserver when invoked with the <option>-h</option> global command-line option.</para>
      <menu>
        <menuentry>
          <menunode>Command-line Options Syntax</menunode>
          <menutitle>Command-line Options Syntax</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Global Options</menunode>
          <menutitle>Global Options</menutitle>
          <menucomment></menucomment>
        </menuentry>
      </menu>
    </chapter>
  </node>
  <node>
    <nodename>Command-line Options Syntax</nodename>
    <nodenext>Global Options</nodenext>
    <nodeprev>Global Command-line Options</nodeprev>
    <nodeup>Global Command-line Options</nodeup>
<!-- node-name,  next,  previous,  up -->
    <section>
      <title>Command-line Options Syntax</title>
      <para>Revision 1.8 of netperf introduced enough new functionality to overrun the English alphabet for mnemonic command-line option names, and the author was not and is not quite ready to switch to the contemporary <option>--mumble</option> style of command-line options. (Call him a Luddite).</para>
      <para>For this reason, the command-line options were split into two parts - the first are the global command-line options.  They are options that affect nearly any and every test type of netperf.  The second type are the test-specific command-line options.  Both are entered on the same command line, but they must be separated from one another by a <code>--</code> for correct parsing.  Global command-line options come first, followed by the <code>--</code> and then test-specific command-line options.  If there are no test-specific options to be set, the <code>--</code> may be omitted.  If there are no global command-line options to be set, test-specific options must still be preceded by a <code>--</code>.  For example:</para>
      <example xml:space="preserve">netperf &lt;global&gt; -- &lt;test-specific&gt;</example>
      <para>sets both global and test-specific options:</para>
      <example xml:space="preserve">netperf &lt;global&gt;</example>
      <para>sets just global options and:</para>
      <example xml:space="preserve">netperf -- &lt;test-specific&gt;</example>
      <para>sets just test-specific options.</para>
    </section>
  </node>
  <node>
    <nodename>Global Options</nodename>
    <nodeprev>Command-line Options Syntax</nodeprev>
    <nodeup>Global Command-line Options</nodeup>
<!-- node-name,  next,  previous,  up -->
    <section>
      <title>Global Options</title>
      <table>
        <tableitem>
          <tableterm><code>-a &lt;sizespec&gt;</code></tableterm>
          <item>
            <para>This option allows you to alter the alignment of the buffers used in the sending and receiving calls on the local system.. Changing the alignment of the buffers can force the system to use different copy schemes, which can have a measurable effect on performance.  If the page size for the system were 4096 bytes, and you want to pass page-aligned buffers beginning on page boundaries, you could use <samp>-a 4096</samp>.  By default the units are bytes, but suffix of &ldquo;G,&rdquo; &ldquo;M,&rdquo; or &ldquo;K&rdquo; will specify the units to be 2^30 (GB), 2^20 (MB) or 2^10 (KB) respectively. A suffix of &ldquo;g,&rdquo; &ldquo;m&rdquo; or &ldquo;k&rdquo; will specify units of 10^9, 10^6 or 10^3 bytes respectively. [Default: 8 bytes]</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-A &lt;sizespec&gt;</code></tableterm>
          <item>
            <para>This option is identical to the <option>-a</option> option with the difference being it affects alignments for the remote system.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-b &lt;size&gt;</code></tableterm>
          <item>
            <para>This option is only present when netperf has been configure with &ndash;enable-intervals=yes prior to compilation.  It sets the size of the burst of send calls in a _STREAM test.  When used in conjunction with the <option>-w</option> option it can cause the rate at which data is sent to be &ldquo;paced.&rdquo;</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-c [rate]</code></tableterm>
          <item>
            <para>This option will ask that CPU utilization and service demand be calculated for the local system.  For those CPU utilization mechanisms requiring calibration, the options rate parameter may be specified to preclude running another calibration step, saving 40 seconds of time. For those CPU utilization mechanisms requiring no calibration, the optional rate parameter will be utterly and completely ignored. [Default: no CPU measurements]</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-C [rate]</code></tableterm>
          <item>
            <para>This option requests CPU utilization and service demand calculations for the remote system.  It is otherwise identical to the <option>-c</option> option.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-d</code></tableterm>
          <item>
            <para>Each instance of this option will increase the quantity of debugging output displayed during a test.  If the debugging output level is set high enough, it may have a measurable effect on performance. Debugging information for the local system is printed to stdout. Debugging information for the remote system is sent by default to the file <file>/tmp/netperf.debug</file>. [Default: no debugging output]</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-D [interval,units]</code></tableterm>
          <item>
            <para>This option is only available when netperf is configured with &ndash;enable-demo=yes.  When set, it will cause netperf to emit periodic reports of performance during the run.  [<var>interval</var>,<var>units</var>] follow the semantics of an optionspec. If specified, <var>interval</var> gives the minimum interval in real seconds, it does not have to be whole seconds.  The <var>units</var> value can be used for the first guess as to how many units of work (bytes or transactions) must be done to take at least <var>interval</var> seconds. If omitted, <var>interval</var> defaults to one second and <var>units</var> to values specific to each test type.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-f G|M|K|g|m|k</code></tableterm>
          <item>
            <para>This option can be used to change the reporting units for _STREAM tests.  Arguments of &ldquo;G,&rdquo; &ldquo;M,&rdquo; or &ldquo;K&rdquo; will set the units to 2^30, 2^20 or 2^10 bytes/s respectively (EG power of two GB, MB or KB).  Arguments of &ldquo;g,&rdquo; &ldquo;,m&rdquo; or &ldquo;k&rdquo; will set the units to 10^9, 10^6 or 10^3 bits/s respectively.  [Default: 'm' or 10^6 bits/s]</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-F &lt;fillfile&gt;</code></tableterm>
          <item>
            <para>This option specified the file from which send which buffers will be pre-filled .  While the buffers will contain data from the specified file, the file is not fully transfered to the remote system as the receiving end of the test will not write the contents of what it receives to a file.  This can be used to pre-fill the send buffers with data having different compressibility and so is useful when measuring performance over mechanisms which perform compression.</para>
            <para>While optional for most tests, this option is required for a test utilizing the sendfile() or related calls because sendfile tests need a name of a file to reference.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-h</code></tableterm>
          <item>
            <para>This option causes netperf to display its usage string and exit to the exclusion of all else.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-H &lt;optionspec&gt;</code></tableterm>
          <item>
            <para>This option will set the name of the remote system and or the address family used for the control connection.  For example:</para>
            <example xml:space="preserve">-H linger,4</example>
            <para>will set the name of the remote system to &ldquo;tardy&rdquo; and tells netperf to use IPv4 addressing only.</para>
            <example xml:space="preserve">-H ,6</example>
            <para>will leave the name of the remote system at its default, and request that only IPv6 addresses be used for the control connection.</para>
            <example xml:space="preserve">-H lag</example>
            <para>will set the name of the remote system to &ldquo;lag&rdquo; and leave the address family to AF_UNSPEC which means selection of IPv4 vs IPv6 is left to the system's address resolution.</para>
            <para>A value of &ldquo;inet&rdquo; can be used in place of &ldquo;4&rdquo; to request IPv4 only addressing.  Similarly, a value of &ldquo;inet6&rdquo; can be used in place of &ldquo;6&rdquo; to request IPv6 only addressing.  A value of &ldquo;0&rdquo; can be used to request either IPv4 or IPv6 addressing as name resolution dictates.</para>
            <para>By default, the options set with the global <option>-H</option> option are inherited by the test for their data connections, unless a test-specific <option>-H</option> option is specified.</para>
            <para>If a <option>-H</option> option follows either the <option>-4</option> or <option>-6</option> options, the family setting specified with the -H option will override the <option>-4</option> or <option>-6</option> options for the remote address family. If no address family is specified, settings from a previous <option>-4</option> or <option>-6</option> option will remain.  In a nutshell, the last explicit global command-line option wins.</para>
            <para>[Default:  &ldquo;localhost&rdquo; for the remote name/IP address and &ldquo;0&rdquo; (eg AF_UNSPEC) for the remote address family.]</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-L &lt;optionspec&gt;</code></tableterm>
          <item>
            <para>This option is identical to the <option>-H</option> option with the difference being it sets the _local_ hostname/IP and/or address family information.  This option is generally unnecessary, but can be useful when you wish to make sure that the netperf control and data connections go via different paths.  It can also come-in handy if one is trying to run netperf through those evil, end-to-end breaking things known as firewalls.</para>
            <para>[Default: 0.0.0.0 (eg INADDR_ANY) for IPv4 and ::0 for IPv6 for the local name.  AF_UNSPEC for the local address family.]</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-I &lt;optionspec&gt;</code></tableterm>
          <item>
            <para>This option enables the calculation of confidence intervals and sets the confidence and width parameters with the first have of the optionspec being either 99 or 95 for 99% or 95% confidence respectively.  The second value of the optionspec specifies the width of the desired confidence interval.  For example</para>
            <example xml:space="preserve">-I 99,5</example>
            <para>asks netperf to be 99% confident that the measured mean values for throughput and CPU utilization are within +/- 2.5% of the &ldquo;real&rdquo; mean values.  If the <option>-i</option> option is specified and the <option>-I</option> option is omitted, the confidence defaults to 99% and the width to 5% (giving +/- 2.5%)</para>
            <para>If netperf calculates that the desired confidence intervals have not been met, it emits a noticeable warning that cannot be suppressed with the <option>-P</option> or <option>-v</option> options:</para>
            <example xml:space="preserve">netperf -H tardy.cup -i 3 -I 99,5
TCP STREAM TEST from 0.0.0.0 (0.0.0.0) port 0 AF_INET to tardy.cup.hp.com (15.244.44.58) port 0 AF_INET : +/-2.5% &space;99% conf.
!!! WARNING
!!! Desired confidence was not achieved within the specified iterations.
!!! This implies that there was variability in the test environment that
!!! must be investigated before going further.
!!! Confidence intervals: Throughput      :  6.8%
!!!                       Local CPU util  :  0.0%
!!!                       Remote CPU util :  0.0%

Recv   Send    Send
Socket Socket  Message  Elapsed
Size   Size    Size     Time     Throughput
bytes  bytes   bytes    secs.    10^6bits/sec

 32768  16384  16384    10.01      40.23</example>
            <para>Where we see that netperf did not meet the desired convidence intervals.  Instead of being 99% confident it was within +/- 2.5% of the real mean value of throughput it is only confident it was within +/-3.4%.  In this example, increasing the <option>-i</option> option (described below) and/or increasing the iteration length with the <option>-l</option> option might resolve the situation.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-i &lt;sizespec&gt;</code></tableterm>
          <item>
            <para>This option enables the calculation of confidence intervals and sets the minimum and maximum number of iterations to run in attempting to achieve the desired confidence interval.  The first value sets the maximum number of iterations to run, the second, the minimum.  The maximum number of iterations is silently capped at 30 and the minimum is silently floored at 3.  Netperf repeats the measurement the minimum number of iterations and continues until it reaches either the desired confidence interval, or the maximum number of iterations, whichever comes first.</para>
            <para>If the <option>-I</option> option is specified and the <option>-i</option> option omitted the maximum number of iterations is set to 10 and the minimum to three.</para>
            <para>If netperf determines that the desired confidence intervals have not been met, it emits a noticeable warning.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-l testlen</code></tableterm>
          <item>
            <para>This option controls the length of any one iteration of the requested test.  A positive value for <var>testlen</var> will run each iteration of the test for at least <var>testlen</var> seconds.  A negative value for <var>testlen</var> will run each iteration for the absolute value of <var>testlen</var> transactions for a _RR test or bytes for a _STREAM test. Certain tests, notably those using UDP can only be timed, they cannot be limited by transaction or byte count.</para>
            <para>In some situations, individual iterations of a test may run for longer for the number of seconds specified by the <option>-l</option> option.  In particular, this may occur for those tests where the socket buffer size(s) are significantly longer than the bandwidthXdelay product of the link(s) over which the data connection passes, or those tests where there may be non-trivial numbers of retransmissions.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-n numcpus</code></tableterm>
          <item>
            <para>This option tells netperf how many CPUs it should ass-u-me are active on the system running netperf.  In particular, this is used for the <xref><xrefnodename>CPU Utilization</xrefnodename><xrefinfoname>CPU utilization</xrefinfoname></xref> and service demand calculations. On certain systems, netperf is able to determine the number of CPU's automagically. This option will override any number netperf might be able to determine on its own.</para>
            <para>Note that this option does _not_ set the number of CPUs on the system running netserver.  When netperf/netserver cannot automagically determine the number of CPUs that can only be set for netserver via a netserver <option>-n</option> command-line option.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-o &lt;sizespec&gt;</code></tableterm>
          <item>
            <para>The value(s) passed-in with this option will be used as an offset added to the alignment specified with the <option>-a</option> option.  For example:</para>
            <example xml:space="preserve">-o 3 -a 4096</example>
            <para>will cause the buffers passed to the local send and receive calls to begin three bytes past an address aligned to 4096 bytes. [Default: 0 bytes]</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-O &lt;sizespec&gt;</code></tableterm>
          <item>
            <para>This option behaves just as the <option>-o</option> option by on the remote system and in conjunction with the <option>-A</option> option. [Default: 0 bytes]</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-p &lt;optionspec&gt;</code></tableterm>
          <item>
            <para>The first value of the optionspec passed-in with this option tells netperf the port number at which it should expect the remote netserver to be listening for control connections.  The second value of the optionspec will request netperf to bind to that local port number before establishing the control connection.  For example</para>
            <example xml:space="preserve">-p 12345</example>
            <para>tells netperf that the remote netserver is listening on port 12345 and leaves selection of the local port number for the control connection up to the local TCP/IP stack whereas</para>
            <example xml:space="preserve">-p ,32109</example>
            <para>leaves the remote netserver port at the default value of 12865 and causes netperf to bind to the local port number 32109 before connecting to the remote netserver.</para>
            <para>In general, setting the local port number is only necessary when one is looking to run netperf through those evil, end-to-end breaking things known as firewalls.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-P 0|1</code></tableterm>
          <item>
            <para>A value of &ldquo;1&rdquo; for the <option>-P</option> option will enable display of the test banner.  A value of &ldquo;0&rdquo; will disable display of the test banner. One might want to disable display of the test banner when running the same basic test type (eg TCP_STREAM) multiple times in succession where the test banners would then simply be redundant and unnecessarily clutter the output. [Default: 1 - display test banners]</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-t testname</code></tableterm>
          <item>
            <para>This option is used to tell netperf which test you wish to run.  As of this writing, valid values for <var>testname</var> include:</para>
            <itemize>
              <itemfunction>&bullet;</itemfunction>
              <item>
                <para><xref><xrefnodename>TCP_STREAM</xrefnodename></xref>, <xref><xrefnodename>TCP_MAERTS</xrefnodename></xref>, <xref><xrefnodename>TCP_SENDFILE</xrefnodename></xref>, <xref><xrefnodename>TCP_RR</xrefnodename></xref>, <xref><xrefnodename>TCP_CRR</xrefnodename></xref>, <xref><xrefnodename>TCP_CC</xrefnodename></xref></para>
              </item>
              <item>
                <para><xref><xrefnodename>UDP_STREAM</xrefnodename></xref>, <xref><xrefnodename>UDP_RR</xrefnodename></xref></para>
              </item>
              <item>
                <para><xref><xrefnodename>XTI_TCP_STREAM</xrefnodename></xref>,  <xref><xrefnodename>XTI_TCP_RR</xrefnodename></xref>, <xref><xrefnodename>XTI_TCP_CRR</xrefnodename></xref>, <xref><xrefnodename>XTI_TCP_CC</xrefnodename></xref></para>
              </item>
              <item>
                <para><xref><xrefnodename>XTI_UDP_STREAM</xrefnodename></xref>, <xref><xrefnodename>XTI_UDP_RR</xrefnodename></xref></para>
              </item>
              <item>
                <para><xref><xrefnodename>SCTP_STREAM</xrefnodename></xref>, <xref><xrefnodename>SCTP_RR</xrefnodename></xref></para>
              </item>
              <item>
                <para><xref><xrefnodename>DLCO_STREAM</xrefnodename></xref>, <xref><xrefnodename>DLCO_RR</xrefnodename></xref>,  <xref><xrefnodename>DLCL_STREAM</xrefnodename></xref>, <xref><xrefnodename>DLCL_RR</xrefnodename></xref></para>
              </item>
              <item>
                <para><xref><xrefnodename>Other Netperf Tests</xrefnodename><xrefinfoname>LOC_CPU</xrefinfoname></xref>, <xref><xrefnodename>Other Netperf Tests</xrefnodename><xrefinfoname>REM_CPU</xrefinfoname></xref></para>
              </item>
            </itemize>
            <para>Not all tests are always compiled into netperf.  In particular, the &ldquo;XTI,&rdquo; &ldquo;SCTP,&rdquo; &ldquo;UNIX,&rdquo; and &ldquo;DL*&rdquo; tests are only included in netperf when configured with <option>--enable-[xti|sctp|unix|dlpi]=yes</option>.</para>
            <para>Netperf only runs one type of test no matter how many <option>-t</option> options may be present on the command-line.  The last <option>-t</option> global command-line option will determine the test to be run. [Default: TCP_STREAM]</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-v verbosity</code></tableterm>
          <item>
            <para>This option controls how verbose netperf will be in its output, and is often used in conjunction with the <option>-P</option> option. If the verbosity is set to a value of &ldquo;0&rdquo; then only the test's SFM (Single Figure of Merit) is displayed.  If local <xref><xrefnodename>CPU Utilization</xrefnodename><xrefinfoname>CPU utilization</xrefinfoname></xref> is requested via the <option>-c</option> option then the SFM is the local service demand.  Othersise, if remote CPU utilization is requested via the <option>-C</option> option then the SFM is the remote service demand.  If neither local nor remote CPU utilization are requested the SFM will be the measured throughput or transaction rate as implied by the test specified with the <option>-t</option> option.</para>
            <para>If the verbosity level is set to &ldquo;1&rdquo; then the &ldquo;normal&rdquo; netperf result output for each test is displayed.</para>
            <para>If the verbosity level is set to &ldquo;2&rdquo; then &ldquo;extra&rdquo; information will be displayed.  This may include, but is not limited to the number of send or recv calls made and the average number of bytes per send or recv call, or a histogram of the time spent in each send() call or for each transaction if netperf was configured with <option>--enable-histogram=yes</option>. [Default: 1 - normal verbosity]</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-w time</code></tableterm>
          <item>
            <para>If netperf was configured with <option>--enable-intervals=yes</option> then this value will set the inter-burst time to time milliseconds, and the <option>-b</option> option will set the number of sends per burst.  The actual inter-burst time may vary depending on the system's timer resolution.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-W &lt;sizespec&gt;</code></tableterm>
          <item>
            <para>This option controls the number of buffers in the send (first or only value) and or receive (second or only value) buffer rings.  Unlike some benchmarks, netperf does not continuously send or receive from a single buffer.  Instead it rotates through a ring of buffers. [Default: One more than the size of the send or receive socket buffer sizes (<option>-s</option> and/or <option>-S</option> options) divided by the send <option>-m</option> or receive <option>-M</option> buffer size respectively]</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-4</code></tableterm>
          <item>
            <para>Specifying this option will set both the local and remote address families to AF_INET - that is use only IPv4 addresses on the control connection.  This can be overridden by a subsequent <option>-6</option>, <option>-H</option> or <option>-L</option> option.  Basically, the last option explicitly specifying an address family wins.  Unless overridden by a test-specific option, this will be inherited for the data connection as well.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-6</code></tableterm>
          <item>
            <para>Specifying this option will set both local and and remote address families to AF_INET6 - that is use only IPv6 addresses on the control connection.  This can be overridden by a subsequent <option>-4</option>, <option>-H</option> or <option>-L</option> option.  Basically, the last address family explicitly specified wins.  Unless overridden by a test-specific option, this will be inherited for the data connection as well.</para>
          </item>
        </tableitem>
      </table>
    </section>
  </node>
  <node>
    <nodename>Using Netperf to Measure Bulk Data Transfer</nodename>
    <nodenext>Using Netperf to Measure Request/Response</nodenext>
    <nodeprev>Global Command-line Options</nodeprev>
    <nodeup>Top</nodeup>
    <chapter>
      <title>Using Netperf to Measure Bulk Data Transfer</title>
      <para>The most commonly measured aspect of networked system performance is that of bulk or unidirectional transfer performance.  Everyone wants to know how many bits or bytes per second they can push across the network. The netperf convention for a bulk data transfer test name is to tack a &ldquo;_STREAM&rdquo; suffix to a test name.</para>
      <menu>
        <menuentry>
          <menunode>Issues in Bulk Transfer</menunode>
          <menutitle>Issues in Bulk Transfer</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Options common to TCP UDP and SCTP tests</menunode>
          <menutitle>Options common to TCP UDP and SCTP tests</menutitle>
          <menucomment></menucomment>
        </menuentry>
      </menu>
    </chapter>
  </node>
  <node>
    <nodename>Issues in Bulk Transfer</nodename>
    <nodenext>Options common to TCP UDP and SCTP tests</nodenext>
    <nodeprev>Using Netperf to Measure Bulk Data Transfer</nodeprev>
    <nodeup>Using Netperf to Measure Bulk Data Transfer</nodeup>
<!-- node-name,  next,  previous,  up -->
    <section>
      <title>Issues in Bulk Transfer</title>
      <para>There are any number of things which can affect the performance of a bulk transfer test.</para>
      <para>Certainly, absent compression, bulk-transfer tests can be limited by the speed of the slowest link in the path from the source to the destination.  If testing over a gigabit link, you will not see more than a gigabit :) Such situations can be described as being <dfn>network-limited</dfn> or <dfn>NIC-limited</dfn>.</para>
      <para>CPU utilization can also affect the results of a bulk-transfer test. If the networking stack requires a certain number of instructions or CPU cycles per KB of data transferred, and the CPU is limited in the number of instructions or cycles it can provide, then the transfer can be described as being <dfn>CPU-bound</dfn>.</para>
      <para>A bulk-transfer test can be CPU bound even when netperf reports less than 100% CPU utilization.  This can happen on an MP system where one or more of the CPUs saturate at 100% but other CPU's remain idle. Typically, a single flow of data, such as that from a single instance of a netperf _STREAM test cannot make use of much more than the power of one CPU.</para>
      <para>Distance and the speed-of-light can affect performance for a bulk-transfer; often this can be mitigated by using larger windows. One common limit to the performance of a transport using window-based flow-control is:</para>
      <example xml:space="preserve">Throughput &lt;= WindowSize/RoundTripTime</example>
      <para>As the sender can only have a window's-worth of data outstanding on the network at any one time, and the soonest the sender can receive a window update from the receiver is one RoundTripTime (RTT).  TCP and SCTP are examples of such protocols.</para>
      <para>Packet losses and their effects can be particularly bad for performance.  This is especially true if the packet losses result in retransmission timeouts for the protocol(s) involved.  By the time a retransmission timeout has happened, the flow or connection has sat idle for a considerable length of time.</para>
      <para>On many platforms, some variant on the <command>netstat</command> command can be used to retrieve statistics about packet loss and retransmission. For example:</para>
      <example xml:space="preserve">netstat -p tcp</example>
      <para>will retrieve TCP statistics on the HP-UX Operating System.  On other platforms, it may not be possible to retrieve statistics for a specific protocol and something like:</para>
      <example xml:space="preserve">netstat -s</example>
      <para>would be used instead.</para>
      <para>Many times, such network statistics are keep since the time the stack started, and we are only really interested in statistics from when netperf was running.  In such situations something along the lines of:</para>
      <example xml:space="preserve">netstat -p tcp &gt; before
netperf -t TCP_mumble...
netstat -p tcp &gt; after</example>
      <para>is indicated.  The <uref><urefurl>ftp://ftp.cup.hp.com/dist/networking/tools/</urefurl><urefdesc>beforeafter</urefdesc></uref> utility can be used to subtract the statistics in <file>before</file> from the statistics in <file>after</file></para>
      <example xml:space="preserve">beforeafter before after &gt; delta</example>
      <para>and then one can look at the statistics in <file>delta</file>.  While it was written with HP-UX's netstat in mind, the <uref><urefurl>ftp://ftp.cup.hp.com/dist/networking/briefs/annotated_netstat.txt</urefurl><urefdesc>annotated netstat</urefdesc></uref> writeup may be helpful with other platforms as well.</para>
    </section>
  </node>
  <node>
    <nodename>Options common to TCP UDP and SCTP tests</nodename>
    <nodeprev>Issues in Bulk Transfer</nodeprev>
    <nodeup>Using Netperf to Measure Bulk Data Transfer</nodeup>
<!-- node-name,  next,  previous,  up -->
    <section>
      <title>Options common to TCP UDP and SCTP tests</title>
      <para>Many &ldquo;test-specific&rdquo; options are actually common across the different tests.  For those tests involving TCP, UDP and SCTP, whether using the BSD Sockets or the XTI interface those common options include:</para>
      <table>
        <tableitem>
          <tableterm><code>-h</code></tableterm>
          <item>
            <para>Display the test-suite-specific usage string and exit.  For a TCP_ or UDP_ test this will be the usage string from the source file nettest_bsd.c.  For an XTI_ test, this will be the usage string from the source file nettest_xti.c.  For an SCTP test, this will be the usage string from the source file nettest_sctp.c.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-H &lt;optionspec&gt;</code></tableterm>
          <item>
            <para>Normally, the remote hostname|IP and address family information is inherited from the settings for the control connection (eg global command-line <option>-H</option>, <option>-4</option> and/or <option>-6</option> options). The test-specific <option>-H</option> will override those settings for the data (aka test) connection only.  Settings for the control connection are left unchanged.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-L &lt;optionspec&gt;</code></tableterm>
          <item>
            <para>The test-specific <option>-L</option> option is identical to the test-specific <option>-H</option> option except it affects the local hostname|IP and address family information.  As with its global command-line counterpart, this is generally only useful when measuring though those evil, end-to-end breaking things called firewalls.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-m bytes</code></tableterm>
          <item>
            <para>Set the size of the buffer passed-in to the &ldquo;send&rdquo; calls of a _STREAM test.  Note that this may have only an indirect effect on the size of the packets sent over the network, and certain Layer 4 protocols do _not_ preserve or enforce message boundaries, so setting <option>-m</option> for the send size does not necessarily mean the receiver will receive that many bytes at any one time. By default the units are bytes, but suffix of &ldquo;G,&rdquo; &ldquo;M,&rdquo; or &ldquo;K&rdquo; will specify the units to be 2^30 (GB), 2^20 (MB) or 2^10 (KB) respectively. A suffix of &ldquo;g,&rdquo; &ldquo;m&rdquo; or &ldquo;k&rdquo; will specify units of 10^9, 10^6 or 10^3 bytes respectively. For example:</para>
            <example xml:space="preserve"><code>-m 32K</code></example>
            <para>will set the size to 32KB or 32768 bytes. [Default: the local send socket buffer size for the connection - either the system's default or the value set via the <option>-s</option> option.]</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-M bytes</code></tableterm>
          <item>
            <para>Set the size of the buffer passed-in to the &ldquo;recv&rdquo; calls of a _STREAM test.  This will be an upper bound on the number of bytes received per receive call. By default the units are bytes, but suffix of &ldquo;G,&rdquo; &ldquo;M,&rdquo; or &ldquo;K&rdquo; will specify the units to be 2^30 (GB), 2^20 (MB) or 2^10 (KB) respectively.  A suffix of &ldquo;g,&rdquo; &ldquo;m&rdquo; or &ldquo;k&rdquo; will specify units of 10^9, 10^6 or 10^3 bytes respectively. For example:</para>
            <example xml:space="preserve"><code>-M 32K</code></example>
            <para>will set the size to 32KB or 32768 bytes. [Default: the remote receive socket buffer size for the data connection - either the system's default or the value set via the <option>-S</option> option.]</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-P &lt;optionspec&gt;</code></tableterm>
          <item>
            <para>Set the local and/or remote port numbers for the data connection.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-s &lt;sizespec&gt;</code></tableterm>
          <item>
            <para>This option sets the local send and receive socket buffer sizes for the control connection to the value(s) specified.  Often, this will affect the advertised and/or effective TCP or other window, but on some platforms it may not. By default the units are bytes, but suffix of &ldquo;G,&rdquo; &ldquo;M,&rdquo; or &ldquo;K&rdquo; will specify the units to be 2^30 (GB), 2^20 (MB) or 2^10 (KB) respectively.  A suffix of &ldquo;g,&rdquo; &ldquo;m&rdquo; or &ldquo;k&rdquo; will specify units of 10^9, 10^6 or 10^3 bytes respectively. For example:</para>
            <example xml:space="preserve"><code>-s 128K</code></example>
            <para>Will request the local send and receive socket buffer sizes to be 128KB or 131072 bytes.</para>
            <para>While the historic expectation is that setting the socket buffer size has a direct effect on say the TCP window, today that may not hold true for all stacks. Further, while the historic expectation is that the value specified in a setsockopt() call will be the value returned via a getsockopt() call, at least one stack is known to deliberately ignore history. [Default: 0 - use the system's default socket buffer sizes]</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-S &lt;sizespec&gt;</code></tableterm>
          <item>
            <para>This option sets the remote send and/or receive socket buffer sizes for the control connection to the value(s) specified.  Often, this will affect the advertised and/or effective TCP or other window, but on some platforms it may not. By default the units are bytes, but suffix of &ldquo;G,&rdquo; &ldquo;M,&rdquo; or &ldquo;K&rdquo; will specify the units to be 2^30 (GB), 2^20 (MB) or 2^10 (KB) respectively.  A suffix of &ldquo;g,&rdquo; &ldquo;m&rdquo; or &ldquo;k&rdquo; will specify units of 10^9, 10^6 or 10^3 bytes respectively. For example:</para>
            <example xml:space="preserve"><code>-s 128K</code></example>
            <para>Will request the local send and receive socket buffer sizes to be 128KB or 131072 bytes.</para>
            <para>While the historic expectation is that setting the socket buffer size has a direct effect on say the TCP window, today that may not hold true for all stacks.  Further, while the historic expectation is that the value specified in a setsockopt() call will be the value returned via a getsockopt() call, at least one stack is known to deliberately ignore history. [Default: 0 - use the system's default socket buffer sizes]</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-4</code></tableterm>
          <item>
            <para>Set the local and remote address family for the data connection to AF_INET - ie use IPv4 addressing only.  Just as with their global command-line counterparts the last of the <option>-4</option>, <option>-6</option>, <option>-H</option> or <option>-L</option> option wins for their respective address families.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-6</code></tableterm>
          <item>
            <para>This option is identical to its <option>-4</option> cousin, but requests IPv6 addresses for the local and remote ends of the data connection.</para>
          </item>
        </tableitem>
      </table>
      <menu>
        <menuentry>
          <menunode>TCP_STREAM</menunode>
          <menutitle>TCP_STREAM</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>TCP_MAERTS</menunode>
          <menutitle>TCP_MAERTS</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>TCP_SENDFILE</menunode>
          <menutitle>TCP_SENDFILE</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>UDP_STREAM</menunode>
          <menutitle>UDP_STREAM</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>XTI_TCP_STREAM</menunode>
          <menutitle>XTI_TCP_STREAM</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>XTI_UDP_STREAM</menunode>
          <menutitle>XTI_UDP_STREAM</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>SCTP_STREAM</menunode>
          <menutitle>SCTP_STREAM</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>DLCO_STREAM</menunode>
          <menutitle>DLCO_STREAM</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>DLCL_STREAM</menunode>
          <menutitle>DLCL_STREAM</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>STREAM_STREAM</menunode>
          <menutitle>STREAM_STREAM</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>DG_STREAM</menunode>
          <menutitle>DG_STREAM</menutitle>
          <menucomment></menucomment>
        </menuentry>
      </menu>
    </section>
  </node>
  <node>
    <nodename>TCP_STREAM</nodename>
    <nodenext>TCP_MAERTS</nodenext>
    <nodeprev>Options common to TCP UDP and SCTP tests</nodeprev>
    <nodeup>Options common to TCP UDP and SCTP tests</nodeup>
    <subsection>
      <title>TCP_STREAM</title>
      <para>The TCP_STREAM test is the default test in netperf.  It is quite simple, transferring some quantity of data from the system running netperf to the system running netserver.  While time spent establishing the connection is not included in the throughput calculation, time spent flushing the last of the data to the remote at the end of the test is.  This is how netperf knows that all the data it sent was received by the remote.  In addition to the <xref><xrefnodename>Options common to TCP UDP and SCTP tests</xrefnodename><xrefinfoname>options common to STREAM tests</xrefinfoname></xref>, the following test-specific options can be included to possibly alter the behavior of the test:</para>
      <table>
        <tableitem>
          <tableterm><code>-C</code></tableterm>
          <item>
            <para>This option will set TCP_CORK mode on the data connection on those systems where TCP_CORK is defined (typically Linux).  A full description of TCP_CORK is beyond the scope of this manual, but in a nutshell it forces sub-MSS sends to be buffered so every segment sent is Maximum Segment Size (MSS) unless the application performs an explicit flush operation or the connection is closed.  At present netperf does not perform an explicit flush operations.  Setting TCP_CORK may improve the bitrate of tests where the &ldquo;send size&rdquo; (<option>-m</option> option) is smaller than the MSS.  It should also improve (make smaller) the service demand.</para>
            <para>The Linux tcp(7) manpage states that TCP_CORK cannot be used in conjunction with TCP_NODELAY (set via the <option>-d</option> option), however netperf does not validate command-line options to enforce that.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-D</code></tableterm>
          <item>
            <para>This option will set TCP_NODELAY on the data connection on those systems where TCP_NODELAY is defined.  This disables something known as the Nagle Algorithm, which is intended to make the segments TCP sends as large as reasonably possible.  Setting TCP_NODELAY for a TCP_STREAM test should either have no effect when the send size (<option>-m</option> option) is larger than the MSS or will decrease reported bitrate and increase service demand when the send size is smaller than the MSS.  This stems from TCP_NODELAY causing each sub-MSS send to be its own TCP segment rather than being aggregated with other small sends.  This means more trips up and down the protocol stack per KB of data transferred, which means greater CPU utilization.</para>
            <para>If setting TCP_NODELAY with <option>-D</option> affects throughput and/or service demand for tests where the send size (<option>-m</option>) is larger than the MSS it suggests the TCP/IP stack's implementation of the Nagle Algorithm _may_ be broken, perhaps interpreting the Nagle Algorithm on a segment by segment basis rather than the proper user send by user send basis.  However, a better test of this can be achieved with the <xref><xrefnodename>TCP_RR</xrefnodename></xref> test.</para>
          </item>
        </tableitem>
      </table>
      <para>Here is an example of a basic TCP_STREAM test, in this case from a Debian Linux (2.6 kernel) system to an HP-UX 11iv2 (HP-UX 11.23) system:</para>
      <example xml:space="preserve">$ netperf -H lag
TCP STREAM TEST from 0.0.0.0 (0.0.0.0) port 0 AF_INET to lag.hpl.hp.com (15.4.89.214) port 0 AF_INET
Recv   Send    Send
Socket Socket  Message  Elapsed
Size   Size    Size     Time     Throughput
bytes  bytes   bytes    secs.    10^6bits/sec

 32768  16384  16384    10.00      80.42</example>
      <para>We see that the default receive socket buffer size for the receiver (lag - HP-UX 11.23) is 32768 bytes, and the default socket send buffer size for the sender (Debian 2.6 kernel) is 16384 bytes.  Througput is expressed as 10^6 (aka Mega) bits per second, and the test ran for 10 seconds.  IPv4 addresses (AF_INET) were used.</para>
    </subsection>
  </node>
  <node>
    <nodename>TCP_MAERTS</nodename>
    <nodenext>TCP_SENDFILE</nodenext>
    <nodeprev>TCP_STREAM</nodeprev>
    <nodeup>Options common to TCP UDP and SCTP tests</nodeup>
<!-- node-name,  next,  previous,  up -->
    <subsection>
      <title>TCP_MAERTS</title>
      <para>A TCP_MAERTS (MAERTS is STREAM backwards) test is &ldquo;just like&rdquo; a <xref><xrefnodename>TCP_STREAM</xrefnodename></xref> test except the data flows from the netserver to the netperf. The global command-line <option>-F</option> option is ignored for this test type.  The test-specific command-line <option>-C</option> option is ignored for this test type.</para>
      <para>Here is an example of a TCP_MAERTS test between the same two systems as in the example for the <xref><xrefnodename>TCP_STREAM</xrefnodename></xref> test.  This time we request larger socket buffers with <option>-s</option> and <option>-S</option> options:</para>
      <example xml:space="preserve">$ netperf -H lag -t TCP_MAERTS -- -s 128K -S 128K
TCP MAERTS TEST from 0.0.0.0 (0.0.0.0) port 0 AF_INET to lag.hpl.hp.com (15.4.89.214) port 0 AF_INET
Recv   Send    Send
Socket Socket  Message  Elapsed
Size   Size    Size     Time     Throughput
bytes  bytes   bytes    secs.    10^6bits/sec

221184 131072 131072    10.03      81.14</example>
      <para>Where we see that Linux, unlike HP-UX, may not return the same value in a getsockopt() as was requested in the prior setsockopt().</para>
      <para>This test is included more for benchmarking convenience than anything else.</para>
    </subsection>
  </node>
  <node>
    <nodename>TCP_SENDFILE</nodename>
    <nodenext>UDP_STREAM</nodenext>
    <nodeprev>TCP_MAERTS</nodeprev>
    <nodeup>Options common to TCP UDP and SCTP tests</nodeup>
<!-- node-name,  next,  previous,  up -->
    <subsection>
      <title>TCP_SENDFILE</title>
      <para>The TCP_SENDFILE test is &ldquo;just like&rdquo; a <xref><xrefnodename>TCP_STREAM</xrefnodename></xref> test except netperf calls the platform's equivalent to HP-UX's <code>sendfile()</code> instead of calling <code>send()</code>.  Often this results in a <dfn>zero-copy</dfn> operation where data is sent directly from the filesystem buffer cache.  This _should_ result in lower CPU utilization and possibly higher throughput.  If it does not, then you may want to contact your vendor(s) because they have a problem on their hands.</para>
      <para>Zero-copy mechanisms may also alter the characteristics (size and number of buffers per) of packets passed to the NIC.  In many stacks, when a copy is performed, the stack can &ldquo;reserve&rdquo; space at the beginning of the destination buffer for things like TCP, IP and Link headers.  This then has the packet contained in a single buffer which can be easier to DMA to the NIC.  When no copy is performed, there is no opportunity to reserve space for headers and so a packet will be contained in two or more buffers.</para>
      <para>The <xref><xrefnodename>Global Options</xrefnodename><xrefinfoname>global <option>-F</option> option</xrefinfoname></xref> is required for this test and it must specify a file of at least the size of the send ring (See <xref><xrefnodename>Global Options</xrefnodename><xrefinfoname>the global <option>-W</option> option</xrefinfoname></xref>.) multiplied by the send size (See <xref><xrefnodename>Options common to TCP UDP and SCTP tests</xrefnodename><xrefinfoname>the test-specific <option>-m</option> option</xrefinfoname></xref>.).  All other TCP-specific options are available and optional.</para>
      <para>In this first example:</para>
      <example xml:space="preserve">$ netperf -H lag -F ../src/netperf -t TCP_SENDFILE -- -s 128K -S 128K
TCP SENDFILE TEST from 0.0.0.0 (0.0.0.0) port 0 AF_INET to lag.hpl.hp.com (15.4.89.214) port 0 AF_INET
alloc_sendfile_buf_ring: specified file too small.
file must be larger than send_width * send_size</example>
      <para>we see what happens when the file is too small.  Here:</para>
      <example xml:space="preserve">$ ../src/netperf -H lag -F /boot/vmlinuz-2.6.8-1-686 -t TCP_SENDFILE -- -s 128K -S 128K
TCP SENDFILE TEST from 0.0.0.0 (0.0.0.0) port 0 AF_INET to lag.hpl.hp.com (15.4.89.214) port 0 AF_INET
Recv   Send    Send
Socket Socket  Message  Elapsed
Size   Size    Size     Time     Throughput
bytes  bytes   bytes    secs.    10^6bits/sec

131072 221184 221184    10.02      81.83</example>
      <para>we resolve that issue by selecting a larger file.</para>
    </subsection>
  </node>
  <node>
    <nodename>UDP_STREAM</nodename>
    <nodenext>XTI_TCP_STREAM</nodenext>
    <nodeprev>TCP_SENDFILE</nodeprev>
    <nodeup>Options common to TCP UDP and SCTP tests</nodeup>
    <subsection>
      <title>UDP_STREAM</title>
      <para>A UDP_STREAM test is similar to a <xref><xrefnodename>TCP_STREAM</xrefnodename></xref> test except UDP is used as the transport rather than TCP.</para>
      <para>A UDP_STREAM test has no end-to-end flow control - UDP provides none and neither does netperf.  However, if you wish, you can configure netperf with <code>--enable-intervals=yes</code> to enable the global command-line <option>-b</option> and <option>-w</option> options to pace bursts of traffic onto the network.</para>
      <para>This has a number of implications.</para>
      <para>The biggest of these implications is the data which is sent might not be received by the remote.  For this reason, the output of a UDP_STREAM test shows both the sending and receiving throughput.  On some platforms, it may be possible for the sending throughput to be reported as a value greater than the maximum rate of the link.  This is common when the CPU(s) are faster than the network and there is no <dfn>intra-stack</dfn> flow-control.</para>
      <para>Here is an example of a UDP_STREAM test between two systems connected by a 10 Gigabit Ethernet link:</para>
      <example xml:space="preserve">$ netperf -t UDP_STREAM -H 192.168.2.125 -- -m 32768
UDP UNIDIRECTIONAL SEND TEST from 0.0.0.0 (0.0.0.0) port 0 AF_INET to 192.168.2.125 (192.168.2.125) port 0 AF_INET
Socket  Message  Elapsed      Messages
Size    Size     Time         Okay Errors   Throughput
bytes   bytes    secs            #      #   10^6bits/sec

124928   32768   10.00      105672      0    2770.20
135168           10.00      104844           2748.50
</example>
      <para>The first line of numbers are statistics from the sending (netperf) side. The second line of numbers are from the receiving (netserver) side.  In this case, 105672 - 104844 or 828 messages did not make it all the way to the remote netserver process.</para>
      <para>If the value of the <option>-m</option> option is larger than the local send socket buffer size (<option>-s</option> option) netperf will likely abort with an error message about how the send call failed:</para>
      <example xml:space="preserve">netperf -t UDP_STREAM -H 192.168.2.125
UDP UNIDIRECTIONAL SEND TEST from 0.0.0.0 (0.0.0.0) port 0 AF_INET to 192.168.2.125 (192.168.2.125) port 0 AF_INET
udp_send: data send error: Message too long</example>
      <para>If the value of the <option>-m</option> option is larger than the remote socket receive buffer, the reported receive throughput will likely be zero as the remote UDP will discard the messages as being too large to fit into the socket buffer.</para>
      <example xml:space="preserve">$ netperf -t UDP_STREAM -H 192.168.2.125 -- -m 65000 -S 32768
UDP UNIDIRECTIONAL SEND TEST from 0.0.0.0 (0.0.0.0) port 0 AF_INET to 192.168.2.125 (192.168.2.125) port 0 AF_INET
Socket  Message  Elapsed      Messages
Size    Size     Time         Okay Errors   Throughput
bytes   bytes    secs            #      #   10^6bits/sec

124928   65000   10.00       53595      0    2786.99
 65536           10.00           0              0.00</example>
    </subsection>
  </node>
  <node>
    <nodename>XTI_TCP_STREAM</nodename>
    <nodenext>XTI_UDP_STREAM</nodenext>
    <nodeprev>UDP_STREAM</nodeprev>
    <nodeup>Options common to TCP UDP and SCTP tests</nodeup>
    <subsection>
      <title>XTI_TCP_STREAM</title>
      <para>An XTI_TCP_STREAM test is simply a <xref><xrefnodename>TCP_STREAM</xrefnodename></xref> test using the XTI rather than BSD Sockets interface.  The test-specific <option>-X &lt;devspec&gt;</option> option can be used to specify the name of the local and/or remote XTI device files, which is required by the <code>t_open()</code> call made by netperf XTI tests.</para>
      <para>The XTI_TCP_STREAM test is only present if netperf was configured with <code>--enable-xti=yes</code>.  The remote netserver must have also been configured with <code>--enable-xti=yes</code>.</para>
    </subsection>
  </node>
  <node>
    <nodename>XTI_UDP_STREAM</nodename>
    <nodenext>SCTP_STREAM</nodenext>
    <nodeprev>XTI_TCP_STREAM</nodeprev>
    <nodeup>Options common to TCP UDP and SCTP tests</nodeup>
    <subsection>
      <title>XTI_UDP_STREAM</title>
      <para>An XTI_UDP_STREAM test is simply a <xref><xrefnodename>UDP_STREAM</xrefnodename></xref> test using the XTI rather than BSD Sockets Interface.  The test-specific <option>-X &lt;devspec&gt;</option> option can be used to specify the name of the local and/or remote XTI device files, which is required by the <code>t_open()</code> call made by netperf XTI tests.</para>
      <para>The XTI_UDP_STREAM test is only present if netperf was configured with <code>--enable-xti=yes</code>. The remote netserver must have also been configured with <code>--enable-xti=yes</code>.</para>
    </subsection>
  </node>
  <node>
    <nodename>SCTP_STREAM</nodename>
    <nodenext>DLCO_STREAM</nodenext>
    <nodeprev>XTI_UDP_STREAM</nodeprev>
    <nodeup>Options common to TCP UDP and SCTP tests</nodeup>
    <subsection>
      <title>SCTP_STREAM</title>
      <para>An SCTP_STREAM test is essentially a <xref><xrefnodename>TCP_STREAM</xrefnodename></xref> test using the SCTP rather than TCP.  The <option>-D</option> option will set SCTP_NODELAY, which is much like the TCP_NODELAY option for TCP.  The <option>-C</option> option is not applicable to an SCTP test as there is no corresponding SCTP_CORK option.  The author is still figuring-out what the <option>-N</option> option does :)</para>
      <para>The SCTP_STREAM test is only present if netperf was configured with <code>--enable-sctp=yes</code>. The remote netserver must have also been configured with <code>--enable-sctp=yes</code>.</para>
    </subsection>
  </node>
  <node>
    <nodename>DLCO_STREAM</nodename>
    <nodenext>DLCL_STREAM</nodenext>
    <nodeprev>SCTP_STREAM</nodeprev>
    <nodeup>Options common to TCP UDP and SCTP tests</nodeup>
    <subsection>
      <title>DLCO_STREAM</title>
      <para>A DLPI Connection Oriented Stream (DLCO_STREAM) test is very similar in concept to a <xref><xrefnodename>TCP_STREAM</xrefnodename></xref> test.  Both use reliable, connection-oriented protocols.  The DLPI test differs from the TCP test in that its protocol operates only at the link-level and does not include TCP-style segmentation and reassembly.  This last difference means that the value  passed-in  with the <option>-m</option> option must be less than the interface MTU.  Otherwise, the <option>-m</option> and <option>-M</option> options are just like their TCP/UDP/SCTP counterparts.</para>
      <para>Other DLPI-specific options include:</para>
      <table>
        <tableitem>
          <tableterm><code>-D &lt;devspec&gt;</code></tableterm>
          <item>
            <para>This option is used to provide the fully-qualified names for the local and/or remote DPLI device files.  The syntax is otherwise identical to that of a <dfn>sizespec</dfn>.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-p &lt;ppaspec&gt;</code></tableterm>
          <item>
            <para>This option is used to specify the local and/or remote DLPI PPA(s). The PPA is used to identify the interface over which traffic is to be sent/received. The syntax of a <dfn>ppaspec</dfn> is otherwise the same as a <dfn>sizespec</dfn>.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-s sap</code></tableterm>
          <item>
            <para>This option specifies the 802.2 SAP for the test.  A SAP is somewhat like either the port field of a TCP or UDP header or the protocol field of an IP header.  The specified SAP should not conflict with any other active SAPs on the specified PPA's (<option>-p</option> option).</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-w &lt;sizespec&gt;</code></tableterm>
          <item>
            <para>This option specifies the local send and receive window sizes in units of frames on those platforms which support setting such things.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-W &lt;sizespec&gt;</code></tableterm>
          <item>
            <para>This option specifies the remote send and receive window sizes in units of frames on those platforms which support setting such things.</para>
          </item>
        </tableitem>
      </table>
      <para>The DLCO_STREAM test is only present if netperf was configured with <code>--enable-dlpi=yes</code>. The remote netserver must have also been configured with <code>--enable-dlpi=yes</code>.</para>
    </subsection>
  </node>
  <node>
    <nodename>DLCL_STREAM</nodename>
    <nodenext>STREAM_STREAM</nodenext>
    <nodeprev>DLCO_STREAM</nodeprev>
    <nodeup>Options common to TCP UDP and SCTP tests</nodeup>
    <subsection>
      <title>DLCL_STREAM</title>
      <para>A DLPI ConnectionLess Stream (DLCL_STREAM) test is analogous to a <xref><xrefnodename>UDP_STREAM</xrefnodename></xref> test in that both make use of unreliable/best-effort, connection-less transports.  The DLCL_STREAM test differs from the <xref><xrefnodename>UDP_STREAM</xrefnodename></xref> test in that the message size (<option>-m</option> option) must always be less than the link MTU as there is no IP-like fragmentation and reassembly available and netperf does not presume to provide one.</para>
      <para>The test-specific command-line options for a DLCL_STREAM test are the same as those for a <xref><xrefnodename>DLCO_STREAM</xrefnodename></xref> test.</para>
      <para>The DLCL_STREAM test is only present if netperf was configured with <code>--enable-dlpi=yes</code>. The remote netserver must have also been configured with <code>--enable-dlpi=yes</code>.</para>
    </subsection>
  </node>
  <node>
    <nodename>STREAM_STREAM</nodename>
    <nodenext>DG_STREAM</nodenext>
    <nodeprev>DLCL_STREAM</nodeprev>
    <nodeup>Options common to TCP UDP and SCTP tests</nodeup>
<!-- node-name,  next,  previous,  up -->
    <subsection>
      <title>STREAM_STREAM</title>
      <para>A Unix Domain Stream Socket Stream test (STREAM_STREAM) is similar in concept to a <xref><xrefnodename>TCP_STREAM</xrefnodename></xref> test, but using Unix Domain sockets.  It is, naturally, limited to intra-machine traffic.  A STREAM_STREAM test shares the <option>-m</option>, <option>-M</option>, <option>-s</option> and <option>-S</option> options of the other _STREAM tests.  In a STREAM_STREAM test the <option>-p</option> option sets the directory in which the pipes will be created rather than setting a port number.  The default is to create the pipes in the system default for the <code>tempnam()</code> call.</para>
      <para>The STREAM_STREAM test is only present if netperf was configured with <code>--enable-unix=yes</code>. The remote netserver must have also been configured with <code>--enable-unix=yes</code>.</para>
    </subsection>
  </node>
  <node>
    <nodename>DG_STREAM</nodename>
    <nodeprev>STREAM_STREAM</nodeprev>
    <nodeup>Options common to TCP UDP and SCTP tests</nodeup>
<!-- node-name,  next,  previous,  up -->
    <subsection>
      <title>DG_STREAM</title>
      <para>A Unix Domain Datagram Socket Stream test (SG_STREAM) is very much like a <xref><xrefnodename>TCP_STREAM</xrefnodename></xref> test except that message boundaries are preserved. In this way, it may also be considered similar to certain flavors of SCTP test which can also preserve message boundaries.</para>
      <para>All the options of a <xref><xrefnodename>STREAM_STREAM</xrefnodename></xref> test are applicable to a DG_STREAM test.</para>
      <para>The DG_STREAM test is only present if netperf was configured with <code>--enable-unix=yes</code>. The remote netserver must have also been configured with <code>--enable-unix=yes</code>.</para>
    </subsection>
  </node>
  <node>
    <nodename>Using Netperf to Measure Request/Response</nodename>
    <nodenext>Other Netperf Tests</nodenext>
    <nodeprev>Using Netperf to Measure Bulk Data Transfer</nodeprev>
    <nodeup>Top</nodeup>
    <chapter>
      <title>Using Netperf to Measure Request/Response</title>
      <para>Request/response performance is often overlooked, yet it is just as important as bulk-transfer performance.  While things like larger socket buffers and TCP windows can cover a multitude of latency and even path-length sins, they cannot easily hide from a request/response test.  The convention for a request/response test is to have a _RR suffix.  There are however a few &ldquo;request/response&rdquo; tests that have other suffixes.</para>
      <para>A request/response test, particularly synchronous, one transaction at at time test such as those found in netperf, is particularly sensitive to the path-length of the networking stack.  An _RR test can also uncover those platforms where the NIC's are strapped by default with overbearing interrupt avoidance settings in an attempt to increase the bulk-transfer performance (or rather, decrease the CPU utilization of a bulk-transfer test).  This sensitivity is most acute for small request and response sizes, such as the single-byte default for a netperf _RR test.</para>
      <para>While a bulk-transfer test reports its results in units of bits or bytes transfered per second, a mumble_RR test reports transactions per second where a transaction is defined as the completed exchange of a request and a response.  One can invert the transaction rate to arrive at the average round-trip latency.  If one is confident about the symmetry of the connection, the average one-way latency can be taken as one-half the average round-trip latency.  Netperf does not do either of these on its own but leaves them as exercises to the benchmarker.</para>
      <menu>
        <menuentry>
          <menunode>Issues in Request/Response</menunode>
          <menutitle>Issues in Request/Response</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Options Common to TCP UDP and SCTP _RR tests</menunode>
          <menutitle>Options Common to TCP UDP and SCTP _RR tests</menutitle>
          <menucomment></menucomment>
        </menuentry>
      </menu>
    </chapter>
  </node>
  <node>
    <nodename>Issues in Request/Response</nodename>
    <nodenext>Options Common to TCP UDP and SCTP _RR tests</nodenext>
    <nodeprev>Using Netperf to Measure Request/Response</nodeprev>
    <nodeup>Using Netperf to Measure Request/Response</nodeup>
<!-- node-name,  next,  previous,  up -->
    <section>
      <title>Issues in Reqeust/Response</title>
      <para>Most if not all the <xref><xrefnodename>Issues in Bulk Transfer</xrefnodename></xref> apply to request/response.  The issue of round-trip latency is even more important as netperf only has one transaction outstanding at a time.</para>
      <para>A single instance of an _RR test should _never_ completely saturate the CPU of a system.  If testing between otherwise evenly matched systems, the symmetric nature of a _RR test with equal request and response sizes should result in equal CPU loading on both systems.</para>
      <para>For smaller request and response sizes packet loss is a bigger issue as there is no opportunity for a <dfn>fast retransmit</dfn> or retransmission prior to a retrnamission timer expiring.</para>
      <para>Certain NICs have ways to minimize the number of interrupts sent to the host.  If these are strapped badly they can significantly reduce the performance of something like a single-byte request/response test. Such setups are distinguised by seriously low reported CPU utilization and what seems like a low (even if in the thousands) transaction per second rate.  Also, if you run such an OS/driver combination on faster or slower hardware and do not see a corresponding change in the transaction rate, chances are good that the drvier is strapping the NIC with aggressive interrupt avoidance settings.  Good for bulk throughput, but bad for latency.</para>
      <para>Some drivers may try to automagically adjust the interrupt avoidance settings.  If they are not terribly good at it, you will see considerable run-to-run variation in reported transaction rates. Particularly if you &ldquo;mix-up&rdquo; _STREAM and _RR tests.</para>
    </section>
  </node>
  <node>
    <nodename>Options Common to TCP UDP and SCTP _RR tests</nodename>
    <nodeprev>Issues in Request/Response</nodeprev>
    <nodeup>Using Netperf to Measure Request/Response</nodeup>
<!-- node-name,  next,  previous,  up -->
    <section>
      <title>Options Common to TCP UDP and SCTP _RR tests</title>
      <para>Many &ldquo;test-specific&rdquo; options are actually common across the different tests.  For those tests involving TCP, UDP and SCTP, whether using the BSD Sockets or the XTI interface those common options include:</para>
      <table>
        <tableitem>
          <tableterm><code>-h</code></tableterm>
          <item>
            <para>Display the test-suite-specific usage string and exit.  For a TCP_ or UDP_ test this will be the usage string from the source file <file>nettest_bsd.c</file>.  For an XTI_ test, this will be the usage string from the source file <file>src/nettest_xti.c</file>.  For an SCTP test, this will be the usage string from the source file <file>src/nettest_sctp.c</file>.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-H &lt;optionspec&gt;</code></tableterm>
          <item>
            <para>Normally, the remote hostname|IP and address family information is inherited from the settings for the control connection (eg global command-line <option>-H</option>, <option>-4</option> and/or <option>-6</option> options. The test-specific <option>-H</option> will override those settings for the data (aka test) connection only.  Settings for the control connection are left unchanged.  This might be used to cause the control and data connections to take different paths through the network.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-L &lt;optionspec&gt;</code></tableterm>
          <item>
            <para>The test-specific <option>-L</option> option is identical to the test-specific <option>-H</option> option except it affects the local hostname|IP and address family information.  As with its global command-line counterpart, this is generally only useful when measuring though those evil, end-to-end breaking things called firewalls.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-P &lt;optionspec&gt;</code></tableterm>
          <item>
            <para>Set the local and/or remote port numbers for the data connection.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-r &lt;sizespec&gt;</code></tableterm>
          <item>
            <para>This option sets the request (first value) and/or response (second value) sizes for an _RR test. By default the units are bytes, but a suffix of &ldquo;G,&rdquo; &ldquo;M,&rdquo; or &ldquo;K&rdquo; will specify the units to be 2^30 (GB), 2^20 (MB) or 2^10 (KB) respectively.  A suffix of &ldquo;g,&rdquo; &ldquo;m&rdquo; or &ldquo;k&rdquo; will specify units of 10^9, 10^6 or 10^3 bytes respectively. For example:</para>
            <example xml:space="preserve"><code>-r 128,16K</code></example>
            <para>Will set the request size to 128 bytes and the response size to 16 KB or 16384 bytes. [Default: 1 - a single-byte request and response ]</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-s &lt;sizespec&gt;</code></tableterm>
          <item>
            <para>This option sets the local send and receive socket buffer sizes for the control connection to the value(s) specified.  Often, this will affect the advertised and/or effective TCP or other window, but on some platforms it may not. By default the units are bytes, but a suffix of &ldquo;G,&rdquo; &ldquo;M,&rdquo; or &ldquo;K&rdquo; will specify the units to be 2^30 (GB), 2^20 (MB) or 2^10 (KB) respectively.  A suffix of &ldquo;g,&rdquo; &ldquo;m&rdquo; or &ldquo;k&rdquo; will specify units of 10^9, 10^6 or 10^3 bytes respectively. For example:</para>
            <example xml:space="preserve"><code>-s 128K</code></example>
            <para>Will request the local send and receive socket buffer sizes to be 128KB or 131072 bytes.</para>
            <para>While the historic expectation is that setting the socket buffer size has a direct effect on say the TCP window, today that may not hold true for all stacks. [Default: 0 - use the system's default socket buffer sizes]</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-S &lt;sizespec&gt;</code></tableterm>
          <item>
            <para>This option sets the remote send and/or receive socket buffer sizes for the control connection to the value(s) specified.  Often, this will affect the advertised and/or effective TCP or other window, but on some platforms it may not. By default the units are bytes, but a suffix of &ldquo;G,&rdquo; &ldquo;M,&rdquo; or &ldquo;K&rdquo; will specify the units to be 2^30 (GB), 2^20 (MB) or 2^10 (KB) respectively.  A suffix of &ldquo;g,&rdquo; &ldquo;m&rdquo; or &ldquo;k&rdquo; will specify units of 10^9, 10^6 or 10^3 bytes respectively. For example:</para>
            <example xml:space="preserve"><code>-s 128K</code></example>
            <para>Will request the local send and receive socket buffer sizes to be 128KB or 131072 bytes.</para>
            <para>While the historic expectation is that setting the socket buffer size has a direct effect on say the TCP window, today that may not hold true for all stacks. [Default: 0 - use the system's default socket buffer sizes]</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-4</code></tableterm>
          <item>
            <para>Set the local and remote address family for the data connection to AF_INET - ie use IPv4 addressing only.  Just as with their global command-line counterparts the last of the <option>-4</option>, <option>-6</option>, <option>-H</option> or <option>-L</option> option wins for their respective address families.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-6</code></tableterm>
          <item>
            <para>This option is identical to its <option>-4</option> cousin, but requests IPv6 addresses for the local and remote ends of the data connection.</para>
          </item>
        </tableitem>
      </table>
      <menu>
        <menuentry>
          <menunode>TCP_RR</menunode>
          <menutitle>TCP_RR</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>TCP_CC</menunode>
          <menutitle>TCP_CC</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>TCP_CRR</menunode>
          <menutitle>TCP_CRR</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>UDP_RR</menunode>
          <menutitle>UDP_RR</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>XTI_TCP_RR</menunode>
          <menutitle>XTI_TCP_RR</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>XTI_TCP_CC</menunode>
          <menutitle>XTI_TCP_CC</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>XTI_TCP_CRR</menunode>
          <menutitle>XTI_TCP_CRR</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>XTI_UDP_RR</menunode>
          <menutitle>XTI_UDP_RR</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>DLCL_RR</menunode>
          <menutitle>DLCL_RR</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>DLCO_RR</menunode>
          <menutitle>DLCO_RR</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>SCTP_RR</menunode>
          <menutitle>SCTP_RR</menutitle>
          <menucomment></menucomment>
        </menuentry>
      </menu>
    </section>
  </node>
  <node>
    <nodename>TCP_RR</nodename>
    <nodenext>TCP_CC</nodenext>
    <nodeprev>Options Common to TCP UDP and SCTP _RR tests</nodeprev>
    <nodeup>Options Common to TCP UDP and SCTP _RR tests</nodeup>
    <subsection>
      <title>TCP_RR</title>
      <para>A TCP_RR (TCP Request/Response) test is requested by passing a value of &ldquo;TCP_RR&rdquo; to the global <option>-t</option> command-line option.  A TCP_RR test can be though-of as a user-space to user-space <code>ping</code> with no think time - it is a synchronous, one transaction at a time, request/response test.</para>
      <para>The transaction rate is the number of complete transactions exchanged divided by the length of time it took to perform those transactions.</para>
      <para>If the two Systems Under Test are otherwise identical, a TCP_RR test with the same request and response size should be symmetric - it should not matter which way the test is run, and the CPU utilization measured should be virtually the same on each system.  If not, it suggests that the CPU utilization mechanism being used may have some, well, issues measuring CPU utilization completely and accurately.</para>
      <para>Time to establish the TCP connection is not counted in the result.  If you want connection setup overheads included, you should consider the TCP_CC or TCP_CRR tests.</para>
      <para>If specifying the <option>-D</option> option to set TCP_NODELAY and disable the Nagle Algorithm increases the transaction rate reported by a TCP_RR test, it implies the stack(s) over which the TCP_RR test is running have a broken implementation of the Nagle Algorithm.  Likely as not they are interpreting Nagle on a segment by segment basis rather than a user send by user send basis.  You should contact your stack vendor(s) to report the problem to them.</para>
      <para>Here is an example of two systems running a basic TCP_RR test over a 10 Gigabit Ethernet link:</para>
      <example xml:space="preserve">netperf -t TCP_RR -H 192.168.2.125
TCP REQUEST/RESPONSE TEST from 0.0.0.0 (0.0.0.0) port 0 AF_INET to 192.168.2.125 (192.168.2.125) port 0 AF_INET
Local /Remote
Socket Size   Request  Resp.   Elapsed  Trans.
Send   Recv   Size     Size    Time     Rate
bytes  Bytes  bytes    bytes   secs.    per sec

16384  87380  1        1       10.00    29150.15
16384  87380</example>
      <para>In this example the request and response sizes were one byte, the socket buffers were left at their defaults, and the test ran for all of 10 seconds.  The transaction per second rate was rather good :)</para>
    </subsection>
  </node>
  <node>
    <nodename>TCP_CC</nodename>
    <nodenext>TCP_CRR</nodenext>
    <nodeprev>TCP_RR</nodeprev>
    <nodeup>Options Common to TCP UDP and SCTP _RR tests</nodeup>
    <subsection>
      <title>TCP_CC</title>
      <para>A TCP_CC (TCP Connect/Close) test is requested by passing a value of &ldquo;TCP_CC&rdquo; to the global <option>-t</option> option.  A TCP_CC test simply measures how fast the pair of systems can open and close connections between one another in a synchronous (one at a time) manner.  While this is considered an _RR test, no request or response is exchanged over the connection.</para>
      <para>The issue of TIME_WAIT reuse is an important one for a TCP_CC test. Basically, TIME_WAIT reuse is when a pair of systems churn through connections fast enough that they wrap the 16-bit port number space in less time than the length of the TIME_WAIT state.  While it is indeed theoretically possible to &ldquo;reuse&rdquo; a connection in TIME_WAIT, the conditions under which such reuse is possible is rather rare.  An attempt to reuse a connection in TIME_WAIT can result in a non-trivial delay in connection establishment.</para>
      <para>Basically, any time the connection churn rate approaches:</para>
      <para>Sizeof(clientportspace) / Lengthof(TIME_WAIT)</para>
      <para>there is the risk of TIME_WAIT reuse.  To minimize the chances of this happening, netperf will by default select its own client port numbers from the range of 5000 to 65535.  On systems with a 60 second TIME_WAIT state, this should allow roughly 1000 transactions per second.  The size of the client port space used by netperf can be controlled via the test-specific <option>-p</option> option, which takes a <dfn>sizespec</dfn> as a value setting the minimum (first value) and maximum (second value) port numbers used by netperf at the client end.</para>
      <para>Since no requests or responses are exchanged during a TCP_CC test, only the <option>-H</option>, <option>-L</option>, <option>-4</option> and <option>-6</option> of the &ldquo;common&rdquo; test-specific options are likely to have an effect, if any, on the results.  The <option>-s</option> and <option>-S</option> options _may_ have some effect if they alter the number and/or type of options carried in the TCP SYNchronize segments.  The <option>-P</option>  and <option>-r</option> options are utterly ignored.</para>
      <para>Since connection establishment and tear-down for TCP is not symmetric, a TCP_CC test is not symmetric in its loading of the two systems under test.</para>
    </subsection>
  </node>
  <node>
    <nodename>TCP_CRR</nodename>
    <nodenext>UDP_RR</nodenext>
    <nodeprev>TCP_CC</nodeprev>
    <nodeup>Options Common to TCP UDP and SCTP _RR tests</nodeup>
    <subsection>
      <title>TCP_CRR</title>
      <para>The TCP Connect/Request/Response (TCP_CRR) test is requested by passing a value of &ldquo;TCP_CRR&rdquo; to the global <option>-t</option> command-line option.  A TCP_RR test is like a merger of a TCP_RR and TCP_CC test which measures the performance of establishing a connection, exchanging a single request/response transaction, and tearing-down that connection.  This is very much like what happens in an HTTP 1.0 or HTTP 1.1 connection when HTTP Keepalives are not used.  In fact, the TCP_CRR test was added to netperf to simulate just that.</para>
      <para>Since a request and response are exchanged the <option>-r</option>, <option>-s</option> and <option>-S</option> options can have an effect on the performance.</para>
      <para>The issue of TIME_WAIT reuse exists for the TCP_CRR test just as it does for the TCP_CC test.  Similarly, since connection establishment and tear-down is not symmetric, a TCP_CRR test is not symmetric even when the request and response sizes are the same.</para>
    </subsection>
  </node>
  <node>
    <nodename>UDP_RR</nodename>
    <nodenext>XTI_TCP_RR</nodenext>
    <nodeprev>TCP_CRR</nodeprev>
    <nodeup>Options Common to TCP UDP and SCTP _RR tests</nodeup>
    <subsection>
      <title>UDP_RR</title>
      <para>A UDP Request/Response (UDP_RR) test is requested by passing a value of &ldquo;UDP_RR&rdquo; to a global <option>-t</option> option.  It is very much the same as a TCP_RR test except UDP is used rather than TCP.</para>
      <para>UDP does not provide for retransmission of lost UDP datagrams, and netperf does not add anything for that either.  This means that if _any_ request or response is lost, the exchange of requests and responses will stop from that point until the test timer expires. Netperf will not really &ldquo;know&rdquo; this has happened - the only symptom will be a low transaction per second rate.</para>
      <para>The netperf side of a UDP_RR test will call <code>connect()</code> on its data socket and thenceforth use the <code>send()</code> and <code>recv()</code> socket calls.  The netserver side of a UDP_RR test will not call <code>connect()</code> and will use <code>recvfrom()</code> and <code>sendto()</code> calls.  This means that even if the request and response sizes are the same, a UDP_RR test is _not_ symmetric in its loading of the two systems under test.</para>
      <para>Here is an example of a UDP_RR test between two otherwise identical two-CPU systems joined via a 1 Gigabit Ethernet network:</para>
      <example xml:space="preserve">$ netperf -T 1 -H 192.168.1.213 -t UDP_RR -c -C
UDP REQUEST/RESPONSE TEST from 0.0.0.0 (0.0.0.0) port 0 AF_INET to 192.168.1.213 (192.168.1.213) port 0 AF_INET
Local /Remote
Socket Size   Request Resp.  Elapsed Trans.   CPU    CPU    S.dem   S.dem
Send   Recv   Size    Size   Time    Rate     local  remote local   remote
bytes  bytes  bytes   bytes  secs.   per sec  % I    % I    us/Tr   us/Tr

65535  65535  1       1      10.01   15262.48   13.90  16.11  18.221  21.116
65535  65535</example>
      <para>This example includes the <option>-c</option> and <option>-C</option> options to enable CPU utilization reporting and shows the asymmetry in CPU loading.  The <option>-T</option> option was used to make sure netperf and netserver ran on a given CPU and did not move around during the test.</para>
    </subsection>
  </node>
  <node>
    <nodename>XTI_TCP_RR</nodename>
    <nodenext>XTI_TCP_CC</nodenext>
    <nodeprev>UDP_RR</nodeprev>
    <nodeup>Options Common to TCP UDP and SCTP _RR tests</nodeup>
    <subsection>
      <title>XTI_TCP_RR</title>
      <para>An XTI_TCP_RR test is essentially the same as a <xref><xrefnodename>TCP_RR</xrefnodename></xref> test only using the XTI rather than BSD Sockets interface. It is requested by passing a value of &ldquo;XTI_TCP_RR&rdquo; to the <option>-t</option> global command-line option.</para>
      <para>The test-specific options for an XTI_TCP_RR test are the same as those for a TCP_RR test with the addition of the <option>-X &lt;devspec&gt;</option> option to specify the names of the local and/or remote XTI device file(s).</para>
    </subsection>
  </node>
  <node>
    <nodename>XTI_TCP_CC</nodename>
    <nodenext>XTI_TCP_CRR</nodenext>
    <nodeprev>XTI_TCP_RR</nodeprev>
    <nodeup>Options Common to TCP UDP and SCTP _RR tests</nodeup>
<!-- node-name,  next,  previous,  up -->
    <subsection>
      <title>XTI_TCP_CC</title>
    </subsection>
  </node>
  <node>
    <nodename>XTI_TCP_CRR</nodename>
    <nodenext>XTI_UDP_RR</nodenext>
    <nodeprev>XTI_TCP_CC</nodeprev>
    <nodeup>Options Common to TCP UDP and SCTP _RR tests</nodeup>
<!-- node-name,  next,  previous,  up -->
    <subsection>
      <title>XTI_TCP_CRR</title>
    </subsection>
  </node>
  <node>
    <nodename>XTI_UDP_RR</nodename>
    <nodenext>DLCL_RR</nodenext>
    <nodeprev>XTI_TCP_CRR</nodeprev>
    <nodeup>Options Common to TCP UDP and SCTP _RR tests</nodeup>
    <subsection>
      <title>XTI_UDP_RR</title>
      <para>An XTI_UDP_RR test is essentially the same as a UDP_RR test only using the XTI rather than BSD Sockets interface.  It is requested by passing a value of &ldquo;XTI_UDP_RR&rdquo; to the <option>-t</option> global command-line option.</para>
      <para>The test-specific options for an XTI_UDP_RR test are the same as those for a UDP_RR test with the addition of the <option>-X &lt;devspec&gt;</option> option to specify the name of the local and/or remote XTI device file(s).</para>
    </subsection>
  </node>
  <node>
    <nodename>DLCL_RR</nodename>
    <nodenext>DLCO_RR</nodenext>
    <nodeprev>XTI_UDP_RR</nodeprev>
    <nodeup>Options Common to TCP UDP and SCTP _RR tests</nodeup>
<!-- node-name,  next,  previous,  up -->
    <subsection>
      <title>DLCL_RR</title>
    </subsection>
  </node>
  <node>
    <nodename>DLCO_RR</nodename>
    <nodenext>SCTP_RR</nodenext>
    <nodeprev>DLCL_RR</nodeprev>
    <nodeup>Options Common to TCP UDP and SCTP _RR tests</nodeup>
<!-- node-name,  next,  previous,  up -->
    <subsection>
      <title>DLCO_RR</title>
    </subsection>
  </node>
  <node>
    <nodename>SCTP_RR</nodename>
    <nodeprev>DLCO_RR</nodeprev>
    <nodeup>Options Common to TCP UDP and SCTP _RR tests</nodeup>
<!-- node-name,  next,  previous,  up -->
    <subsection>
      <title>SCTP_RR</title>
    </subsection>
  </node>
  <node>
    <nodename>Other Netperf Tests</nodename>
    <nodenext>Address Resolution</nodenext>
    <nodeprev>Using Netperf to Measure Request/Response</nodeprev>
    <nodeup>Top</nodeup>
    <chapter>
      <title>Other Netperf Tests</title>
      <para>Apart from the typical performance tests, netperf contains some tests which can be used to streamline measurements and reporting.  These include CPU rate calibration (present) and host identification (future enhancement).</para>
      <menu>
        <menuentry>
          <menunode>CPU rate calibration</menunode>
          <menutitle>CPU rate calibration</menutitle>
          <menucomment></menucomment>
        </menuentry>
      </menu>
    </chapter>
  </node>
  <node>
    <nodename>CPU rate calibration</nodename>
    <nodeprev>Other Netperf Tests</nodeprev>
    <nodeup>Other Netperf Tests</nodeup>
    <section>
      <title>CPU rate calibration</title>
      <para>Some of the CPU utilization measurement mechanisms of netperf work by comparing the rate at which some counter increments when the system is idle with the rate at which that same counter increments when the system is running a netperf test.  The ratio of those rates is used to arrive at a CPU utilization percentage.</para>
      <para>This means that netperf must know the rate at which the counter increments when the system is presumed to be &ldquo;idle.&rdquo;  If it does not know the rate, netperf will measure it before starting a data transfer test.  This calibration step takes 40 seconds for each of the local or remote ystems, and if repeated for each netperf test would make taking repeated measurements rather slow.</para>
      <para>Thus, the netperf CPU utilization options <option>-c</option> and and <option>-C</option> can take an optional calibration value.  This value is used as the &ldquo;idle rate&rdquo; and the calibration step is not performed. To determine the idle rate, netperf can be used to run special tests which only report the value of the calibration - they are the LOC_CPU and REM_CPU tests.  These return the calibration value for the local and remote system respectively.  A common way to use these tests is to store their results into an environment variable and use that in subsequent netperf commands:</para>
      <example xml:space="preserve">LOC_RATE=`netperf -t LOC_CPU`
REM_RATE=`netperf -H &lt;remote&gt; -t REM_CPU`
netperf -H &lt;remote&gt; -c $LOC_RATE -C $REM_RATE ... -- ...
...
netperf -H &lt;remote&gt; -c $LOC_RATE -C $REM_RATE ... -- ...</example>
      <para>If you are going to use netperf to measure aggregate results, it is important to use the LOC_CPU and REM_CPU tests to get the calibration values first to avoid issues with some of the aggregate netperf tests transferring data while others are &ldquo;idle&rdquo; and getting bogus calibration values.  When running aggregate tests, it is very important to remember that any one instance of netperf does not know about the other instances of netperf.  It will report global CPU utilization and will calculate service demand believing it was the only thing causing that CPU utilization.  So, you can use the CPU utilization reported by netperf in an aggregate test, but you have to calculate service demands by hand.</para>
    </section>
  </node>
  <node>
    <nodename>Address Resolution</nodename>
    <nodenext>Enhancing Netperf</nodenext>
    <nodeprev>Other Netperf Tests</nodeprev>
    <nodeup>Top</nodeup>
<!-- node-name,  next,  previous,  up -->
    <chapter>
      <title>Address Resolution</title>
      <para>Netperf versions 2.4.0 and later have merged IPv4 and IPv6 tests so the functionality of the tests in <file>src/nettest_ipv6.c</file> has been subsumed into the tests in <file>src/nettest_bsd.c</file>  This has been accomplished in part by switching from <code>gethostbyname()</code>to <code>getaddrinfo()</code> exclusively.  While it was theoretically possible to get multiple results for a hostname from <code>gethostbyname()</code> it was generally unlikely and netperf's ignoring of the second and later results was not much of an issue.</para>
      <para>Now with <code>getaddrinfo</code> and particularly with AF_UNSPEC it is increasingly likely that a given hostname will have multiple associated addresses.  The <code>establish_control()</code> routine of <file>src/netlib.c</file> will indeed attempt to chose from among all the matching IP addresses when establishing the control connection. Netperf does not _really_ care if the control connection is IPv4 or IPv6 or even mixed on either end.</para>
      <para>However, the individual tests still ass-u-me that the first result in the address list is the one to be used.  Whether or not this will turn-out to be an issue has yet to be determined.</para>
      <para>If you do run into problems with this, the easiest workaround is to specify IP addresses for the data connection explicitly in the test-specific <option>-H</option> and <option>-L</option> options.  At some point, the netperf tests _may_ try to be more sophisticated in their parsing of returns from <code>getaddrinfo()</code> - straw-man patches to <email><emailaddress>netperf-feedback@netperf.org</emailaddress></email> would of course be most welcome :)</para>
      <para>Netperf has leveraged code from other open-source projects with amenable licensing to provide a replacement <code>getaddrinfo()</code> call on those platforms where the <command>configure</command> script believes there is no native getaddrinfo call.  As of this writing, the replacement <code>getaddrinfo()</code> as been tested on HP-UX 11.0 and then presumed to run elsewhere.</para>
    </chapter>
  </node>
  <node>
    <nodename>Enhancing Netperf</nodename>
    <nodenext>Index</nodenext>
    <nodeprev>Address Resolution</nodeprev>
    <nodeup>Top</nodeup>
<!-- node-name,  next,  previous,  up -->
    <chapter>
      <title>Enhancing Netperf</title>
      <para>Netperf is constantly evolving.  If you find you want to make enhancements to netperf, by all means do so.  If you wish to add a new &ldquo;suite&rdquo; of tests to netperf the general idea is to</para>
      <enumerate first="1">
        <item>
          <para>Add files <file>src/nettest_mumble.c</file> and <file>src/nettest_mumble.h</file> where mumble is replaced with something meaningful for the test-suite.</para>
        </item>
        <item>
          <para>Add support for an apropriate <option>--enable-mumble</option> option in <file>configure.ac</file>.</para>
        </item>
        <item>
          <para>Edit <file>src/netperf.c</file>, <file>netsh.c</file>, and <file>netserver.c</file> as required, using #ifdef WANT_MUMBLE.</para>
        </item>
        <item>
          <para>Compile and test</para>
        </item>
      </enumerate>
      <para>If you wish to submit your changes for possible inclusion into the mainline sources, please try to base your changes on the latest available sources. (See <xref><xrefnodename>Getting Netperf Bits</xrefnodename></xref>.) and then send email describing the changes at a high level to <email><emailaddress>netperf-feedback@netperf.org</emailaddress></email> or perhaps <email><emailaddress>netperf-talk@netperf.org</emailaddress></email>.  If the concensus is positive, then sending context <command>diff</command> results to <email><emailaddress>netperf-feedback@netperf.org</emailaddress></email> is the next step.  From that point, it is a matter of pestering the Netperf Contributing Editor until he gets the changes incorporated :)</para>
      <para>One of these days, it is hoped that some sort of public version control system will be setup - perhaps on netperf.org - to make this whole process easier.</para>
    </chapter>
  </node>
  <node>
    <nodename>Index</nodename>
    <nodeprev>Enhancing Netperf</nodeprev>
    <nodeup>Top</nodeup>
    <unnumbered>
      <title>Index</title>
      <printindex>cp</printindex>
    </unnumbered>
  </node>
</texinfo>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-indent-step:1
sgml-indent-data:nil
End:
-->
